#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_equation_separate(modergb, modealpha):
    '''
    set the RGB blend equation and the alpha blend equation separately.
    
    Args:
        modergb: the rgb blend equation, how the red, green, and blue components
            of the source and destination colors are combined.
        modealpha: the alpha blend equation, how the alpha component of the
            source and destination colors are combined.
    '''

@accepts(t.sizei, POINTER(t.enum))
@returns(t.void)
@binds(dll)
def draw_buffers(n, bufs):
    '''
    Specifies a list of color buffers to be drawn into.
    
    gl.draw_buffers and gl.named_framebuffer_draw_buffers define an array of
    buffers into which outputs from the fragment shader data will be written. If
    a fragment shader writes a value to one or more user defined output
    variables, then the value of each variable will be written into the buffer
    specified at a location within bufs corresponding to the location assigned
    to that user defined output. The draw buffer used for user defined outputs
    assigned to locations greater than or equal to n is implicitly set to
    gl.NONE and any data written to such an output is discarded.
    
    Args:
        n: the number of buffers in bufs.
        bufs: points to an array of symbolic constants specifying the buffers
            into which fragment colors or data values will be written.
    '''

@accepts(t.enum, t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def stencil_op_separate(face, sfail, dpfail, dppass):
    '''
    set front and/or back stencil test actions.
    
    gl.stencil_op_separate takes three arguments that indicate what happens to
    the stored stencil value while stenciling is enabled. If the stencil test
    fails, no change is made to the pixel's color or depth buffers, and sfail
    specifies what happens to the stencil buffer contents. The following eight
    actions are possible.
    
    Args:
        face: whether front and/or back stencil state is updated.
        sfail: the action to take when the stencil test fails.
        dpfail: the stencil action when the stencil test passes, but the depth
            test fails.
        dppass: the stencil action when both the stencil test and the depth test
            pass, or when the stencil test passes and either there is no depth
            buffer or depth testing is not enabled.
    '''

@accepts(t.enum, t.enum, t.int, t.uint)
@returns(t.void)
@binds(dll)
def stencil_func_separate(face, func, ref, mask):
    '''
    set front and/or back function and reference value for stencil testing.
    
    Args:
        face: whether front and/or back stencil state is updated.
        func: the test function.
        ref: the reference value for the stencil test.
        mask: a mask that is anded with both the reference value and the stored
            stencil value when the test is done.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def stencil_mask_separate(face, mask):
    '''
    control the front and/or back writing of individual bits in the stencil
    planes.
    
    gl.stencil_mask_separate controls the writing of individual bits in the
    stencil planes. The least significant n bits of mask, where.
    
    Args:
        face: whether the front and/or back stencil writemask is updated.
        mask: a bit mask to enable and disable writing of individual bits in the
            stencil planes.
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def attach_shader(program, shader):
    '''
    Attaches a shader object to a program object.
    
    Args:
        program: the program object to which a shader object will be attached.
        shader: the shader object that is to be attached.
    '''

@accepts(t.uint, t.uint, t.char_p)
@returns(t.void)
@binds(dll)
def bind_attrib_location(program, index, name):
    '''
    Associates a generic vertex attribute index with a named attribute variable.
    
    gl.bind_attrib_location is used to associate a user-defined attribute
    variable in the program object specified by program with a generic vertex
    attribute index. The name of the user-defined attribute variable is passed
    as a null terminated string in name. The generic vertex attribute index to
    be bound to this variable is specified by index. When program is made part
    of current state, values provided via the generic vertex attribute index
    will modify the value of the user-defined attribute variable specified by
    name.
    
    Args:
        program: the handle of the program object in which the association is to
            be made.
        index: the index of the generic vertex attribute to be bound.
        name: a null terminated string containing the name of the vertex shader
            attribute variable to which index is to be bound.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def compile_shader(shader):
    '''
    Compiles a shader object.
    
    gl.compile_shader compiles the source code strings that have been stored in
    the shader object specified by shader.
    
    Args:
        shader: the shader object to be compiled.
    '''

@accepts()
@returns(t.uint)
@binds(dll)
def create_program():
    '''
    Creates a program object.
    '''

@accepts(t.enum)
@returns(t.uint)
@binds(dll)
def create_shader(type):
    '''
    Creates a shader object.
    
    gl.create_shader creates an empty shader object and returns a non-zero value
    by which it can be referenced. A shader object is used to maintain the
    source code strings that define a shader. shaderType indicates the type of
    shader to be created. Five types of shader are supported.
    
    Args:
        type: the type of shader to be created.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def delete_program(program):
    '''
    Deletes a program object.
    
    gl.delete_program frees the memory and invalidates the name associated with
    the program object specified by program. This command effectively undoes the
    effects of a call to gl.create_program.
    
    Args:
        program: the program object to be deleted.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def delete_shader(shader):
    '''
    Deletes a shader object.
    
    gl.delete_shader frees the memory and invalidates the name associated with
    the shader object specified by shader. This command effectively undoes the
    effects of a call to gl.create_shader.
    
    Args:
        shader: the shader object to be deleted.
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def detach_shader(program, shader):
    '''
    Detaches a shader object from a program object to which it is attached.
    
    gl.detach_shader detaches the shader object specified by shader from the
    program object specified by program. This command can be used to undo the
    effect of the command gl.attach_shader.
    
    Args:
        program: the program object from which to detach the shader object.
        shader: the shader object to be detached.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def disable_vertex_attrib_array(index):
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def enable_vertex_attrib_array(index):
    '''
    Enable or disable a generic vertex attribute array.
    
    gl.enable_vertex_attrib_array and gl.enable_vertex_array_attrib enable the
    generic vertex attribute array specified by index.
    gl.enable_vertex_attrib_array uses currently bound vertex array object for
    the operation, whereas gl.enable_vertex_array_attrib updates state of the
    vertex array object with ID vaobj.
    
    Args:
        index: the index of the generic vertex attribute to be enabled or
            disabled.
    '''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.int), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_attrib(program, index, bufsize, length, size, type, name):
    '''
    Returns information about an active attribute variable for the specified
    program object.
    
    gl.get_active_attrib returns information about an active attribute variable
    in the program object specified by program. The number of active attributes
    can be obtained by calling gl.get_program with the value
    gl.ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active
    attribute variable. Permissible values for index range from zero to the
    number of active attribute variables minus one.
    
    Args:
        program: the program object to be queried.
        index: the index of the attribute variable to be queried.
        bufsize: the maximum number of characters opengl is allowed to write in
            the character buffer indicated by name.
        length: returns the number of characters actually written by opengl in
            the string indicated by name (excluding the null terminator) if a
            value other than null is passed.
        size: returns the size of the attribute variable.
        type: returns the data type of the attribute variable.
        name: returns a null terminated string containing the name of the
            attribute variable.
    '''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.int), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_uniform(program, index, bufsize, length, size, type, name):
    '''
    Returns information about an active uniform variable for the specified
    program object.
    
    gl.get_active_uniform returns information about an active uniform variable
    in the program object specified by program. The number of active uniform
    variables can be obtained by calling gl.get_program with the value
    gl.ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform
    variable. Permissible values for index range from zero to the number of
    active uniform variables minus one.
    
    Args:
        program: the program object to be queried.
        index: the index of the uniform variable to be queried.
        bufsize: the maximum number of characters opengl is allowed to write in
            the character buffer indicated by name.
        length: returns the number of characters actually written by opengl in
            the string indicated by name (excluding the null terminator) if a
            value other than null is passed.
        size: returns the size of the uniform variable.
        type: returns the data type of the uniform variable.
        name: returns a null terminated string containing the name of the
            uniform variable.
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_attached_shaders(program, maxcount, count, shaders):
    '''
    Returns the handles of the shader objects attached to a program object.
    
    gl.get_attached_shaders returns the names of the shader objects attached to
    program. The names of shader objects that are attached to program will be
    returned in shaders. The actual number of shader names written into shaders
    is returned in count. If no shader objects are attached to program, count is
    set to 0.
    
    Args:
        program: the program object to be queried.
        maxcount: the size of the array for storing the returned object names.
        count: returns the number of names actually returned in shaders.
        shaders: an array that is used to return the names of attached shader
            objects.
    '''

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_attrib_location(program, name):
    '''
    Returns the location of an attribute variable.
    
    gl.get_attrib_location queries the previously linked program object
    specified by program for the attribute variable specified by name and
    returns the index of the generic vertex attribute that is bound to that
    attribute variable. If name is a matrix attribute variable, the index of the
    first column of the matrix is returned. If the named attribute variable is
    not an active attribute in the specified program object or if name starts
    with the reserved prefix "gl_", a value of -1 is returned.
    
    Args:
        program: the program object to be queried.
        name: points to a null terminated string containing the name of the
            attribute variable whose location is to be queried.
    '''

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_programiv(program, pname, params):
    pass

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_program_info_log(program, bufsize, length, infolog):
    '''
    Returns the information log for a program object.
    
    gl.get_program_info_log returns the information log for the specified
    program object. The information log for a program object is modified when
    the program object is linked or validated. The string that is returned will
    be null terminated.
    
    Args:
        program: the program object whose information log is to be queried.
        bufsize: the size of the character buffer for storing the returned
            information log.
        length: returns the length of the string returned in infolog (excluding
            the null terminator).
        infolog: an array of characters that is used to return the information
            log.
    '''

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_shaderiv(shader, pname, params):
    pass

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_shader_info_log(shader, bufsize, length, infolog):
    '''
    Returns the information log for a shader object.
    
    gl.get_shader_info_log returns the information log for the specified shader
    object. The information log for a shader object is modified when the shader
    is compiled. The string that is returned will be null terminated.
    
    Args:
        shader: the shader object whose information log is to be queried.
        bufsize: the size of the character buffer for storing the returned
            information log.
        length: returns the length of the string returned in infolog (excluding
            the null terminator).
        infolog: an array of characters that is used to return the information
            log.
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_shader_source(shader, bufsize, length, source):
    '''
    Returns the source code string from a shader object.
    
    gl.get_shader_source returns the concatenation of the source code strings
    from the shader object specified by shader. The source code strings for a
    shader object are the result of a previous call to gl.shader_source. The
    string returned by the function will be null terminated.
    
    Args:
        shader: the shader object to be queried.
        bufsize: the size of the character buffer for storing the returned
            source code string.
        length: returns the length of the string returned in source (excluding
            the null terminator).
        source: an array of characters that is used to return the source code
            string.
    '''

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_uniform_location(program, name):
    '''
    Returns the location of a uniform variable.
    
    gl.get_uniform_location returns an integer that represents the location of a
    specific uniform variable within a program object. name must be a null
    terminated string that contains no white space. name must be an active
    uniform variable name in program that is not a structure, an array of
    structures, or a subcomponent of a vector or a matrix. This function returns
    -1 if name does not correspond to an active uniform variable in program, if
    name starts with the reserved prefix "gl_", or if name is associated with an
    atomic counter or a named uniform block.
    
    Args:
        program: the program object to be queried.
        name: points to a null terminated string containing the name of the
            uniform variable whose location is to be queried.
    '''

@accepts(t.uint, t.int, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_uniformfv(program, location, params):
    pass

@accepts(t.uint, t.int, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_uniformiv(program, location, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def get_vertex_attribdv(index, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_vertex_attribfv(index, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_vertex_attribiv(index, pname, params):
    pass

@accepts(t.uint, t.enum, t.void)
@returns(t.void)
@binds(dll)
def get_vertex_attrib_pointerv(index, pname, pointer):
    '''
    return the address of the specified generic vertex attribute pointer.
    
    gl.get_vertex_attrib_pointerv returns pointer information. index is the
    generic vertex attribute to be queried, pname is a symbolic constant
    indicating the pointer to be returned, and params is a pointer to a location
    in which to place the returned data.
    
    Args:
        index: the generic vertex attribute parameter to be returned.
        pname: the symbolic name of the generic vertex attribute parameter to be
            returned.
        pointer: returns the pointer value.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_program(program):
    '''
    Determines if a name corresponds to a program object.
    
    gl.is_program returns gl.TRUE if program is the name of a program object
    previously created with gl.create_program and not yet deleted with
    gl.delete_program. If program is zero or a non-zero value that is not the
    name of a program object, or if an error occurs, gl.is_program returns
    gl.FALSE.
    
    Args:
        program: a potential program object.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_shader(shader):
    '''
    Determines if a name corresponds to a shader object.
    
    gl.is_shader returns gl.TRUE if shader is the name of a shader object
    previously created with gl.create_shader and not yet deleted with
    gl.delete_shader. If shader is zero or a non-zero value that is not the name
    of a shader object, or if an error occurs, gl.is_shader returns gl.FALSE.
    
    Args:
        shader: a potential shader object.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def link_program(program):
    '''
    Links a program object.
    
    gl.link_program links the program object specified by program. If any shader
    objects of type gl.VERTEX_SHADER are attached to program, they will be used
    to create an executable that will run on the programmable vertex processor.
    If any shader objects of type gl.GEOMETRY_SHADER are attached to program,
    they will be used to create an executable that will run on the programmable
    geometry processor. If any shader objects of type gl.FRAGMENT_SHADER are
    attached to program, they will be used to create an executable that will run
    on the programmable fragment processor.
    
    Args:
        program: the handle of the program object to be linked.
    '''

@accepts(t.uint, t.sizei, POINTER(t.char_p), POINTER(t.int))
@returns(t.void)
@binds(dll)
def shader_source(shader, count, string, length):
    '''
    Replaces the source code in a shader object.
    
    gl.shader_source sets the source code in shader to the source code in the
    array of strings specified by string. Any source code previously stored in
    the shader object is completely replaced. The number of strings in the array
    is specified by count. If length is None, each string is assumed to be null
    terminated.
    
    Args:
        shader: the handle of the shader object whose source code is to be
            replaced.
        count: the number of elements in the string and length arrays.
        string: an array of pointers to strings containing the source code to be
            loaded into the shader.
        length: an array of string lengths.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def use_program(program):
    '''
    Installs a program object as part of current rendering state.
    
    gl.use_program installs the program object specified by program as part of
    current rendering state. One or more executables are created in a program
    object by successfully attaching shader objects to it with gl.attach_shader,
    successfully compiling the shader objects with gl.compile_shader, and
    successfully linking the program object with gl.link_program.
    
    Args:
        program: the handle of the program object whose executables are to be
            used as part of current rendering state.
    '''

@accepts(t.int, t.float)
@returns(t.void)
@binds(dll)
def uniform1f(location, v0):
    pass

@accepts(t.int, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform2f(location, v0, v1):
    pass

@accepts(t.int, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform3f(location, v0, v1, v2):
    pass

@accepts(t.int, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform4f(location, v0, v1, v2, v3):
    pass

@accepts(t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform1i(location, v0):
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform2i(location, v0, v1):
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform3i(location, v0, v1, v2):
    pass

@accepts(t.int, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform4i(location, v0, v1, v2, v3):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform1fv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform2fv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform3fv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform4fv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform1iv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform2iv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform3iv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform4iv(location, count, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix2fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix3fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix4fv(location, count, transpose, value):
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def validate_program(program):
    '''
    Validates a program object.
    
    gl.validate_program checks to see whether the executables contained in
    program can execute given the current OpenGL state. The information
    generated by the validation process will be stored in program's information
    log. The validation information may consist of an empty string, or it may be
    a string containing information about how the current program object
    interacts with the rest of current OpenGL state. This provides a way for
    OpenGL implementers to convey more information about why the current program
    is inefficient, suboptimal, failing to execute, and so on.
    
    Args:
        program: the handle of the program object to be validated.
    '''

@accepts(t.uint, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib1d(index, x):
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib1dv(index, v):
    pass

@accepts(t.uint, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib1f(index, x):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib1fv(index, v):
    pass

@accepts(t.uint, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib1s(index, x):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib1sv(index, v):
    pass

@accepts(t.uint, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib2d(index, x, y):
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib2dv(index, v):
    pass

@accepts(t.uint, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib2f(index, x, y):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib2fv(index, v):
    pass

@accepts(t.uint, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib2s(index, x, y):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib2sv(index, v):
    pass

@accepts(t.uint, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib3d(index, x, y, z):
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib3dv(index, v):
    pass

@accepts(t.uint, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib3f(index, x, y, z):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib3fv(index, v):
    pass

@accepts(t.uint, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib3s(index, x, y, z):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib3sv(index, v):
    pass

@accepts(t.uint, POINTER(t.byte))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nbv(index, v):
    pass

@accepts(t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex_attrib4_niv(index, v):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nsv(index, v):
    pass

@accepts(t.uint, t.ubyte, t.ubyte, t.ubyte, t.ubyte)
@returns(t.void)
@binds(dll)
def vertex_attrib4_nub(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nubv(index, v):
    pass

@accepts(t.uint, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nuiv(index, v):
    pass

@accepts(t.uint, POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nusv(index, v):
    pass

@accepts(t.uint, POINTER(t.byte))
@returns(t.void)
@binds(dll)
def vertex_attrib4bv(index, v):
    pass

@accepts(t.uint, t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib4d(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib4dv(index, v):
    pass

@accepts(t.uint, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib4f(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib4fv(index, v):
    pass

@accepts(t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex_attrib4iv(index, v):
    pass

@accepts(t.uint, t.short, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib4s(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib4sv(index, v):
    pass

@accepts(t.uint, POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def vertex_attrib4ubv(index, v):
    pass

@accepts(t.uint, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def vertex_attrib4uiv(index, v):
    pass

@accepts(t.uint, POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def vertex_attrib4usv(index, v):
    pass

@accepts(t.uint, t.int, t.enum, t.boolean, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def vertex_attrib_pointer(index, size, type, normalized, stride, pointer):
    '''
    define an array of generic vertex attribute data.
    
    gl.vertex_attrib_pointer, gl.vertex_attrib_i_pointer and
    gl.vertex_attrib_l_pointer specify the location and data format of the array
    of generic vertex attributes at index index to use when rendering. size
    specifies the number of components per attribute and must be 1, 2, 3, 4, or
    gl.BGRA. type specifies the data type of each component, and stride
    specifies the byte stride from one attribute to the next, allowing vertices
    and attributes to be packed into a single array or stored in separate
    arrays.
    
    Args:
        index: the index of the generic vertex attribute to be modified.
        size: the number of components per generic vertex attribute.
        type: the data type of each component in the array.
        normalized: for glvertexattribpointer, specifies whether fixed-point
            data values should be normalized (gl_true) or converted directly as
            fixed-point values (gl_false) when they are accessed.
        stride: the byte offset between consecutive generic vertex attributes.
        pointer: a offset of the first component of the first generic vertex
            attribute in the array in the data store of the buffer currently
            bound to the gl_array_buffer target.
    '''

BLEND_EQUATION_RGB = 0x8009
VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622
VERTEX_ATTRIB_ARRAY_SIZE = 0x8623
VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624
VERTEX_ATTRIB_ARRAY_TYPE = 0x8625
CURRENT_VERTEX_ATTRIB = 0x8626
VERTEX_PROGRAM_POINT_SIZE = 0x8642
VERTEX_ATTRIB_ARRAY_POINTER = 0x8645
STENCIL_BACK_FUNC = 0x8800
STENCIL_BACK_FAIL = 0x8801
STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802
STENCIL_BACK_PASS_DEPTH_PASS = 0x8803
MAX_DRAW_BUFFERS = 0x8824
DRAW_BUFFER0 = 0x8825
DRAW_BUFFER1 = 0x8826
DRAW_BUFFER2 = 0x8827
DRAW_BUFFER3 = 0x8828
DRAW_BUFFER4 = 0x8829
DRAW_BUFFER5 = 0x882A
DRAW_BUFFER6 = 0x882B
DRAW_BUFFER7 = 0x882C
DRAW_BUFFER8 = 0x882D
DRAW_BUFFER9 = 0x882E
DRAW_BUFFER10 = 0x882F
DRAW_BUFFER11 = 0x8830
DRAW_BUFFER12 = 0x8831
DRAW_BUFFER13 = 0x8832
DRAW_BUFFER14 = 0x8833
DRAW_BUFFER15 = 0x8834
BLEND_EQUATION_ALPHA = 0x883D
MAX_VERTEX_ATTRIBS = 0x8869
VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A
MAX_TEXTURE_IMAGE_UNITS = 0x8872
FRAGMENT_SHADER = 0x8B30
VERTEX_SHADER = 0x8B31
MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49
MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A
MAX_VARYING_FLOATS = 0x8B4B
MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
SHADER_TYPE = 0x8B4F
FLOAT_VEC2 = 0x8B50
FLOAT_VEC3 = 0x8B51
FLOAT_VEC4 = 0x8B52
INT_VEC2 = 0x8B53
INT_VEC3 = 0x8B54
INT_VEC4 = 0x8B55
BOOL = 0x8B56
BOOL_VEC2 = 0x8B57
BOOL_VEC3 = 0x8B58
BOOL_VEC4 = 0x8B59
FLOAT_MAT2 = 0x8B5A
FLOAT_MAT3 = 0x8B5B
FLOAT_MAT4 = 0x8B5C
SAMPLER_1D = 0x8B5D
SAMPLER_2D = 0x8B5E
SAMPLER_3D = 0x8B5F
SAMPLER_CUBE = 0x8B60
SAMPLER_1D_SHADOW = 0x8B61
SAMPLER_2D_SHADOW = 0x8B62
DELETE_STATUS = 0x8B80
COMPILE_STATUS = 0x8B81
LINK_STATUS = 0x8B82
VALIDATE_STATUS = 0x8B83
INFO_LOG_LENGTH = 0x8B84
ATTACHED_SHADERS = 0x8B85
ACTIVE_UNIFORMS = 0x8B86
ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87
SHADER_SOURCE_LENGTH = 0x8B88
ACTIVE_ATTRIBUTES = 0x8B89
ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A
FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B
SHADING_LANGUAGE_VERSION = 0x8B8C
CURRENT_PROGRAM = 0x8B8D
POINT_SPRITE_COORD_ORIGIN = 0x8CA0
LOWER_LEFT = 0x8CA1
UPPER_LEFT = 0x8CA2
STENCIL_BACK_REF = 0x8CA3
STENCIL_BACK_VALUE_MASK = 0x8CA4
STENCIL_BACK_WRITEMASK = 0x8CA5
VERTEX_PROGRAM_TWO_SIDE = 0x8643
POINT_SPRITE = 0x8861
COORD_REPLACE = 0x8862
MAX_TEXTURE_COORDS = 0x8871