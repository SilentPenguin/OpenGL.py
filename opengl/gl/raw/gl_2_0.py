#BEWARE: automatically generated code
#This code was generated by opengl/gl/generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_equation_separate(modergb, modealpha):
    '''
    set the RGB blend equation and the alpha blend equation separately
    
    Args:
        modergb: specifies the RGB blend equation, how the red, green, and blue components of the source and destination colors are combined
        modealpha: specifies the alpha blend equation, how the alpha component of the source and destination colors are combined
    '''

@accepts(t.sizei, POINTER(t.enum))
@returns(t.void)
@binds(dll)
def draw_buffers(n, bufs):
    '''
    Specifies a list of color buffers to be drawn into
    
    Args:
        n: Specifies the number of buffers in bufs
        bufs: Points to an array of symbolic constants specifying the buffers into which fragment colors or data values will be written
    '''

@accepts(t.enum, t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def stencil_op_separate(face, sfail, dpfail, dppass):
    '''
    set front and/or back stencil test actions
    
    Args:
        face: Specifies whether front and/or back stencil state is updated
        sfail: Specifies the action to take when the stencil test fails
        dpfail: Specifies the stencil action when the stencil test passes, but the depth test fails
        dppass: Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled
    '''

@accepts(t.enum, t.enum, t.int, t.uint)
@returns(t.void)
@binds(dll)
def stencil_func_separate(face, func, ref, mask):
    '''
    set front and/or back function and reference value for stencil testing
    
    Args:
        face: Specifies whether front and/or back stencil state is updated
        func: Specifies the test function
        ref: Specifies the reference value for the stencil test
        mask: Specifies a mask that is ANDed with both the reference value and the stored stencil value when the test is done
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def stencil_mask_separate(face, mask):
    '''
    control the front and/or back writing of individual bits in the stencil planes
    
    Args:
        face: Specifies whether the front and/or back stencil writemask is updated
        mask: Specifies a bit mask to enable and disable writing of individual bits in the stencil planes
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def attach_shader(program, shader):
    '''
    Attaches a shader object to a program object
    
    Args:
        program: Specifies the program object to which a shader object will be attached
        shader: Specifies the shader object that is to be attached
    '''

@accepts(t.uint, t.uint, t.char_p)
@returns(t.void)
@binds(dll)
def bind_attrib_location(program, index, name):
    '''
    Associates a generic vertex attribute index with a named attribute variable
    
    Args:
        program: Specifies the handle of the program object in which the association is to be made
        index: Specifies the index of the generic vertex attribute to be bound
        name: Specifies a null terminated string containing the name of the vertex shader attribute variable to which index is to be bound
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def compile_shader(shader):
    '''
    Compiles a shader object
    
    Args:
        shader: Specifies the shader object to be compiled
    '''

@accepts()
@returns(t.uint)
@binds(dll)
def create_program():
    '''
    Creates a program object
    
    Args:
    '''

@accepts(t.enum)
@returns(t.uint)
@binds(dll)
def create_shader(type):
    '''
    Creates a shader object
    
    Args:
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def delete_program(program):
    '''
    Deletes a program object
    
    Args:
        program: Specifies the program object to be deleted
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def delete_shader(shader):
    '''
    Deletes a shader object
    
    Args:
        shader: Specifies the shader object to be deleted
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def detach_shader(program, shader):
    '''
    Detaches a shader object from a program object to which it is attached
    
    Args:
        program: Specifies the program object from which to detach the shader object
        shader: Specifies the shader object to be detached
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def disable_vertex_attrib_array(index):
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def enable_vertex_attrib_array(index):
    '''
    Enable or disable a generic vertex attribute array
    
    Args:
        index: Specifies the index of the generic vertex attribute to be enabled or disabled
    '''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.int), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_attrib(program, index, bufsize, length, size, type, name):
    '''
    Returns information about an active attribute variable for the specified program object
    
    Args:
        program: Specifies the program object to be queried
        index: Specifies the index of the attribute variable to be queried
        bufsize: Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name
        length: Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed
        size: Returns the size of the attribute variable
        type: Returns the data type of the attribute variable
        name: Returns a null terminated string containing the name of the attribute variable
    '''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.int), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_uniform(program, index, bufsize, length, size, type, name):
    '''
    Returns information about an active uniform variable for the specified program object
    
    Args:
        program: Specifies the program object to be queried
        index: Specifies the index of the uniform variable to be queried
        bufsize: Specifies the maximum number of characters OpenGL is allowed to write in the character buffer indicated by name
        length: Returns the number of characters actually written by OpenGL in the string indicated by name (excluding the null terminator) if a value other than NULL is passed
        size: Returns the size of the uniform variable
        type: Returns the data type of the uniform variable
        name: Returns a null terminated string containing the name of the uniform variable
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_attached_shaders(program, maxcount, count, shaders):
    '''
    Returns the handles of the shader objects attached to a program object
    
    Args:
        program: Specifies the program object to be queried
        maxcount: Specifies the size of the array for storing the returned object names
        count: Returns the number of names actually returned in shaders
        shaders: Specifies an array that is used to return the names of attached shader objects
    '''

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_attrib_location(program, name):
    '''
    Returns the location of an attribute variable
    
    Args:
        program: Specifies the program object to be queried
        name: Points to a null terminated string containing the name of the attribute variable whose location is to be queried
    '''

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_programiv(program, pname, params):
    pass

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_program_info_log(program, bufsize, length, infolog):
    '''
    Returns the information log for a program object
    
    Args:
        program: Specifies the program object whose information log is to be queried
        length: Returns the length of the string returned in infoLog (excluding the null terminator)
        infolog: Specifies an array of characters that is used to return the information log
    '''

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_shaderiv(shader, pname, params):
    pass

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_shader_info_log(shader, bufsize, length, infolog):
    '''
    Returns the information log for a shader object
    
    Args:
        shader: Specifies the shader object whose information log is to be queried
        length: Returns the length of the string returned in infoLog (excluding the null terminator)
        infolog: Specifies an array of characters that is used to return the information log
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_shader_source(shader, bufsize, length, source):
    '''
    Returns the source code string from a shader object
    
    Args:
        shader: Specifies the shader object to be queried
        bufsize: Specifies the size of the character buffer for storing the returned source code string
        length: Returns the length of the string returned in source (excluding the null terminator)
        source: Specifies an array of characters that is used to return the source code string
    '''

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_uniform_location(program, name):
    '''
    Returns the location of a uniform variable
    
    Args:
        program: Specifies the program object to be queried
        name: Points to a null terminated string containing the name of the uniform variable whose location is to be queried
    '''

@accepts(t.uint, t.int, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_uniformfv(program, location, params):
    pass

@accepts(t.uint, t.int, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_uniformiv(program, location, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def get_vertex_attribdv(index, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_vertex_attribfv(index, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_vertex_attribiv(index, pname, params):
    pass

@accepts(t.uint, t.enum, t.void)
@returns(t.void)
@binds(dll)
def get_vertex_attrib_pointerv(index, pname, pointer):
    '''
    return the address of the specified generic vertex attribute pointer
    
    Args:
        index: Specifies the generic vertex attribute parameter to be returned
        pname: Specifies the symbolic name of the generic vertex attribute parameter to be returned
        pointer: Returns the pointer value
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_program(program):
    '''
    Determines if a name corresponds to a program object
    
    Args:
        program: Specifies a potential program object
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_shader(shader):
    '''
    Determines if a name corresponds to a shader object
    
    Args:
        shader: Specifies a potential shader object
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def link_program(program):
    '''
    Links a program object
    
    Args:
        program: Specifies the handle of the program object to be linked
    '''

@accepts(t.uint, t.sizei, POINTER(t.char_p), POINTER(t.int))
@returns(t.void)
@binds(dll)
def shader_source(shader, count, string, length):
    '''
    Replaces the source code in a shader object
    
    Args:
        shader: Specifies the handle of the shader object whose source code is to be replaced
        count: Specifies the number of elements in the string and length arrays
        string: Specifies an array of pointers to strings containing the source code to be loaded into the shader
        length: Specifies an array of string lengths
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def use_program(program):
    '''
    Installs a program object as part of current rendering state
    
    Args:
        program: Specifies the handle of the program object whose executables are to be used as part of current rendering state
    '''

@accepts(t.int, t.float)
@returns(t.void)
@binds(dll)
def uniform1f(location, v0):
    pass

@accepts(t.int, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform2f(location, v0, v1):
    pass

@accepts(t.int, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform3f(location, v0, v1, v2):
    pass

@accepts(t.int, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform4f(location, v0, v1, v2, v3):
    pass

@accepts(t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform1i(location, v0):
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform2i(location, v0, v1):
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform3i(location, v0, v1, v2):
    pass

@accepts(t.int, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform4i(location, v0, v1, v2, v3):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform1fv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform2fv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform3fv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform4fv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform1iv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform2iv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform3iv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform4iv(location, count, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix2fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix3fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix4fv(location, count, transpose, value):
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def validate_program(program):
    '''
    Validates a program object
    
    Args:
        program: Specifies the handle of the program object to be validated
    '''

@accepts(t.uint, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib1d(index, x):
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib1dv(index, v):
    pass

@accepts(t.uint, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib1f(index, x):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib1fv(index, v):
    pass

@accepts(t.uint, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib1s(index, x):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib1sv(index, v):
    pass

@accepts(t.uint, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib2d(index, x, y):
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib2dv(index, v):
    pass

@accepts(t.uint, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib2f(index, x, y):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib2fv(index, v):
    pass

@accepts(t.uint, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib2s(index, x, y):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib2sv(index, v):
    pass

@accepts(t.uint, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib3d(index, x, y, z):
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib3dv(index, v):
    pass

@accepts(t.uint, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib3f(index, x, y, z):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib3fv(index, v):
    pass

@accepts(t.uint, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib3s(index, x, y, z):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib3sv(index, v):
    pass

@accepts(t.uint, POINTER(t.byte))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nbv(index, v):
    pass

@accepts(t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex_attrib4_niv(index, v):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nsv(index, v):
    pass

@accepts(t.uint, t.ubyte, t.ubyte, t.ubyte, t.ubyte)
@returns(t.void)
@binds(dll)
def vertex_attrib4_nub(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nubv(index, v):
    pass

@accepts(t.uint, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nuiv(index, v):
    pass

@accepts(t.uint, POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nusv(index, v):
    pass

@accepts(t.uint, POINTER(t.byte))
@returns(t.void)
@binds(dll)
def vertex_attrib4bv(index, v):
    pass

@accepts(t.uint, t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib4d(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib4dv(index, v):
    pass

@accepts(t.uint, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib4f(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib4fv(index, v):
    pass

@accepts(t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex_attrib4iv(index, v):
    pass

@accepts(t.uint, t.short, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib4s(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib4sv(index, v):
    pass

@accepts(t.uint, POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def vertex_attrib4ubv(index, v):
    pass

@accepts(t.uint, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def vertex_attrib4uiv(index, v):
    pass

@accepts(t.uint, POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def vertex_attrib4usv(index, v):
    pass

@accepts(t.uint, t.int, t.enum, t.boolean, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def vertex_attrib_pointer(index, size, type, normalized, stride, pointer):
    '''
    define an array of generic vertex attribute data
    
    Args:
        index: Specifies the index of the generic vertex attribute to be modified
        size: Specifies the number of components per generic vertex attribute
        type: Specifies the data type of each component in the array
        normalized: For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed
        stride: Specifies the byte offset between consecutive generic vertex attributes
        pointer: Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target
    '''

BLEND_EQUATION_RGB = 0x8009
VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622
VERTEX_ATTRIB_ARRAY_SIZE = 0x8623
VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624
VERTEX_ATTRIB_ARRAY_TYPE = 0x8625
CURRENT_VERTEX_ATTRIB = 0x8626
VERTEX_PROGRAM_POINT_SIZE = 0x8642
VERTEX_ATTRIB_ARRAY_POINTER = 0x8645
STENCIL_BACK_FUNC = 0x8800
STENCIL_BACK_FAIL = 0x8801
STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802
STENCIL_BACK_PASS_DEPTH_PASS = 0x8803
MAX_DRAW_BUFFERS = 0x8824
DRAW_BUFFER0 = 0x8825
DRAW_BUFFER1 = 0x8826
DRAW_BUFFER2 = 0x8827
DRAW_BUFFER3 = 0x8828
DRAW_BUFFER4 = 0x8829
DRAW_BUFFER5 = 0x882A
DRAW_BUFFER6 = 0x882B
DRAW_BUFFER7 = 0x882C
DRAW_BUFFER8 = 0x882D
DRAW_BUFFER9 = 0x882E
DRAW_BUFFER10 = 0x882F
DRAW_BUFFER11 = 0x8830
DRAW_BUFFER12 = 0x8831
DRAW_BUFFER13 = 0x8832
DRAW_BUFFER14 = 0x8833
DRAW_BUFFER15 = 0x8834
BLEND_EQUATION_ALPHA = 0x883D
MAX_VERTEX_ATTRIBS = 0x8869
VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A
MAX_TEXTURE_IMAGE_UNITS = 0x8872
FRAGMENT_SHADER = 0x8B30
VERTEX_SHADER = 0x8B31
MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49
MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A
MAX_VARYING_FLOATS = 0x8B4B
MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
SHADER_TYPE = 0x8B4F
FLOAT_VEC2 = 0x8B50
FLOAT_VEC3 = 0x8B51
FLOAT_VEC4 = 0x8B52
INT_VEC2 = 0x8B53
INT_VEC3 = 0x8B54
INT_VEC4 = 0x8B55
BOOL = 0x8B56
BOOL_VEC2 = 0x8B57
BOOL_VEC3 = 0x8B58
BOOL_VEC4 = 0x8B59
FLOAT_MAT2 = 0x8B5A
FLOAT_MAT3 = 0x8B5B
FLOAT_MAT4 = 0x8B5C
SAMPLER_1D = 0x8B5D
SAMPLER_2D = 0x8B5E
SAMPLER_3D = 0x8B5F
SAMPLER_CUBE = 0x8B60
SAMPLER_1D_SHADOW = 0x8B61
SAMPLER_2D_SHADOW = 0x8B62
DELETE_STATUS = 0x8B80
COMPILE_STATUS = 0x8B81
LINK_STATUS = 0x8B82
VALIDATE_STATUS = 0x8B83
INFO_LOG_LENGTH = 0x8B84
ATTACHED_SHADERS = 0x8B85
ACTIVE_UNIFORMS = 0x8B86
ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87
SHADER_SOURCE_LENGTH = 0x8B88
ACTIVE_ATTRIBUTES = 0x8B89
ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A
FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B
SHADING_LANGUAGE_VERSION = 0x8B8C
CURRENT_PROGRAM = 0x8B8D
POINT_SPRITE_COORD_ORIGIN = 0x8CA0
LOWER_LEFT = 0x8CA1
UPPER_LEFT = 0x8CA2
STENCIL_BACK_REF = 0x8CA3
STENCIL_BACK_VALUE_MASK = 0x8CA4
STENCIL_BACK_WRITEMASK = 0x8CA5
VERTEX_PROGRAM_TWO_SIDE = 0x8643
POINT_SPRITE = 0x8861
COORD_REPLACE = 0x8862
MAX_TEXTURE_COORDS = 0x8871