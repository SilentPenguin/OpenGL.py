#BEWARE: automatically generated code
#This code was generated by opengl/gl/generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_equation_separate(modeRGB, modeAlpha): 
    pass

@accepts(t.sizei, POINTER(t.enum))
@returns(t.void)
@binds(dll)
def draw_buffers(n, bufs): 
    '''Specifies a list of color buffers to be drawn into'''

@accepts(t.enum, t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def stencil_op_separate(face, sfail, dpfail, dppass): 
    pass

@accepts(t.enum, t.enum, t.int, t.uint)
@returns(t.void)
@binds(dll)
def stencil_func_separate(face, func, ref, mask): 
    pass

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def stencil_mask_separate(face, mask): 
    pass

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def attach_shader(program, shader): 
    '''Attaches a shader object to a program object'''

@accepts(t.uint, t.uint, t.char_p)
@returns(t.void)
@binds(dll)
def bind_attrib_location(program, index, name): 
    '''Associates a generic vertex attribute index with a named attribute variable'''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def compile_shader(shader): 
    '''Compiles a shader object'''

@accepts()
@returns(t.uint)
@binds(dll)
def create_program(): 
    '''Creates a program object'''

@accepts(t.enum)
@returns(t.uint)
@binds(dll)
def create_shader(type): 
    '''Creates a shader object'''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def delete_program(program): 
    '''Deletes a program object'''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def delete_shader(shader): 
    '''Deletes a shader object'''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def detach_shader(program, shader): 
    '''Detaches a shader object from a program object to which it is attached'''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def disable_vertex_attrib_array(index): 
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def enable_vertex_attrib_array(index): 
    '''Enable or disable a generic vertex attribute array'''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.int), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_attrib(program, index, bufSize, length, size, type, name): 
    '''Returns information about an active attribute variable for the specified program object'''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.int), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_uniform(program, index, bufSize, length, size, type, name): 
    '''Returns information about an active uniform variable for the specified program object'''

@accepts(t.uint, t.sizei, POINTER(t.sizei), POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_attached_shaders(program, maxCount, count, shaders): 
    '''Returns the handles of the shader objects attached to a program object'''

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_attrib_location(program, name): 
    '''Returns the location of an attribute variable'''

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_programiv(program, pname, params): 
    pass

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_program_info_log(program, bufSize, length, infoLog): 
    '''Returns the information log for a program object'''

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_shaderiv(shader, pname, params): 
    pass

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_shader_info_log(shader, bufSize, length, infoLog): 
    '''Returns the information log for a shader object'''

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_shader_source(shader, bufSize, length, source): 
    '''Returns the source code string from a shader object'''

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_uniform_location(program, name): 
    '''Returns the location of a uniform variable'''

@accepts(t.uint, t.int, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_uniformfv(program, location, params): 
    pass

@accepts(t.uint, t.int, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_uniformiv(program, location, params): 
    pass

@accepts(t.uint, t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def get_vertex_attribdv(index, pname, params): 
    pass

@accepts(t.uint, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_vertex_attribfv(index, pname, params): 
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_vertex_attribiv(index, pname, params): 
    pass

@accepts(t.uint, t.enum, t.void)
@returns(t.void)
@binds(dll)
def get_vertex_attrib_pointerv(index, pname, pointer): 
    '''return the address of the specified generic vertex attribute pointer'''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_program(program): 
    '''Determines if a name corresponds to a program object'''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_shader(shader): 
    '''Determines if a name corresponds to a shader object'''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def link_program(program): 
    '''Links a program object'''

@accepts(t.uint, t.sizei, POINTER(t.char_p), POINTER(t.int))
@returns(t.void)
@binds(dll)
def shader_source(shader, count, string, length): 
    '''Replaces the source code in a shader object'''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def use_program(program): 
    '''Installs a program object as part of current rendering state'''

@accepts(t.int, t.float)
@returns(t.void)
@binds(dll)
def uniform1f(location, v0): 
    pass

@accepts(t.int, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform2f(location, v0, v1): 
    pass

@accepts(t.int, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform3f(location, v0, v1, v2): 
    pass

@accepts(t.int, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform4f(location, v0, v1, v2, v3): 
    pass

@accepts(t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform1i(location, v0): 
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform2i(location, v0, v1): 
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform3i(location, v0, v1, v2): 
    pass

@accepts(t.int, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform4i(location, v0, v1, v2, v3): 
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform1fv(location, count, value): 
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform2fv(location, count, value): 
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform3fv(location, count, value): 
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform4fv(location, count, value): 
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform1iv(location, count, value): 
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform2iv(location, count, value): 
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform3iv(location, count, value): 
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform4iv(location, count, value): 
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix2fv(location, count, transpose, value): 
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix3fv(location, count, transpose, value): 
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix4fv(location, count, transpose, value): 
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def validate_program(program): 
    '''Validates a program object'''

@accepts(t.uint, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib1d(index, x): 
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib1dv(index, v): 
    pass

@accepts(t.uint, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib1f(index, x): 
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib1fv(index, v): 
    pass

@accepts(t.uint, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib1s(index, x): 
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib1sv(index, v): 
    pass

@accepts(t.uint, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib2d(index, x, y): 
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib2dv(index, v): 
    pass

@accepts(t.uint, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib2f(index, x, y): 
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib2fv(index, v): 
    pass

@accepts(t.uint, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib2s(index, x, y): 
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib2sv(index, v): 
    pass

@accepts(t.uint, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib3d(index, x, y, z): 
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib3dv(index, v): 
    pass

@accepts(t.uint, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib3f(index, x, y, z): 
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib3fv(index, v): 
    pass

@accepts(t.uint, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib3s(index, x, y, z): 
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib3sv(index, v): 
    pass

@accepts(t.uint, POINTER(t.byte))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nbv(index, v): 
    pass

@accepts(t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex_attrib4_niv(index, v): 
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nsv(index, v): 
    pass

@accepts(t.uint, t.ubyte, t.ubyte, t.ubyte, t.ubyte)
@returns(t.void)
@binds(dll)
def vertex_attrib4_nub(index, x, y, z, w): 
    pass

@accepts(t.uint, POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nubv(index, v): 
    pass

@accepts(t.uint, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nuiv(index, v): 
    pass

@accepts(t.uint, POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def vertex_attrib4_nusv(index, v): 
    pass

@accepts(t.uint, POINTER(t.byte))
@returns(t.void)
@binds(dll)
def vertex_attrib4bv(index, v): 
    pass

@accepts(t.uint, t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex_attrib4d(index, x, y, z, w): 
    pass

@accepts(t.uint, POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex_attrib4dv(index, v): 
    pass

@accepts(t.uint, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib4f(index, x, y, z, w): 
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib4fv(index, v): 
    pass

@accepts(t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex_attrib4iv(index, v): 
    pass

@accepts(t.uint, t.short, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex_attrib4s(index, x, y, z, w): 
    pass

@accepts(t.uint, POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex_attrib4sv(index, v): 
    pass

@accepts(t.uint, POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def vertex_attrib4ubv(index, v): 
    pass

@accepts(t.uint, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def vertex_attrib4uiv(index, v): 
    pass

@accepts(t.uint, POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def vertex_attrib4usv(index, v): 
    pass

@accepts(t.uint, t.int, t.enum, t.boolean, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def vertex_attrib_pointer(index, size, type, normalized, stride, pointer): 
    '''define an array of generic vertex attribute data'''

BLEND_EQUATION_RGB = 0x8009
VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622
VERTEX_ATTRIB_ARRAY_SIZE = 0x8623
VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624
VERTEX_ATTRIB_ARRAY_TYPE = 0x8625
CURRENT_VERTEX_ATTRIB = 0x8626
VERTEX_PROGRAM_POINT_SIZE = 0x8642
VERTEX_ATTRIB_ARRAY_POINTER = 0x8645
STENCIL_BACK_FUNC = 0x8800
STENCIL_BACK_FAIL = 0x8801
STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802
STENCIL_BACK_PASS_DEPTH_PASS = 0x8803
MAX_DRAW_BUFFERS = 0x8824
DRAW_BUFFER0 = 0x8825
DRAW_BUFFER1 = 0x8826
DRAW_BUFFER2 = 0x8827
DRAW_BUFFER3 = 0x8828
DRAW_BUFFER4 = 0x8829
DRAW_BUFFER5 = 0x882A
DRAW_BUFFER6 = 0x882B
DRAW_BUFFER7 = 0x882C
DRAW_BUFFER8 = 0x882D
DRAW_BUFFER9 = 0x882E
DRAW_BUFFER10 = 0x882F
DRAW_BUFFER11 = 0x8830
DRAW_BUFFER12 = 0x8831
DRAW_BUFFER13 = 0x8832
DRAW_BUFFER14 = 0x8833
DRAW_BUFFER15 = 0x8834
BLEND_EQUATION_ALPHA = 0x883D
MAX_VERTEX_ATTRIBS = 0x8869
VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A
MAX_TEXTURE_IMAGE_UNITS = 0x8872
FRAGMENT_SHADER = 0x8B30
VERTEX_SHADER = 0x8B31
MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49
MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A
MAX_VARYING_FLOATS = 0x8B4B
MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
SHADER_TYPE = 0x8B4F
FLOAT_VEC2 = 0x8B50
FLOAT_VEC3 = 0x8B51
FLOAT_VEC4 = 0x8B52
INT_VEC2 = 0x8B53
INT_VEC3 = 0x8B54
INT_VEC4 = 0x8B55
BOOL = 0x8B56
BOOL_VEC2 = 0x8B57
BOOL_VEC3 = 0x8B58
BOOL_VEC4 = 0x8B59
FLOAT_MAT2 = 0x8B5A
FLOAT_MAT3 = 0x8B5B
FLOAT_MAT4 = 0x8B5C
SAMPLER_1D = 0x8B5D
SAMPLER_2D = 0x8B5E
SAMPLER_3D = 0x8B5F
SAMPLER_CUBE = 0x8B60
SAMPLER_1D_SHADOW = 0x8B61
SAMPLER_2D_SHADOW = 0x8B62
DELETE_STATUS = 0x8B80
COMPILE_STATUS = 0x8B81
LINK_STATUS = 0x8B82
VALIDATE_STATUS = 0x8B83
INFO_LOG_LENGTH = 0x8B84
ATTACHED_SHADERS = 0x8B85
ACTIVE_UNIFORMS = 0x8B86
ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87
SHADER_SOURCE_LENGTH = 0x8B88
ACTIVE_ATTRIBUTES = 0x8B89
ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A
FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B
SHADING_LANGUAGE_VERSION = 0x8B8C
CURRENT_PROGRAM = 0x8B8D
POINT_SPRITE_COORD_ORIGIN = 0x8CA0
LOWER_LEFT = 0x8CA1
UPPER_LEFT = 0x8CA2
STENCIL_BACK_REF = 0x8CA3
STENCIL_BACK_VALUE_MASK = 0x8CA4
STENCIL_BACK_WRITEMASK = 0x8CA5
VERTEX_PROGRAM_TWO_SIDE = 0x8643
POINT_SPRITE = 0x8861
COORD_REPLACE = 0x8862
MAX_TEXTURE_COORDS = 0x8871