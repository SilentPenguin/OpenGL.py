#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def dispatch_compute(num_groups_x, num_groups_y, num_groups_z):
    '''
    launch one or more compute work groups.
    
    gl.dispatch_compute launches one or more compute work groups. Each work
    group is processed by the active program object for the compute shader
    stage. While the individual shader invocations within a work group are
    executed as a unit, work groups are executed completely independently and in
    unspecified order. num_groups_x, num_groups_y and num_groups_z specify the
    number of local work groups that will be dispatched in the X, Y and Z
    dimensions, respectively.
    
    Args:
        num_groups_x: the number of work groups to be launched in the x
            dimension.
        num_groups_y: the number of work groups to be launched in the y
            dimension.
        num_groups_z: the number of work groups to be launched in the z
            dimension.
    '''

@accepts(t.intptr)
@returns(t.void)
@binds(dll)
def dispatch_compute_indirect(indirect):
    '''
    launch one or more compute work groups using parameters stored in a buffer.
    
    gl.dispatch_compute_indirect launches one or more compute work groups using
    parameters stored in the buffer object currently bound to the
    gl.DISPATCH_INDIRECT_BUFFER target. Each work group is processed by the
    active program object for the compute shader stage. While the individual
    shader invocations within a work group are executed as a unit, work groups
    are executed completely independently and in unspecified order. indirect
    contains the offset into the data store of the buffer object bound to the
    gl.DISPATCH_INDIRECT_BUFFER target at which the parameters are stored.
    
    Args:
        indirect: the offset into the buffer object currently bound to the
            gl_dispatch_indirect_buffer buffer target at which the dispatch
            parameters are stored.
    '''

COMPUTE_SHADER = 0x91B9
MAX_COMPUTE_UNIFORM_BLOCKS = 0x91BB
MAX_COMPUTE_TEXTURE_IMAGE_UNITS = 0x91BC
MAX_COMPUTE_IMAGE_UNIFORMS = 0x91BD
MAX_COMPUTE_SHARED_MEMORY_SIZE = 0x8262
MAX_COMPUTE_UNIFORM_COMPONENTS = 0x8263
MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264
MAX_COMPUTE_ATOMIC_COUNTERS = 0x8265
MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266
MAX_COMPUTE_WORK_GROUP_INVOCATIONS = 0x90EB
MAX_COMPUTE_WORK_GROUP_COUNT = 0x91BE
MAX_COMPUTE_WORK_GROUP_SIZE = 0x91BF
COMPUTE_WORK_GROUP_SIZE = 0x8267
DISPATCH_INDIRECT_BUFFER = 0x90EE
DISPATCH_INDIRECT_BUFFER_BINDING = 0x90EF
COMPUTE_SHADER_BIT = 0x00000020
@accepts(t.enum, t.void)
@returns(t.void)
@binds(dll)
def draw_arrays_indirect(mode, indirect):
    '''
    render primitives from array data, taking parameters from memory.
    
    gl.draw_arrays_indirect specifies multiple geometric primitives with very
    few subroutine calls. gl.draw_arrays_indirect behaves similarly to
    gl.draw_arrays_instanced_base_instance, execept that the parameters to
    gl.draw_arrays_instanced_base_instance are stored in memory at the address
    given by indirect.
    
    Args:
        mode: what kind of primitives to render.
        indirect: the address of a structure containing the draw parameters.
    '''

@accepts(t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def draw_elements_indirect(mode, type, indirect):
    '''
    render indexed primitives from array data, taking parameters from memory.
    
    gl.draw_elements_indirect specifies multiple indexed geometric primitives
    with very few subroutine calls. gl.draw_elements_indirect behaves similarly
    to gl.draw_elements_instanced_base_vertex_base_instance, execpt that the
    parameters to gl.draw_elements_instanced_base_vertex_base_instance are
    stored in memory at the address given by indirect.
    
    Args:
        mode: what kind of primitives to render.
        type: the type of data in the buffer bound to the
            gl_element_array_buffer binding.
        indirect: the address of a structure containing the draw parameters.
    '''

DRAW_INDIRECT_BUFFER = 0x8F3F
DRAW_INDIRECT_BUFFER_BINDING = 0x8F43
MAX_UNIFORM_LOCATIONS = 0x826E
@accepts(t.enum, t.enum, t.int)
@returns(t.void)
@binds(dll)
def framebuffer_parameteri(target, pname, param):
    '''
    set a named parameter of a framebuffer object.
    
    gl.framebuffer_parameteri and gl.named_framebuffer_parameteri modify the
    value of the parameter named pname in the specified framebuffer object.
    There are no modifiable parameters of the default draw and read framebuffer,
    so they are not valid targets of these commands.
    
    Args:
        target: the target to which the framebuffer is bound for
            glframebufferparameteri.
        pname: the framebuffer parameter to be modified.
        param: the new value for the parameter named pname.
    '''

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_framebuffer_parameteriv(target, pname, params):
    pass

FRAMEBUFFER_DEFAULT_WIDTH = 0x9310
FRAMEBUFFER_DEFAULT_HEIGHT = 0x9311
FRAMEBUFFER_DEFAULT_SAMPLES = 0x9313
FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314
MAX_FRAMEBUFFER_WIDTH = 0x9315
MAX_FRAMEBUFFER_HEIGHT = 0x9316
MAX_FRAMEBUFFER_SAMPLES = 0x9318
@accepts(t.uint, t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_program_interfaceiv(program, programinterface, pname, params):
    pass

@accepts(t.uint, t.enum, t.char_p)
@returns(t.uint)
@binds(dll)
def get_program_resource_index(program, programinterface, name):
    '''
    query the index of a named resource within a program.
    
    gl.get_program_resource_index returns the unsigned integer index assigned to
    a resource named name in the interface type programInterface of program
    object program.
    
    Args:
        program: the name of a program object whose resources to query.
        programinterface: a token identifying the interface within program
            containing the resource named name.
        name: the name of the resource to query the index of.
    '''

@accepts(t.uint, t.enum, t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_program_resource_name(program, programinterface, index, bufsize, length, name):
    '''
    query the name of an indexed resource within a program.
    
    gl.get_program_resource_name retrieves the name string assigned to the
    single active resource with an index of index in the interface
    programInterface of program object program. index must be less than the
    number of entries in the active resource list for programInterface.
    
    Args:
        program: the name of a program object whose resources to query.
        programinterface: a token identifying the interface within program
            containing the indexed resource.
        index: the index of the resource within programinterface of program.
        bufsize: the size of the character array whose address is given by name.
        length: the address of a variable which will receive the length of the
            resource name.
        name: the address of a character array into which will be written the
            name of the resource.
    '''

@accepts(t.uint, t.enum, t.uint, t.sizei, POINTER(t.enum), t.sizei, POINTER(t.sizei), POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_program_resourceiv(program, programinterface, index, propcount, props, bufsize, length, params):
    pass

@accepts(t.uint, t.enum, t.char_p)
@returns(t.int)
@binds(dll)
def get_program_resource_location(program, programinterface, name):
    '''
    query the location of a named resource within a program.
    
    gl.get_program_resource_location returns the location assigned to the
    variable named name in interface programInterface of program object program.
    program must be the name of a program that has been linked successfully.
    programInterface must be one of gl.UNIFORM, gl.PROGRAM_INPUT,
    gl.PROGRAM_OUTPUT, gl.VERTEX_SUBROUTINE_UNIFORM,
    gl.TESS_CONTROL_SUBROUTINE_UNIFORM, gl.TESS_EVALUATION_SUBROUTINE_UNIFORM,
    gl.GEOMETRY_SUBROUTINE_UNIFORM, gl.FRAGMENT_SUBROUTINE_UNIFORM,
    gl.COMPUTE_SUBROUTINE_UNIFORM, or gl.TRANSFORM_FEEDBACK_BUFFER.
    
    Args:
        program: the name of a program object whose resources to query.
        programinterface: a token identifying the interface within program
            containing the resource named name.
        name: the name of the resource to query the location of.
    '''

UNIFORM = 0x92E1
UNIFORM_BLOCK = 0x92E2
PROGRAM_INPUT = 0x92E3
PROGRAM_OUTPUT = 0x92E4
BUFFER_VARIABLE = 0x92E5
SHADER_STORAGE_BLOCK = 0x92E6
ATOMIC_COUNTER_BUFFER = 0x92C0
TRANSFORM_FEEDBACK_VARYING = 0x92F4
ACTIVE_RESOURCES = 0x92F5
MAX_NAME_LENGTH = 0x92F6
MAX_NUM_ACTIVE_VARIABLES = 0x92F7
NAME_LENGTH = 0x92F9
TYPE = 0x92FA
ARRAY_SIZE = 0x92FB
OFFSET = 0x92FC
BLOCK_INDEX = 0x92FD
ARRAY_STRIDE = 0x92FE
MATRIX_STRIDE = 0x92FF
IS_ROW_MAJOR = 0x9300
ATOMIC_COUNTER_BUFFER_INDEX = 0x9301
BUFFER_BINDING = 0x9302
BUFFER_DATA_SIZE = 0x9303
NUM_ACTIVE_VARIABLES = 0x9304
ACTIVE_VARIABLES = 0x9305
REFERENCED_BY_VERTEX_SHADER = 0x9306
REFERENCED_BY_FRAGMENT_SHADER = 0x930A
REFERENCED_BY_COMPUTE_SHADER = 0x930B
TOP_LEVEL_ARRAY_SIZE = 0x930C
TOP_LEVEL_ARRAY_STRIDE = 0x930D
LOCATION = 0x930E
@accepts(t.uint, t.bitfield, t.uint)
@returns(t.void)
@binds(dll)
def use_program_stages(pipeline, stages, program):
    '''
    bind stages of a program object to a program pipeline.
    
    gl.use_program_stages binds executables from a program object associated
    with a specified set of shader stages to the program pipeline object given
    by pipeline. pipeline specifies the program pipeline object to which to bind
    the executables. stages contains a logical combination of bits indicating
    the shader stages to use within program with the program pipeline object
    pipeline. stages must be a logical combination of gl.VERTEX_SHADER_BIT,
    gl.TESS_CONTROL_SHADER_BIT, gl.TESS_EVALUATION_SHADER_BIT,
    gl.GEOMETRY_SHADER_BIT, gl.FRAGMENT_SHADER_BIT and gl.COMPUTE_SHADER_BIT.
    
    Args:
        pipeline: the program pipeline object to which to bind stages from
            program.
        stages: a set of program stages to bind to the program pipeline object.
        program: the program object containing the shader executables to use in
            pipeline.
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def active_shader_program(pipeline, program):
    '''
    set the active program object for a program pipeline object.
    
    gl.active_shader_program sets the linked program named by program to be the
    active program for the program pipeline object pipeline. The active program
    in the active program pipeline object is the target of calls to gl.uniform
    when no program has been made current through a call to gl.use_program.
    
    Args:
        pipeline: the program pipeline object to set the active program object
            for.
        program: the program object to set as the active program pipeline object
            pipeline.
    '''

@accepts(t.enum, t.sizei, POINTER(t.char_p))
@returns(t.uint)
@binds(dll)
def create_shader_programv(type, count, strings):
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def bind_program_pipeline(pipeline):
    '''
    bind a program pipeline to the current context.
    
    gl.bind_program_pipeline binds a program pipeline object to the current
    context. pipeline must be a name previously returned from a call to
    gl.gen_program_pipelines. If no program pipeline exists with name pipeline
    then a new pipeline object is created with that name and initialized to the
    default state vector.
    
    Args:
        pipeline: the name of the pipeline object to bind to the context.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_program_pipelines(n, pipelines):
    '''
    delete program pipeline objects.
    
    gl.delete_program_pipelines deletes the n program pipeline objects whose
    names are stored in the array pipelines. Unused names in pipelines are
    ignored, as is the name zero. After a program pipeline object is deleted,
    its name is again unused and it has no contents. If program pipeline object
    that is currently bound is deleted, the binding for that object reverts to
    zero and no program pipeline object becomes current.
    
    Args:
        n: the number of program pipeline objects to delete.
        pipelines: an array of names of program pipeline objects to delete.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_program_pipelines(n, pipelines):
    '''
    reserve program pipeline object names.
    
    gl.gen_program_pipelines returns n previously unused program pipeline object
    names in pipelines. These names are marked as used, for the purposes of
    gl.gen_program_pipelines only, but they acquire program pipeline state only
    when they are first bound.
    
    Args:
        n: the number of program pipeline object names to reserve.
        pipelines: an array of into which the reserved names will be written.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_program_pipeline(pipeline):
    '''
    determine if a name corresponds to a program pipeline object.
    
    gl.is_program_pipeline returns gl.TRUE if pipeline is currently the name of
    a program pipeline object. If pipeline is zero, or if pipeline is not the
    name of a program pipeline object, or if an error occurs,
    gl.is_program_pipeline returns gl.FALSE. If pipeline is a name returned by
    gl.gen_program_pipelines, but that has not yet been bound through a call to
    gl.bind_program_pipeline, then the name is not a program pipeline object and
    gl.is_program_pipeline returns gl.FALSE.
    
    Args:
        pipeline: a value that may be the name of a program pipeline object.
    '''

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_program_pipelineiv(pipeline, pname, params):
    pass

@accepts(t.uint, t.int, t.int)
@returns(t.void)
@binds(dll)
def program_uniform1i(program, location, v0):
    pass

@accepts(t.uint, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def program_uniform2i(program, location, v0, v1):
    pass

@accepts(t.uint, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def program_uniform3i(program, location, v0, v1, v2):
    pass

@accepts(t.uint, t.int, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def program_uniform4i(program, location, v0, v1, v2, v3):
    pass

@accepts(t.uint, t.int, t.uint)
@returns(t.void)
@binds(dll)
def program_uniform1ui(program, location, v0):
    pass

@accepts(t.uint, t.int, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def program_uniform2ui(program, location, v0, v1):
    pass

@accepts(t.uint, t.int, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def program_uniform3ui(program, location, v0, v1, v2):
    pass

@accepts(t.uint, t.int, t.uint, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def program_uniform4ui(program, location, v0, v1, v2, v3):
    pass

@accepts(t.uint, t.int, t.float)
@returns(t.void)
@binds(dll)
def program_uniform1f(program, location, v0):
    pass

@accepts(t.uint, t.int, t.float, t.float)
@returns(t.void)
@binds(dll)
def program_uniform2f(program, location, v0, v1):
    pass

@accepts(t.uint, t.int, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def program_uniform3f(program, location, v0, v1, v2):
    pass

@accepts(t.uint, t.int, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def program_uniform4f(program, location, v0, v1, v2, v3):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def program_uniform1iv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def program_uniform2iv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def program_uniform3iv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def program_uniform4iv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def program_uniform1uiv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def program_uniform2uiv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def program_uniform3uiv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def program_uniform4uiv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform1fv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform2fv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform3fv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform4fv(program, location, count, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix2fv(program, location, count, transpose, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix3fv(program, location, count, transpose, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix4fv(program, location, count, transpose, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix2x3fv(program, location, count, transpose, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix3x2fv(program, location, count, transpose, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix2x4fv(program, location, count, transpose, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix4x2fv(program, location, count, transpose, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix3x4fv(program, location, count, transpose, value):
    pass

@accepts(t.uint, t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def program_uniform_matrix4x3fv(program, location, count, transpose, value):
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def validate_program_pipeline(pipeline):
    '''
    validate a program pipeline object against current GL state.
    
    gl.validate_program_pipeline instructs the implementation to validate the
    shader executables contained in pipeline against the current GL state. The
    implementation may use this as an opportunity to perform any internal shader
    modifications that may be required to ensure correct operation of the
    installed shaders given the current GL state.
    
    Args:
        pipeline: the name of a program pipeline object to validate.
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_program_pipeline_info_log(pipeline, bufsize, length, infolog):
    '''
    retrieve the info log string from a program pipeline object.
    
    gl.get_program_pipeline_info_log retrieves the info log for the program
    pipeline object pipeline. The info log, including its null terminator, is
    written into the array of characters whose address is given by infoLog. The
    maximum number of characters that may be written into infoLog is given by
    bufSize, and the actual number of characters written into infoLog is
    returned in the integer whose address is given by length. If length is None,
    no length is returned.
    
    Args:
        pipeline: the name of a program pipeline object from which to retrieve
            the info log.
        bufsize: the maximum number of characters, including the null
            terminator, that may be written into infolog.
        length: the address of a variable into which will be written the number
            of characters written into infolog.
        infolog: the address of an array of characters into which will be
            written the info log for pipeline.
    '''

VERTEX_SHADER_BIT = 0x00000001
FRAGMENT_SHADER_BIT = 0x00000002
ALL_SHADER_BITS = 0xFFFFFFFF
PROGRAM_SEPARABLE = 0x8258
ACTIVE_PROGRAM = 0x8259
PROGRAM_PIPELINE_BINDING = 0x825A
ATOMIC_COUNTER_BUFFER = 0x92C0
ATOMIC_COUNTER_BUFFER_BINDING = 0x92C1
ATOMIC_COUNTER_BUFFER_START = 0x92C2
ATOMIC_COUNTER_BUFFER_SIZE = 0x92C3
MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC
MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0
MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264
MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1
MAX_VERTEX_ATOMIC_COUNTERS = 0x92D2
MAX_FRAGMENT_ATOMIC_COUNTERS = 0x92D6
MAX_COMPUTE_ATOMIC_COUNTERS = 0x8265
MAX_COMBINED_ATOMIC_COUNTERS = 0x92D7
MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8
MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC
ACTIVE_ATOMIC_COUNTER_BUFFERS = 0x92D9
UNSIGNED_INT_ATOMIC_COUNTER = 0x92DB
@accepts(t.uint, t.uint, t.int, t.boolean, t.int, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def bind_image_texture(unit, texture, level, layered, layer, access, format):
    '''
    bind a level of a texture to an image unit.
    
    gl.bind_image_texture binds a single level of a texture to an image unit for
    the purpose of reading and writing it from shaders. unit specifies the zero-
    based index of the image unit to which to bind the texture level. texture
    specifies the name of an existing texture object to bind to the image unit.
    If texture is zero, then any existing binding to the image unit is broken.
    
    Args:
        unit: the index of the image unit to which to bind the texture.
        texture: the name of the texture to bind to the image unit.
        level: the level of the texture that is to be bound.
        layered: whether a layered texture binding is to be established.
        layer: if layered is gl_false, specifies the layer of texture to be
            bound to the image unit.
        access: a token indicating the type of access that will be performed on
            the image.
        format: the format that the elements of the image will be treated as for
            the purposes of formatted stores.
    '''

@accepts(t.enum, t.uint, POINTER(t.boolean))
@returns(t.void)
@binds(dll)
def get_booleani_v(target, index, data):
    pass

@accepts(t.bitfield)
@returns(t.void)
@binds(dll)
def memory_barrier(barriers):
    '''
    defines a barrier ordering memory transactions.
    
    gl.memory_barrier defines a barrier ordering the memory transactions issued
    prior to the command relative to those issued after the barrier. For the
    purposes of this ordering, memory transactions performed by shaders are
    considered to be issued by the rendering command that triggered the
    execution of the shader.
    
    Args:
        barriers: the barriers to insert.
    '''

@accepts(t.bitfield)
@returns(t.void)
@binds(dll)
def memory_barrier_by_region(barriers):
    pass

MAX_IMAGE_UNITS = 0x8F38
MAX_VERTEX_IMAGE_UNIFORMS = 0x90CA
MAX_FRAGMENT_IMAGE_UNIFORMS = 0x90CE
MAX_COMPUTE_IMAGE_UNIFORMS = 0x91BD
MAX_COMBINED_IMAGE_UNIFORMS = 0x90CF
IMAGE_BINDING_NAME = 0x8F3A
IMAGE_BINDING_LEVEL = 0x8F3B
IMAGE_BINDING_LAYERED = 0x8F3C
IMAGE_BINDING_LAYER = 0x8F3D
IMAGE_BINDING_ACCESS = 0x8F3E
IMAGE_BINDING_FORMAT = 0x906E
VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001
ELEMENT_ARRAY_BARRIER_BIT = 0x00000002
UNIFORM_BARRIER_BIT = 0x00000004
TEXTURE_FETCH_BARRIER_BIT = 0x00000008
SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020
COMMAND_BARRIER_BIT = 0x00000040
PIXEL_BUFFER_BARRIER_BIT = 0x00000080
TEXTURE_UPDATE_BARRIER_BIT = 0x00000100
BUFFER_UPDATE_BARRIER_BIT = 0x00000200
FRAMEBUFFER_BARRIER_BIT = 0x00000400
TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800
ATOMIC_COUNTER_BARRIER_BIT = 0x00001000
ALL_BARRIER_BITS = 0xFFFFFFFF
IMAGE_2D = 0x904D
IMAGE_3D = 0x904E
IMAGE_CUBE = 0x9050
IMAGE_2D_ARRAY = 0x9053
INT_IMAGE_2D = 0x9058
INT_IMAGE_3D = 0x9059
INT_IMAGE_CUBE = 0x905B
INT_IMAGE_2D_ARRAY = 0x905E
UNSIGNED_INT_IMAGE_2D = 0x9063
UNSIGNED_INT_IMAGE_3D = 0x9064
UNSIGNED_INT_IMAGE_CUBE = 0x9066
UNSIGNED_INT_IMAGE_2D_ARRAY = 0x9069
IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7
IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8
IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9
READ_ONLY = 0x88B8
WRITE_ONLY = 0x88B9
READ_WRITE = 0x88BA
SHADER_STORAGE_BUFFER = 0x90D2
SHADER_STORAGE_BUFFER_BINDING = 0x90D3
SHADER_STORAGE_BUFFER_START = 0x90D4
SHADER_STORAGE_BUFFER_SIZE = 0x90D5
MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6
MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA
MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB
MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC
MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD
MAX_SHADER_STORAGE_BLOCK_SIZE = 0x90DE
SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF
SHADER_STORAGE_BARRIER_BIT = 0x00002000
MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39
DEPTH_STENCIL_TEXTURE_MODE = 0x90EA
STENCIL_INDEX = 0x1901
MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E
MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F
@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.boolean)
@returns(t.void)
@binds(dll)
def tex_storage2_d_multisample(target, samples, internalformat, width, height, fixedsamplelocations):
    '''
    specify storage for a two-dimensional multisample texture.
    
    Args:
        target: the target to which the texture object is bound for
            gltexstorage2dmultisample.
        samples: the number of samples in the texture.
        internalformat: the sized internal format to be used to store texture
            image data.
        width: the width of the texture, in texels.
        height: the height of the texture, in texels.
        fixedsamplelocations: whether the image will use identical sample
            locations and the same number of samples for all texels in the
            image, and the sample locations will not depend on the internal
            format or size of the image.
    '''

@accepts(t.enum, t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_multisamplefv(pname, index, val):
    pass

@accepts(t.uint, t.bitfield)
@returns(t.void)
@binds(dll)
def sample_maski(masknumber, mask):
    '''
    set the value of a sub-word of the sample mask.
    
    gl.sample_maski sets one 32-bit sub-word of the multi-word sample mask,
    gl.SAMPLE_MASK_VALUE.
    
    Args:
        masknumber: which 32-bit sub-word of the sample mask to update.
        mask: the new value of the mask sub-word.
    '''

@accepts(t.enum, t.int, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_tex_level_parameteriv(target, level, pname, params):
    pass

@accepts(t.enum, t.int, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_tex_level_parameterfv(target, level, pname, params):
    pass

SAMPLE_POSITION = 0x8E50
SAMPLE_MASK = 0x8E51
SAMPLE_MASK_VALUE = 0x8E52
TEXTURE_2D_MULTISAMPLE = 0x9100
MAX_SAMPLE_MASK_WORDS = 0x8E59
MAX_COLOR_TEXTURE_SAMPLES = 0x910E
MAX_DEPTH_TEXTURE_SAMPLES = 0x910F
MAX_INTEGER_SAMPLES = 0x9110
TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104
TEXTURE_SAMPLES = 0x9106
TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107
TEXTURE_WIDTH = 0x1000
TEXTURE_HEIGHT = 0x1001
TEXTURE_DEPTH = 0x8071
TEXTURE_INTERNAL_FORMAT = 0x1003
TEXTURE_RED_SIZE = 0x805C
TEXTURE_GREEN_SIZE = 0x805D
TEXTURE_BLUE_SIZE = 0x805E
TEXTURE_ALPHA_SIZE = 0x805F
TEXTURE_DEPTH_SIZE = 0x884A
TEXTURE_STENCIL_SIZE = 0x88F1
TEXTURE_SHARED_SIZE = 0x8C3F
TEXTURE_RED_TYPE = 0x8C10
TEXTURE_GREEN_TYPE = 0x8C11
TEXTURE_BLUE_TYPE = 0x8C12
TEXTURE_ALPHA_TYPE = 0x8C13
TEXTURE_DEPTH_TYPE = 0x8C16
TEXTURE_COMPRESSED = 0x86A1
SAMPLER_2D_MULTISAMPLE = 0x9108
INT_SAMPLER_2D_MULTISAMPLE = 0x9109
UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A
@accepts(t.uint, t.uint, t.intptr, t.sizei)
@returns(t.void)
@binds(dll)
def bind_vertex_buffer(bindingindex, buffer, offset, stride):
    '''
    bind a buffer to a vertex buffer bind point.
    
    gl.bind_vertex_buffer and gl.vertex_array_vertex_buffer bind the buffer
    named buffer to the vertex buffer binding point whose index is given by
    bindingindex. gl.bind_vertex_buffer modifies the binding of the currently
    bound vertex array object, whereas gl.vertex_array_vertex_buffer allows the
    caller to specify ID of the vertex array object with an argument named
    vaobj, for which the binding should be modified. offset and stride specify
    the offset of the first element within the buffer and the distance between
    elements within the buffer, respectively, and are both measured in basic
    machine units. bindingindex must be less than the value of
    gl.MAX_VERTEX_ATTRIB_BINDINGS.
    
    Args:
        bindingindex: the index of the vertex buffer binding point to which to
            bind the buffer.
        buffer: the name of a buffer to bind to the vertex buffer binding point.
        offset: the offset of the first element of the buffer.
        stride: the distance between elements within the buffer.
    '''

@accepts(t.uint, t.int, t.enum, t.boolean, t.uint)
@returns(t.void)
@binds(dll)
def vertex_attrib_format(attribindex, size, type, normalized, relativeoffset):
    '''
    specify the organization of vertex arrays.
    
    gl.vertex_attrib_format, gl.vertex_attrib_i_format and
    gl.vertex_attrib_l_format, as well as gl.vertex_array_attrib_format,
    gl.vertex_array_attrib_i_format and gl.vertex_array_attrib_l_format specify
    the organization of data in vertex arrays. The first three calls operate on
    the bound vertex array object, whereas the last three ones modify the state
    of a vertex array object with ID vaobj. attribindex specifies the index of
    the generic vertex attribute array whose data layout is being described, and
    must be less than the value of gl.MAX_VERTEX_ATTRIBS.
    
    Args:
        attribindex: the generic vertex attribute array being described.
        size: the number of values per vertex that are stored in the array.
        type: the type of the data stored in the array.
        normalized: the distance between elements within the buffer.
        relativeoffset: the distance between elements within the buffer.
    '''

@accepts(t.uint, t.int, t.enum, t.uint)
@returns(t.void)
@binds(dll)
def vertex_attrib_i_format(attribindex, size, type, relativeoffset):
    pass

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def vertex_attrib_binding(attribindex, bindingindex):
    '''
    associate a vertex attribute and a vertex buffer binding for a vertex array
    object.
    
    gl.vertex_attrib_binding and gl.vertex_array_attrib_binding establishes an
    association between the generic vertex attribute of a vertex array object
    whose index is given by attribindex, and a vertex buffer binding whose index
    is given by bindingindex. For gl.vertex_attrib_binding, the vertex array
    object affected is that currently bound. For gl.vertex_array_attrib_binding,
    vaobj is the name of the vertex array object.
    
    Args:
        attribindex: the index of the attribute to associate with a vertex
            buffer binding.
        bindingindex: the index of the vertex buffer binding with which to
            associate the generic vertex attribute.
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def vertex_binding_divisor(bindingindex, divisor):
    '''
    modify the rate at which generic vertex attributes advance.
    
    gl.vertex_binding_divisor and gl.vertex_array_binding_divisor modify the
    rate at which generic vertex attributes advance when rendering multiple
    instances of primitives in a single draw command. If divisor is zero, the
    attributes using the buffer bound to bindingindex advance once per vertex.
    If divisor is non-zero, the attributes advance once per divisor instances of
    the set of vertices being rendered. An attribute is referred to as instanced
    if the corresponding divisor value is non-zero.
    
    Args:
        bindingindex: the index of the binding whose divisor to modify.
        divisor: the new value for the instance step rate to apply.
    '''

VERTEX_ATTRIB_BINDING = 0x82D4
VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D5
VERTEX_BINDING_DIVISOR = 0x82D6
VERTEX_BINDING_OFFSET = 0x82D7
VERTEX_BINDING_STRIDE = 0x82D8
VERTEX_BINDING_BUFFER = 0x8F4F
MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D9
MAX_VERTEX_ATTRIB_BINDINGS = 0x82DA
MAX_VERTEX_ATTRIB_STRIDE = 0x82E5