#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.float)
@returns(t.void)
@binds(dll)
def min_sample_shading(value):
    '''
    specifies minimum rate at which sample shaing takes place.
    
    gl.min_sample_shading specifies the rate at which samples are shaded within
    a covered pixel. Sample-rate shading is enabled by calling gl.enable with
    the parameter gl.SAMPLE_SHADING. If gl.MULTISAMPLE or gl.SAMPLE_SHADING is
    disabled, sample shading has no effect. Otherwise, an implementation must
    provide at least as many unique color values for each covered fragment as
    specified by value times samples where samples is the value of gl.SAMPLES
    for the current framebuffer.
    
    Args:
        value: the rate at which samples are shaded within each covered pixel.
    '''

@accepts(t.uint, t.enum)
@returns(t.void)
@binds(dll)
def blend_equationi(buf, mode):
    pass

@accepts(t.uint, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_equation_separatei(buf, modergb, modealpha):
    pass

@accepts(t.uint, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_funci(buf, src, dst):
    pass

@accepts(t.uint, t.enum, t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_func_separatei(buf, srcrgb, dstrgb, srcalpha, dstalpha):
    pass

SAMPLE_SHADING = 0x8C36
MIN_SAMPLE_SHADING_VALUE = 0x8C37
MIN_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5E
MAX_PROGRAM_TEXTURE_GATHER_OFFSET = 0x8E5F
TEXTURE_CUBE_MAP_ARRAY = 0x9009
TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A
PROXY_TEXTURE_CUBE_MAP_ARRAY = 0x900B
SAMPLER_CUBE_MAP_ARRAY = 0x900C
SAMPLER_CUBE_MAP_ARRAY_SHADOW = 0x900D
INT_SAMPLER_CUBE_MAP_ARRAY = 0x900E
UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F
@accepts(t.enum, t.void)
@returns(t.void)
@binds(dll)
def draw_arrays_indirect(mode, indirect):
    '''
    render primitives from array data, taking parameters from memory.
    
    gl.draw_arrays_indirect specifies multiple geometric primitives with very
    few subroutine calls. gl.draw_arrays_indirect behaves similarly to
    gl.draw_arrays_instanced_base_instance, execept that the parameters to
    gl.draw_arrays_instanced_base_instance are stored in memory at the address
    given by indirect.
    
    Args:
        mode: what kind of primitives to render.
        indirect: the address of a structure containing the draw parameters.
    '''

@accepts(t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def draw_elements_indirect(mode, type, indirect):
    '''
    render indexed primitives from array data, taking parameters from memory.
    
    gl.draw_elements_indirect specifies multiple indexed geometric primitives
    with very few subroutine calls. gl.draw_elements_indirect behaves similarly
    to gl.draw_elements_instanced_base_vertex_base_instance, execpt that the
    parameters to gl.draw_elements_instanced_base_vertex_base_instance are
    stored in memory at the address given by indirect.
    
    Args:
        mode: what kind of primitives to render.
        type: the type of data in the buffer bound to the
            gl_element_array_buffer binding.
        indirect: the address of a structure containing the draw parameters.
    '''

DRAW_INDIRECT_BUFFER = 0x8F3F
DRAW_INDIRECT_BUFFER_BINDING = 0x8F43
GEOMETRY_SHADER_INVOCATIONS = 0x887F
MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A
MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B
MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C
FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D
MAX_VERTEX_STREAMS = 0x8E71
@accepts(t.int, t.double)
@returns(t.void)
@binds(dll)
def uniform1d(location, x):
    pass

@accepts(t.int, t.double, t.double)
@returns(t.void)
@binds(dll)
def uniform2d(location, x, y):
    pass

@accepts(t.int, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def uniform3d(location, x, y, z):
    pass

@accepts(t.int, t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def uniform4d(location, x, y, z, w):
    pass

@accepts(t.int, t.sizei, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform1dv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform2dv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform3dv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform4dv(location, count, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix2dv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix3dv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix4dv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix2x3dv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix2x4dv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix3x2dv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix3x4dv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix4x2dv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.double))
@returns(t.void)
@binds(dll)
def uniform_matrix4x3dv(location, count, transpose, value):
    pass

@accepts(t.uint, t.int, POINTER(t.double))
@returns(t.void)
@binds(dll)
def get_uniformdv(program, location, params):
    pass

DOUBLE_VEC2 = 0x8FFC
DOUBLE_VEC3 = 0x8FFD
DOUBLE_VEC4 = 0x8FFE
DOUBLE_MAT2 = 0x8F46
DOUBLE_MAT3 = 0x8F47
DOUBLE_MAT4 = 0x8F48
DOUBLE_MAT2x3 = 0x8F49
DOUBLE_MAT2x4 = 0x8F4A
DOUBLE_MAT3x2 = 0x8F4B
DOUBLE_MAT3x4 = 0x8F4C
DOUBLE_MAT4x2 = 0x8F4D
DOUBLE_MAT4x3 = 0x8F4E
@accepts(t.uint, t.enum, t.char_p)
@returns(t.int)
@binds(dll)
def get_subroutine_uniform_location(program, shadertype, name):
    '''
    retrieve the location of a subroutine uniform of a given shader stage within a
program.
    
    gl.get_subroutine_uniform_location returns the location of the subroutine
    uniform variable name in the shader stage of type shadertype attached to
    program, with behavior otherwise identical to gl.get_uniform_location.
    
    Args:
        program: the name of the program containing shader stage.
        shadertype: the shader stage from which to query for subroutine uniform
            index.
        name: the name of the subroutine uniform whose index to query.
    '''

@accepts(t.uint, t.enum, t.char_p)
@returns(t.uint)
@binds(dll)
def get_subroutine_index(program, shadertype, name):
    '''
    retrieve the index of a subroutine uniform of a given shader stage within a
program.
    
    gl.get_subroutine_index returns the index of a subroutine uniform within a
    shader stage attached to a program object. program contains the name of the
    program to which the shader is attached. shadertype specifies the stage from
    which to query shader subroutine index. name contains the null-terminated
    name of the subroutine uniform whose name to query.
    
    Args:
        program: the name of the program containing shader stage.
        shadertype: the shader stage from which to query for subroutine uniform
            index.
        name: the name of the subroutine uniform whose index to query.
    '''

@accepts(t.uint, t.enum, t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_active_subroutine_uniformiv(program, shadertype, index, pname, values):
    pass

@accepts(t.uint, t.enum, t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_subroutine_uniform_name(program, shadertype, index, bufsize, length, name):
    '''
    query the name of an active shader subroutine uniform.
    
    gl.get_active_subroutine_uniform_name retrieves the name of an active shader
    subroutine uniform. program contains the name of the program containing the
    uniform. shadertype specifies the stage for which which the uniform
    location, given by index, is valid. index must be between zero and the value
    of gl.ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage.
    
    Args:
        program: the name of the program containing the subroutine.
        shadertype: the shader stage from which to query for the subroutine
            parameter.
        index: the index of the shader subroutine uniform.
        bufsize: the size of the buffer whose address is given in name.
        length: the address of a variable into which is written the number of
            characters copied into name.
        name: the address of a buffer that will receive the name of the
            specified shader subroutine uniform.
    '''

@accepts(t.uint, t.enum, t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_subroutine_name(program, shadertype, index, bufsize, length, name):
    '''
    query the name of an active shader subroutine.
    
    gl.get_active_subroutine_name queries the name of an active shader
    subroutine uniform from the program object given in program. index specifies
    the index of the shader subroutine uniform within the shader stage given by
    stage, and must between zero and the value of gl.ACTIVE_SUBROUTINES minus
    one for the shader stage.
    
    Args:
        program: the name of the program containing the subroutine.
        shadertype: the shader stage from which to query the subroutine name.
        index: the index of the shader subroutine uniform.
        bufsize: the size of the buffer whose address is given in name.
        length: the address of a variable which is to receive the length of the
            shader subroutine uniform name.
        name: the address of an array into which the name of the shader
            subroutine uniform will be written.
    '''

@accepts(t.enum, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform_subroutinesuiv(shadertype, count, indices):
    pass

@accepts(t.enum, t.int, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_uniform_subroutineuiv(shadertype, location, params):
    pass

@accepts(t.uint, t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_program_stageiv(program, shadertype, pname, values):
    pass

ACTIVE_SUBROUTINES = 0x8DE5
ACTIVE_SUBROUTINE_UNIFORMS = 0x8DE6
ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47
ACTIVE_SUBROUTINE_MAX_LENGTH = 0x8E48
ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49
MAX_SUBROUTINES = 0x8DE7
MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8
NUM_COMPATIBLE_SUBROUTINES = 0x8E4A
COMPATIBLE_SUBROUTINES = 0x8E4B
@accepts(t.enum, t.int)
@returns(t.void)
@binds(dll)
def patch_parameteri(pname, value):
    pass

@accepts(t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def patch_parameterfv(pname, values):
    pass

PATCHES = 0x000E
PATCH_VERTICES = 0x8E72
PATCH_DEFAULT_INNER_LEVEL = 0x8E73
PATCH_DEFAULT_OUTER_LEVEL = 0x8E74
TESS_CONTROL_OUTPUT_VERTICES = 0x8E75
TESS_GEN_MODE = 0x8E76
TESS_GEN_SPACING = 0x8E77
TESS_GEN_VERTEX_ORDER = 0x8E78
TESS_GEN_POINT_MODE = 0x8E79
ISOLINES = 0x8E7A
QUADS = 0x0007
FRACTIONAL_ODD = 0x8E7B
FRACTIONAL_EVEN = 0x8E7C
MAX_PATCH_VERTICES = 0x8E7D
MAX_TESS_GEN_LEVEL = 0x8E7E
MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F
MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80
MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81
MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82
MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83
MAX_TESS_PATCH_COMPONENTS = 0x8E84
MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85
MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86
MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89
MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A
MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C
MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D
MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E
MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F
UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0
UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1
TESS_EVALUATION_SHADER = 0x8E87
TESS_CONTROL_SHADER = 0x8E88
@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def bind_transform_feedback(target, id):
    '''
    bind a transform feedback object.
    
    gl.bind_transform_feedback binds the transform feedback object with name id
    to the current GL state. id must be a name previously returned from a call
    to gl.gen_transform_feedbacks. If id has not previously been bound, a new
    transform feedback object with name id and initialized with with the default
    transform state vector is created.
    
    Args:
        target: the target to which to bind the transform feedback object id.
        id: the name of a transform feedback object reserved by
            glgentransformfeedbacks.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_transform_feedbacks(n, ids):
    '''
    delete transform feedback objects.
    
    gl.delete_transform_feedbacks deletes the n transform feedback objects whose
    names are stored in the array ids. Unused names in ids are ignored, as is
    the name zero. After a transform feedback object is deleted, its name is
    again unused and it has no contents. If an active transform feedback object
    is deleted, its name immediately becomes unused, but the underlying object
    is not deleted until it is no longer active.
    
    Args:
        n: the number of transform feedback objects to delete.
        ids: an array of names of transform feedback objects to delete.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_transform_feedbacks(n, ids):
    '''
    reserve transform feedback object names.
    
    gl.gen_transform_feedbacks returns n previously unused transform feedback
    object names in ids. These names are marked as used, for the purposes of
    gl.gen_transform_feedbacks only, but they acquire transform feedback state
    only when they are first bound.
    
    Args:
        n: the number of transform feedback object names to reserve.
        ids: an array of into which the reserved names will be written.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_transform_feedback(id):
    '''
    determine if a name corresponds to a transform feedback object.
    
    gl.is_transform_feedback returns gl.TRUE if id is currently the name of a
    transform feedback object. If id is zero, or if id is not the name of a
    transform feedback object, or if an error occurs, gl.is_transform_feedback
    returns gl.FALSE. If id is a name returned by gl.gen_transform_feedbacks,
    but that has not yet been bound through a call to
    gl.bind_transform_feedback, then the name is not a transform feedback object
    and gl.is_transform_feedback returns gl.FALSE.
    
    Args:
        id: a value that may be the name of a transform feedback object.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def pause_transform_feedback():
    '''
    pause transform feedback operations.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def resume_transform_feedback():
    '''
    resume transform feedback operations.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def draw_transform_feedback(mode, id):
    '''
    render primitives using a count derived from a transform feedback object.
    
    gl.draw_transform_feedback draws primitives of a type specified by mode
    using a count retrieved from the transform feedback specified by id. Calling
    gl.draw_transform_feedback is equivalent to calling gl.draw_arrays with mode
    as specified, first set to zero, and count set to the number of vertices
    captured on vertex stream zero the last time transform feedback was active
    on the transform feedback object named by id.
    
    Args:
        mode: what kind of primitives to render.
        id: the name of a transform feedback object from which to retrieve a
            primitive count.
    '''

TRANSFORM_FEEDBACK = 0x8E22
TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23
TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24
TRANSFORM_FEEDBACK_BINDING = 0x8E25
@accepts(t.enum, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def draw_transform_feedback_stream(mode, id, stream):
    '''
    render primitives using a count derived from a specifed stream of a transform
feedback object.
    
    gl.draw_transform_feedback_stream draws primitives of a type specified by
    mode using a count retrieved from the transform feedback stream specified by
    stream of the transform feedback object specified by id. Calling
    gl.draw_transform_feedback_stream is equivalent to calling gl.draw_arrays
    with mode as specified, first set to zero, and count set to the number of
    vertices captured on vertex stream stream the last time transform feedback
    was active on the transform feedback object named by id.
    
    Args:
        mode: what kind of primitives to render.
        id: the name of a transform feedback object from which to retrieve a
            primitive count.
        stream: the index of the transform feedback stream from which to
            retrieve a primitive count.
    '''

@accepts(t.enum, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def begin_query_indexed(target, index, id):
    '''
    delimit the boundaries of a query object on an indexed target.
    
    Args:
        target: the target type of query object established between
            glbeginqueryindexed and the subsequent glendqueryindexed.
        index: the index of the query target upon which to begin the query.
        id: the name of a query object.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def end_query_indexed(target, index):
    pass

@accepts(t.enum, t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_query_indexediv(target, index, pname, params):
    pass

MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70
MAX_VERTEX_STREAMS = 0x8E71