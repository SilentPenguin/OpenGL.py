#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

CONTEXT_CORE_PROFILE_BIT = 0x00000001
CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002
LINES_ADJACENCY = 0x000A
LINE_STRIP_ADJACENCY = 0x000B
TRIANGLES_ADJACENCY = 0x000C
TRIANGLE_STRIP_ADJACENCY = 0x000D
PROGRAM_POINT_SIZE = 0x8642
MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29
FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7
FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8
GEOMETRY_SHADER = 0x8DD9
GEOMETRY_VERTICES_OUT = 0x8916
GEOMETRY_INPUT_TYPE = 0x8917
GEOMETRY_OUTPUT_TYPE = 0x8918
MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF
MAX_GEOMETRY_OUTPUT_VERTICES = 0x8DE0
MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1
MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122
MAX_GEOMETRY_INPUT_COMPONENTS = 0x9123
MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124
MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125
CONTEXT_PROFILE_MASK = 0x9126
DEPTH_CLAMP = 0x864F
@accepts(t.enum, t.sizei, t.enum, t.void, t.int)
@returns(t.void)
@binds(dll)
def draw_elements_base_vertex(mode, count, type, indices, basevertex):
    '''
    render primitives from array data with a per-element offset.
    
    gl.draw_elements_base_vertex behaves identically to gl.draw_elements except
    that the ith element transferred by the corresponding draw call will be
    taken from element indices[i] + basevertex of each enabled array. If the
    resulting value is larger than the maximum value representable by type, it
    is as if the calculation were upconverted to 32-bit unsigned integers (with
    wrapping on overflow conditions). The operation is undefined if the sum
    would be negative.
    
    Args:
        mode: what kind of primitives to render.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        basevertex: a constant that should be added to each element of indices
            when chosing elements from the enabled vertex arrays.
    '''

@accepts(t.enum, t.uint, t.uint, t.sizei, t.enum, t.void, t.int)
@returns(t.void)
@binds(dll)
def draw_range_elements_base_vertex(mode, start, end, count, type, indices, basevertex):
    '''
    render primitives from array data with a per-element offset.
    
    gl.draw_range_elements_base_vertex is a restricted form of
    gl.draw_elements_base_vertex. mode, start, end, count and basevertex match
    the corresponding arguments to gl.draw_elements_base_vertex, with the
    additional constraint that all values in the array indices must lie between
    start and end, inclusive, prior to adding basevertex. Index values lying
    outside the range [start, end] are treated in the same way as
    gl.draw_elements_base_vertex. The ith element transferred by the
    corresponding draw call will be taken from element indices[i] + basevertex
    of each enabled array.
    
    Args:
        mode: what kind of primitives to render.
        start: the minimum array index contained in indices.
        end: the maximum array index contained in indices.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        basevertex: a constant that should be added to each element of indices
            when chosing elements from the enabled vertex arrays.
    '''

@accepts(t.enum, t.sizei, t.enum, t.void, t.sizei, t.int)
@returns(t.void)
@binds(dll)
def draw_elements_instanced_base_vertex(mode, count, type, indices, instancecount, basevertex):
    '''
    render multiple instances of a set of primitives from array data with a per-
element offset.
    
    gl.draw_elements_instanced_base_vertex behaves identically to
    gl.draw_elements_instanced except that the ith element transferred by the
    corresponding draw call will be taken from element indices[i] + basevertex
    of each enabled array. If the resulting value is larger than the maximum
    value representable by type, it is as if the calculation were upconverted to
    32-bit unsigned integers (with wrapping on overflow conditions). The
    operation is undefined if the sum would be negative.
    
    Args:
        mode: what kind of primitives to render.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        instancecount: the number of instances of the indexed geometry that
            should be drawn.
        basevertex: a constant that should be added to each element of indices
            when chosing elements from the enabled vertex arrays.
    '''

@accepts(t.enum, POINTER(t.sizei), t.enum, t.void, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def multi_draw_elements_base_vertex(mode, count, type, indices, drawcount, basevertex):
    '''
    render multiple sets of primitives by specifying indices of array data elements
and an index to apply to each index.
    
    gl.multi_draw_elements_base_vertex behaves identically to
    gl.draw_elements_base_vertex, except that drawcount separate lists of
    elements are specifried instead.
    
    Args:
        mode: what kind of primitives to render.
        count: points to an array of the elements counts.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        drawcount: the size of the count, indices and basevertex arrays.
        basevertex: a pointer to the location where the base vertices are
            stored.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def provoking_vertex(mode):
    '''
    specifiy the vertex to be used as the source of data for flat shaded varyings.
    
    Args:
        mode: the vertex to be used as the source of data for flat shaded
            varyings.
    '''

QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C
FIRST_VERTEX_CONVENTION = 0x8E4D
LAST_VERTEX_CONVENTION = 0x8E4E
PROVOKING_VERTEX = 0x8E4F
TEXTURE_CUBE_MAP_SEAMLESS = 0x884F
@accepts(t.enum, t.bitfield)
@returns(t.sync)
@binds(dll)
def fence_sync(condition, flags):
    '''
    create a new sync object and insert it into the GL command stream.
    
    gl.fence_sync creates a new fence sync object, inserts a fence command into
    the GL command stream and associates it with that sync object, and returns a
    non-zero name corresponding to the sync object.
    
    Args:
        condition: the condition that must be met to set the sync object's state
            to signaled.
        flags: a bitwise combination of flags controlling the behavior of the
            sync object.
    '''

@accepts(t.sync)
@returns(t.boolean)
@binds(dll)
def is_sync(sync):
    '''
    determine if a name corresponds to a sync object.
    
    gl.is_sync returns gl.TRUE if sync is currently the name of a sync object.
    If sync is not the name of a sync object, or if an error occurs, gl.is_sync
    returns gl.FALSE. Note that zero is not the name of a sync object.
    
    Args:
        sync: a value that may be the name of a sync object.
    '''

@accepts(t.sync)
@returns(t.void)
@binds(dll)
def delete_sync(sync):
    '''
    delete a sync object.
    
    gl.delete_sync deletes the sync object specified by sync. If the fence
    command corresponding to the specified sync object has completed, or if no
    gl.wait_sync or gl.client_wait_sync commands are blocking on sync, the
    object is deleted immediately. Otherwise, sync is flagged for deletion and
    will be deleted when it is no longer associated with any fence command and
    is no longer blocking any gl.wait_sync or gl.client_wait_sync command. In
    either case, after gl.delete_sync returns, the name sync is invalid and can
    no longer be used to refer to the sync object.
    
    Args:
        sync: the sync object to be deleted.
    '''

@accepts(t.sync, t.bitfield, t.uint64)
@returns(t.enum)
@binds(dll)
def client_wait_sync(sync, flags, timeout):
    '''
    block and wait for a sync object to become signaled.
    
    gl.client_wait_sync causes the client to block and wait for the sync object
    specified by sync to become signaled. If sync is signaled when
    gl.client_wait_sync is called, gl.client_wait_sync returns immediately,
    otherwise it will block and wait for up to timeout nanoseconds for sync to
    become signaled.
    
    Args:
        sync: the sync object whose status to wait on.
        flags: a bitfield controlling the command flushing behavior.
        timeout: the timeout, specified in nanoseconds, for which the
            implementation should wait for sync to become signaled.
    '''

@accepts(t.sync, t.bitfield, t.uint64)
@returns(t.void)
@binds(dll)
def wait_sync(sync, flags, timeout):
    '''
    instruct the GL server to block until the specified sync object becomes signaled.
    
    gl.wait_sync causes the GL server to block and wait until sync becomes
    signaled. sync is the name of an existing sync object upon which to wait.
    flags and timeout are currently not used and must be set to zero and the
    special value gl.TIMEOUT_IGNORED, respectivelyflags and timeout are
    placeholders for anticipated future extensions of sync object capabilities.
    They must have these reserved values in order that existing code calling
    gl.wait_sync operate properly in the presence of such extensions.
    
    Args:
        sync: the sync object whose status to wait on.
        flags: a bitfield controlling the command flushing behavior.
        timeout: the timeout that the server should wait before continuing.
    '''

@accepts(t.enum, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_integer64v(pname, data):
    pass

@accepts(t.sync, t.enum, t.sizei, POINTER(t.sizei), POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_synciv(sync, pname, bufsize, length, values):
    pass

MAX_SERVER_WAIT_TIMEOUT = 0x9111
OBJECT_TYPE = 0x9112
SYNC_CONDITION = 0x9113
SYNC_STATUS = 0x9114
SYNC_FLAGS = 0x9115
SYNC_FENCE = 0x9116
SYNC_GPU_COMMANDS_COMPLETE = 0x9117
UNSIGNALED = 0x9118
SIGNALED = 0x9119
ALREADY_SIGNALED = 0x911A
TIMEOUT_EXPIRED = 0x911B
CONDITION_SATISFIED = 0x911C
WAIT_FAILED = 0x911D
TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF
SYNC_FLUSH_COMMANDS_BIT = 0x00000001
@accepts(t.enum, t.uint, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_integer64i_v(target, index, data):
    pass

@accepts(t.enum, t.enum, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_buffer_parameteri64v(target, pname, params):
    pass

@accepts(t.enum, t.enum, t.uint, t.int)
@returns(t.void)
@binds(dll)
def framebuffer_texture(target, attachment, texture, level):
    '''
    attach a level of a texture object as a logical buffer of a framebuffer object.
    
    Args:
        target: the target to which the framebuffer is bound for all commands
            except glnamedframebuffertexture.
        attachment: the attachment point of the framebuffer.
        texture: the name of an existing texture object to attach.
        level: the mipmap level of the texture object to attach.
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.boolean)
@returns(t.void)
@binds(dll)
def tex_image2_d_multisample(target, samples, internalformat, width, height, fixedsamplelocations):
    '''
    establish the data storage, format, dimensions, and number of samples of a
multisample texture's image.
    
    Args:
        target: the target of the operation.
        samples: the number of samples in the multisample texture's image.
        internalformat: the internal format to be used to store the multisample
            texture's image.
        width: the width of the multisample texture's image, in texels.
        height: the height of the multisample texture's image, in texels.
        fixedsamplelocations: whether the image will use identical sample
            locations and the same number of samples for all texels in the
            image, and the sample locations will not depend on the internal
            format or size of the image.
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.sizei, t.boolean)
@returns(t.void)
@binds(dll)
def tex_image3_d_multisample(target, samples, internalformat, width, height, depth, fixedsamplelocations):
    '''
    establish the data storage, format, dimensions, and number of samples of a
multisample texture's image.
    
    Args:
        target: the target of the operation.
        samples: the number of samples in the multisample texture's image.
        internalformat: the internal format to be used to store the multisample
            texture's image.
        width: the width of the multisample texture's image, in texels.
        height: the height of the multisample texture's image, in texels.
        fixedsamplelocations: whether the image will use identical sample
            locations and the same number of samples for all texels in the
            image, and the sample locations will not depend on the internal
            format or size of the image.
    '''

@accepts(t.enum, t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_multisamplefv(pname, index, val):
    pass

@accepts(t.uint, t.bitfield)
@returns(t.void)
@binds(dll)
def sample_maski(masknumber, mask):
    '''
    set the value of a sub-word of the sample mask.
    
    gl.sample_maski sets one 32-bit sub-word of the multi-word sample mask,
    gl.SAMPLE_MASK_VALUE.
    
    Args:
        masknumber: which 32-bit sub-word of the sample mask to update.
        mask: the new value of the mask sub-word.
    '''

SAMPLE_POSITION = 0x8E50
SAMPLE_MASK = 0x8E51
SAMPLE_MASK_VALUE = 0x8E52
MAX_SAMPLE_MASK_WORDS = 0x8E59
TEXTURE_2D_MULTISAMPLE = 0x9100
PROXY_TEXTURE_2D_MULTISAMPLE = 0x9101
TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9102
PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103
TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104
TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105
TEXTURE_SAMPLES = 0x9106
TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107
SAMPLER_2D_MULTISAMPLE = 0x9108
INT_SAMPLER_2D_MULTISAMPLE = 0x9109
UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A
SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910B
INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C
UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D
MAX_COLOR_TEXTURE_SAMPLES = 0x910E
MAX_DEPTH_TEXTURE_SAMPLES = 0x910F
MAX_INTEGER_SAMPLES = 0x9110