#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

CONTEXT_CORE_PROFILE_BIT = 0x00000001
CONTEXT_COMPATIBILITY_PROFILE_BIT = 0x00000002
LINES_ADJACENCY = 0x000A
LINE_STRIP_ADJACENCY = 0x000B
TRIANGLES_ADJACENCY = 0x000C
TRIANGLE_STRIP_ADJACENCY = 0x000D
PROGRAM_POINT_SIZE = 0x8642
MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29
FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7
FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8
GEOMETRY_SHADER = 0x8DD9
GEOMETRY_VERTICES_OUT = 0x8916
GEOMETRY_INPUT_TYPE = 0x8917
GEOMETRY_OUTPUT_TYPE = 0x8918
MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF
MAX_GEOMETRY_OUTPUT_VERTICES = 0x8DE0
MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1
MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122
MAX_GEOMETRY_INPUT_COMPONENTS = 0x9123
MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124
MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125
CONTEXT_PROFILE_MASK = 0x9126
DEPTH_CLAMP = 0x864F
@accepts(t.enum, t.sizei, t.enum, t.void, t.int)
@returns(t.void)
@binds(dll)
def draw_elements_base_vertex(mode, count, type, indices, basevertex):
    '''
    render primitives from array data with a per-element offset
    
    Args:
        mode: Specifies what kind of primitives to render
        count: Specifies the number of elements to be rendered
        type: Specifies the type of the values in indices
        indices: Specifies a pointer to the location where the indices are
            stored
        basevertex: Specifies a constant that should be added to each element of
            indices when chosing elements from the enabled vertex arrays
    '''

@accepts(t.enum, t.uint, t.uint, t.sizei, t.enum, t.void, t.int)
@returns(t.void)
@binds(dll)
def draw_range_elements_base_vertex(mode, start, end, count, type, indices, basevertex):
    '''
    render primitives from array data with a per-element offset
    
    Args:
        mode: Specifies what kind of primitives to render
        start: Specifies the minimum array index contained in indices
        end: Specifies the maximum array index contained in indices
        count: Specifies the number of elements to be rendered
        type: Specifies the type of the values in indices
        indices: Specifies a pointer to the location where the indices are
            stored
        basevertex: Specifies a constant that should be added to each element of
            indices when chosing elements from the enabled vertex arrays
    '''

@accepts(t.enum, t.sizei, t.enum, t.void, t.sizei, t.int)
@returns(t.void)
@binds(dll)
def draw_elements_instanced_base_vertex(mode, count, type, indices, instancecount, basevertex):
    '''
    render multiple instances of a set of primitives from array data with a per-
element offset
    
    Args:
        mode: Specifies what kind of primitives to render
        count: Specifies the number of elements to be rendered
        type: Specifies the type of the values in indices
        indices: Specifies a pointer to the location where the indices are
            stored
        instancecount: Specifies the number of instances of the indexed geometry
            that should be drawn
        basevertex: Specifies a constant that should be added to each element of
            indices when chosing elements from the enabled vertex arrays
    '''

@accepts(t.enum, POINTER(t.sizei), t.enum, t.void, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def multi_draw_elements_base_vertex(mode, count, type, indices, drawcount, basevertex):
    '''
    render multiple sets of primitives by specifying indices of array data elements
and an index to apply to each index
    
    Args:
        mode: Specifies what kind of primitives to render
        count: Points to an array of the elements counts
        type: Specifies the type of the values in indices
        indices: Specifies a pointer to the location where the indices are
            stored
        drawcount: Specifies the size of the count, indices and basevertex
            arrays
        basevertex: Specifies a pointer to the location where the base vertices
            are stored
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def provoking_vertex(mode):
    '''
    specifiy the vertex to be used as the source of data for flat shaded varyings
    
    Args:
        mode: Specifies the vertex to be used as the source of data for flat
            shaded varyings
    '''

QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C
FIRST_VERTEX_CONVENTION = 0x8E4D
LAST_VERTEX_CONVENTION = 0x8E4E
PROVOKING_VERTEX = 0x8E4F
TEXTURE_CUBE_MAP_SEAMLESS = 0x884F
@accepts(t.enum, t.bitfield)
@returns(t.sync)
@binds(dll)
def fence_sync(condition, flags):
    '''
    create a new sync object and insert it into the GL command stream
    
    Args:
        condition: Specifies the condition that must be met to set the sync
            object's state to signaled
        flags: Specifies a bitwise combination of flags controlling the behavior
            of the sync object
    '''

@accepts(t.sync)
@returns(t.boolean)
@binds(dll)
def is_sync(sync):
    '''
    determine if a name corresponds to a sync object
    
    Args:
        sync: Specifies a value that may be the name of a sync object
    '''

@accepts(t.sync)
@returns(t.void)
@binds(dll)
def delete_sync(sync):
    '''
    delete a sync object
    
    Args:
        sync: The sync object to be deleted
    '''

@accepts(t.sync, t.bitfield, t.uint64)
@returns(t.enum)
@binds(dll)
def client_wait_sync(sync, flags, timeout):
    '''
    block and wait for a sync object to become signaled
    
    Args:
        sync: The sync object whose status to wait on
        flags: A bitfield controlling the command flushing behavior
        timeout: The timeout, specified in nanoseconds, for which the
            implementation should wait for sync to become signaled
    '''

@accepts(t.sync, t.bitfield, t.uint64)
@returns(t.void)
@binds(dll)
def wait_sync(sync, flags, timeout):
    '''
    instruct the GL server to block until the specified sync object becomes signaled
    
    Args:
        sync: Specifies the sync object whose status to wait on
        flags: A bitfield controlling the command flushing behavior
        timeout: Specifies the timeout that the server should wait before
            continuing
    '''

@accepts(t.enum, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_integer64v(pname, data):
    pass

@accepts(t.sync, t.enum, t.sizei, POINTER(t.sizei), POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_synciv(sync, pname, bufsize, length, values):
    pass

MAX_SERVER_WAIT_TIMEOUT = 0x9111
OBJECT_TYPE = 0x9112
SYNC_CONDITION = 0x9113
SYNC_STATUS = 0x9114
SYNC_FLAGS = 0x9115
SYNC_FENCE = 0x9116
SYNC_GPU_COMMANDS_COMPLETE = 0x9117
UNSIGNALED = 0x9118
SIGNALED = 0x9119
ALREADY_SIGNALED = 0x911A
TIMEOUT_EXPIRED = 0x911B
CONDITION_SATISFIED = 0x911C
WAIT_FAILED = 0x911D
TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF
SYNC_FLUSH_COMMANDS_BIT = 0x00000001
@accepts(t.enum, t.uint, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_integer64i_v(target, index, data):
    pass

@accepts(t.enum, t.enum, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_buffer_parameteri64v(target, pname, params):
    pass

@accepts(t.enum, t.enum, t.uint, t.int)
@returns(t.void)
@binds(dll)
def framebuffer_texture(target, attachment, texture, level):
    '''
    attach a level of a texture object as a logical buffer of a framebuffer object
    
    Args:
        target: Specifies the target to which the framebuffer is bound for all
            commands except gl.named_framebuffer_texture
        attachment: Specifies the attachment point of the framebuffer
        texture: Specifies the name of an existing texture object to attach
        level: Specifies the mipmap level of the texture object to attach
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.boolean)
@returns(t.void)
@binds(dll)
def tex_image2_d_multisample(target, samples, internalformat, width, height, fixedsamplelocations):
    '''
    establish the data storage, format, dimensions, and number of samples of a
multisample texture's image
    
    Args:
        target: Specifies the target of the operation
        samples: The number of samples in the multisample texture's image
        internalformat: The internal format to be used to store the multisample
            texture's image
        width: The width of the multisample texture's image, in texels
        height: The height of the multisample texture's image, in texels
        fixedsamplelocations: Specifies whether the image will use identical
            sample locations and the same number of samples for all texels in
            the image, and the sample locations will not depend on the internal
            format or size of the image
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.sizei, t.boolean)
@returns(t.void)
@binds(dll)
def tex_image3_d_multisample(target, samples, internalformat, width, height, depth, fixedsamplelocations):
    '''
    establish the data storage, format, dimensions, and number of samples of a
multisample texture's image
    
    Args:
        target: Specifies the target of the operation
        samples: The number of samples in the multisample texture's image
        internalformat: The internal format to be used to store the multisample
            texture's image
        width: The width of the multisample texture's image, in texels
        height: The height of the multisample texture's image, in texels
        fixedsamplelocations: Specifies whether the image will use identical
            sample locations and the same number of samples for all texels in
            the image, and the sample locations will not depend on the internal
            format or size of the image
    '''

@accepts(t.enum, t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_multisamplefv(pname, index, val):
    pass

@accepts(t.uint, t.bitfield)
@returns(t.void)
@binds(dll)
def sample_maski(masknumber, mask):
    '''
    set the value of a sub-word of the sample mask
    
    Args:
        masknumber: Specifies which 32-bit sub-word of the sample mask to update
        mask: Specifies the new value of the mask sub-word
    '''

SAMPLE_POSITION = 0x8E50
SAMPLE_MASK = 0x8E51
SAMPLE_MASK_VALUE = 0x8E52
MAX_SAMPLE_MASK_WORDS = 0x8E59
TEXTURE_2D_MULTISAMPLE = 0x9100
PROXY_TEXTURE_2D_MULTISAMPLE = 0x9101
TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9102
PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103
TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104
TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105
TEXTURE_SAMPLES = 0x9106
TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107
SAMPLER_2D_MULTISAMPLE = 0x9108
INT_SAMPLER_2D_MULTISAMPLE = 0x9109
UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A
SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910B
INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C
UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D
MAX_COLOR_TEXTURE_SAMPLES = 0x910E
MAX_DEPTH_TEXTURE_SAMPLES = 0x910F
MAX_INTEGER_SAMPLES = 0x9110