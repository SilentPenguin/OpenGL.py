#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def read_buffer(src):
    '''
    select a color buffer source for pixels.
    
    gl.read_buffer specifies a color buffer as the source for subsequent
    gl.read_pixels, gl.copy_tex_image1D, gl.copy_tex_image2D,
    gl.copy_tex_sub_image1D, gl.copy_tex_sub_image2D, and
    gl.copy_tex_sub_image3D commands. mode accepts one of twelve or more
    predefined values. In a fully configured system, gl.FRONT, gl.LEFT, and
    gl.FRONT_LEFT all name the front left buffer, gl.FRONT_RIGHT and gl.RIGHT
    name the front right buffer, and gl.BACK_LEFT and gl.BACK name the back left
    buffer. Further more, the constants gl.COLOR_ATTACHMENTi may be used to
    indicate the ith color attachment where i ranges from zero to the value of
    gl.MAX_COLOR_ATTACHMENTS minus one.
    
    Args:
        src: a color buffer.
    '''

@accepts(t.enum, t.uint, t.uint, t.sizei, t.enum, t.void)
@returns(t.void)
@binds(dll)
def draw_range_elements(mode, start, end, count, type, indices):
    '''
    render primitives from array data.
    
    gl.draw_range_elements is a restricted form of gl.draw_elements. mode,
    start, end, and count match the corresponding arguments to gl.draw_elements,
    with the additional constraint that all values in the arrays count must lie
    between start and end, inclusive.
    
    Args:
        mode: what kind of primitives to render.
        start: the minimum array index contained in indices.
        end: the maximum array index contained in indices.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
    '''

@accepts(t.enum, t.int, t.int, t.sizei, t.sizei, t.sizei, t.int, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def tex_image3_d(target, level, internalformat, width, height, depth, border, format, type, pixels):
    '''
    specify a three-dimensional texture image.
    
    Args:
        target: the target texture.
        level: the level-of-detail number.
        internalformat: the number of color components in the texture.
        width: the width of the texture image.
        height: the height of the texture image.
        depth: the depth of the texture image, or the number of layers in a
            texture array.
        border: this value must be 0.
        format: the format of the pixel data.
        type: the data type of the pixel data.
        pixels: a pointer to the image data in memory.
    '''

@accepts(t.enum, t.int, t.int, t.int, t.int, t.sizei, t.sizei, t.sizei, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def tex_sub_image3_d(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels):
    '''
    specify a three-dimensional texture subimage.
    
    Args:
        target: the target to which the texture is bound for gltexsubimage3d.
        level: the level-of-detail number.
        xoffset: a texel offset in the x direction within the texture array.
        yoffset: a texel offset in the y direction within the texture array.
        zoffset: a texel offset in the z direction within the texture array.
        width: the width of the texture subimage.
        height: the height of the texture subimage.
        depth: the depth of the texture subimage.
        format: the format of the pixel data.
        type: the data type of the pixel data.
        pixels: a pointer to the image data in memory.
    '''

@accepts(t.enum, t.int, t.int, t.int, t.int, t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def copy_tex_sub_image3_d(target, level, xoffset, yoffset, zoffset, x, y, width, height):
    '''
    copy a three-dimensional texture subimage.
    
    Args:
        target: the target to which the texture object is bound for
            glcopytexsubimage3d function.
        level: the level-of-detail number.
        xoffset: a texel offset in the x direction within the texture array.
        yoffset: a texel offset in the y direction within the texture array.
        zoffset: a texel offset in the z direction within the texture array.
        x: the window coordinates of the lower left corner of the rectangular
            region of pixels to be copied.
        y: the window coordinates of the lower left corner of the rectangular
            region of pixels to be copied.
        width: the width of the texture subimage.
        height: the height of the texture subimage.
    '''

@accepts(t.enum, t.int, t.enum, t.sizei, t.sizei, t.sizei, t.int, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def compressed_tex_image3_d(target, level, internalformat, width, height, depth, border, imagesize, data):
    '''
    specify a three-dimensional texture image in a compressed format.
    
    Args:
        target: the target texture.
        level: the level-of-detail number.
        internalformat: the format of the compressed image data stored at
            address data.
        width: the width of the texture image.
        height: the height of the texture image.
        depth: the depth of the texture image.
        border: this value must be 0.
        imagesize: the number of unsigned bytes of image data starting at the
            address specified by data.
        data: a pointer to the compressed image data in memory.
    '''

@accepts(t.enum, t.int, t.int, t.int, t.int, t.sizei, t.sizei, t.sizei, t.enum, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def compressed_tex_sub_image3_d(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data):
    '''
    specify a three-dimensional texture subimage in a compressed format.
    
    Args:
        target: the target to which the texture is bound for
            glcompressedtexsubimage3d function.
        level: the level-of-detail number.
        xoffset: a texel offset in the x direction within the texture array.
        yoffset: a texel offset in the y direction within the texture array.
        width: the width of the texture subimage.
        height: the height of the texture subimage.
        depth: the depth of the texture subimage.
        format: the format of the compressed image data stored at address data.
        imagesize: the number of unsigned bytes of image data starting at the
            address specified by data.
        data: a pointer to the compressed image data in memory.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_queries(n, ids):
    '''
    generate query object names.
    
    gl.gen_queries returns n query object names in ids. There is no guarantee
    that the names form a contiguous set of integers; however, it is guaranteed
    that none of the returned names was in use immediately before the call to
    gl.gen_queries.
    
    Args:
        n: the number of query object names to be generated.
        ids: an array in which the generated query object names are stored.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_queries(n, ids):
    '''
    delete named query objects.
    
    gl.delete_queries deletes n query objects named by the elements of the array
    ids. After a query object is deleted, it has no contents, and its name is
    free for reuse.
    
    Args:
        n: the number of query objects to be deleted.
        ids: an array of query objects to be deleted.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_query(id):
    '''
    determine if a name corresponds to a query object.
    
    gl.is_query returns gl.TRUE if id is currently the name of a query object.
    If id is zero, or is a non-zero value that is not currently the name of a
    query object, or if an error occurs, gl.is_query returns gl.FALSE.
    
    Args:
        id: a value that may be the name of a query object.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def begin_query(target, id):
    '''
    delimit the boundaries of a query object.
    
    Args:
        target: the target type of query object established between glbeginquery
            and the subsequent glendquery.
        id: the name of a query object.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def end_query(target):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_queryiv(target, pname, params):
    '''
    return parameters of a query object target.
    
    gl.get_queryiv returns in params a selected parameter of the query object
    target specified by target.
    
    Args:
        target: a query object target.
        pname: the symbolic name of a query object target parameter.
        params: returns the requested data.
    '''

@accepts(t.uint, t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_query_objectuiv(id, pname, params):
    pass

@accepts(t.enum)
@returns(t.boolean)
@binds(dll)
def unmap_buffer(target):
    '''
    release the mapping of a buffer object's data store into the client's address
space.
    
    gl.unmap_buffer and gl.unmap_named_buffer unmap any mapping of a specified
    buffer object into the client's address space.
    
    Args:
        target: the target to which the buffer object is bound for
            glunmapbuffer, which must be one of the buffer binding targets in
            the following table:.
    '''

@accepts(t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def get_buffer_pointerv(target, pname, params):
    '''
    return the pointer to a mapped buffer object's data store.
    
    gl.get_buffer_pointerv and gl.get_named_buffer_pointerv return the buffer
    pointer pname, which must be gl.BUFFER_MAP_POINTER. The single buffer map
    pointer is returned in params. A None pointer is returned if the buffer
    object's data store is not currently mapped; or if the requesting context
    did not map the buffer object's data store, and the implementation is unable
    to support mappings on multiple clients.
    
    Args:
        target: the target to which the buffer object is bound for
            glgetbufferpointerv, which must be one of the buffer binding targets
            in the following table:.
        pname: the name of the pointer to be returned.
        params: returns the pointer value specified by pname.
    '''

@accepts(t.sizei, POINTER(t.enum))
@returns(t.void)
@binds(dll)
def draw_buffers(n, bufs):
    '''
    Specifies a list of color buffers to be drawn into.
    
    gl.draw_buffers and gl.named_framebuffer_draw_buffers define an array of
    buffers into which outputs from the fragment shader data will be written. If
    a fragment shader writes a value to one or more user defined output
    variables, then the value of each variable will be written into the buffer
    specified at a location within bufs corresponding to the location assigned
    to that user defined output. The draw buffer used for user defined outputs
    assigned to locations greater than or equal to n is implicitly set to
    gl.NONE and any data written to such an output is discarded.
    
    Args:
        n: the number of buffers in bufs.
        bufs: points to an array of symbolic constants specifying the buffers
            into which fragment colors or data values will be written.
    '''

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix2x3fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix3x2fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix2x4fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix4x2fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix3x4fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix4x3fv(location, count, transpose, value):
    pass

@accepts(t.int, t.int, t.int, t.int, t.int, t.int, t.int, t.int, t.bitfield, t.enum)
@returns(t.void)
@binds(dll)
def blit_framebuffer(srcx0, srcy0, srcx1, srcy1, dstx0, dsty0, dstx1, dsty1, mask, filter):
    '''
    copy a block of pixels from one framebuffer object to another.
    
    gl.blit_framebuffer and gl.blit_named_framebuffer transfer a rectangle of
    pixel values from one region of a read framebuffer to another region of a
    draw framebuffer.
    
    Args:
        srcx0: the bounds of the source rectangle within the read buffer of the
            read framebuffer.
        srcy0: the bounds of the source rectangle within the read buffer of the
            read framebuffer.
        srcx1: the bounds of the source rectangle within the read buffer of the
            read framebuffer.
        srcy1: the bounds of the source rectangle within the read buffer of the
            read framebuffer.
        dstx0: the bounds of the destination rectangle within the write buffer
            of the write framebuffer.
        dsty0: the bounds of the destination rectangle within the write buffer
            of the write framebuffer.
        dstx1: the bounds of the destination rectangle within the write buffer
            of the write framebuffer.
        dsty1: the bounds of the destination rectangle within the write buffer
            of the write framebuffer.
        mask: the bitwise or of the flags indicating which buffers are to be
            copied.
        filter: the interpolation to be applied if the image is stretched.
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def renderbuffer_storage_multisample(target, samples, internalformat, width, height):
    '''
    establish data storage, format, dimensions and sample count of a renderbuffer
object's image.
    
    gl.renderbuffer_storage_multisample and
    gl.named_renderbuffer_storage_multisample establish the data storage,
    format, dimensions and number of samples of a renderbuffer object's image.
    
    Args:
        target: a binding target of the allocation for
            glrenderbufferstoragemultisample function.
        samples: the number of samples to be used for the renderbuffer object's
            storage.
        internalformat: the internal format to use for the renderbuffer object's
            image.
        width: the width of the renderbuffer, in pixels.
        height: the height of the renderbuffer, in pixels.
    '''

@accepts(t.enum, t.enum, t.uint, t.int, t.int)
@returns(t.void)
@binds(dll)
def framebuffer_texture_layer(target, attachment, texture, level, layer):
    '''
    attach a single layer of a texture object as a logical buffer of a framebuffer
object.
    
    gl.framebuffer_texture_layer and gl.named_framebuffer_texture_layer attach a
    single layer of a three-dimensional or array texture object as one of the
    logical buffers of the specified framebuffer object. Textures cannot be
    attached to the default draw and read framebuffer, so they are not valid
    targets of these commands.
    
    Args:
        target: the target to which the framebuffer is bound for
            glframebuffertexturelayer.
        attachment: the attachment point of the framebuffer.
        texture: the name of an existing texture object to attach.
        level: the mipmap level of the texture object to attach.
        layer: the layer of the texture object to attach.
    '''

@accepts(t.enum, t.intptr, t.sizeiptr, t.bitfield)
@returns(t.void)
@binds(dll)
def map_buffer_range(target, offset, length, access):
    '''
    map all or part of a buffer object's data store into the client's address space.
    
    gl.map_buffer_range and gl.map_named_buffer_range map all or part of the
    data store of a specified buffer object into the client's address space.
    offset and length indicate the range of data in the buffer object that is to
    be mapped, in terms of basic machine units. access is a bitfield containing
    flags which describe the requested mapping. These flags are described below.
    
    Args:
        target: the target to which the buffer object is bound for
            glmapbufferrange, which must be one of the buffer binding targets in
            the following table:.
        offset: the starting offset within the buffer of the range to be mapped.
        length: the length of the range to be mapped.
        access: a combination of access flags indicating the desired access to
            the mapped range.
    '''

@accepts(t.enum, t.intptr, t.sizeiptr)
@returns(t.void)
@binds(dll)
def flush_mapped_buffer_range(target, offset, length):
    '''
    indicate modifications to a range of a mapped buffer.
    
    gl.flush_mapped_buffer_range indicates that modifications have been made to
    a range of a mapped buffer object. The buffer object must previously have
    been mapped with the gl.MAP_FLUSH_EXPLICIT_BIT flag.
    
    Args:
        target: the target to which the buffer object is bound for
            glflushmappedbufferrange, which must be one of the buffer binding
            targets in the following table:.
        offset: the start of the buffer subrange, in basic machine units.
        length: the length of the buffer subrange, in basic machine units.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def bind_vertex_array(array):
    '''
    bind a vertex array object.
    
    gl.bind_vertex_array binds the vertex array object with name array. array is
    the name of a vertex array object previously returned from a call to
    gl.gen_vertex_arrays, or zero to break the existing vertex array object
    binding.
    
    Args:
        array: the name of the vertex array to bind.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_vertex_arrays(n, arrays):
    '''
    delete vertex array objects.
    
    gl.delete_vertex_arrays deletes n vertex array objects whose names are
    stored in the array addressed by arrays. Once a vertex array object is
    deleted it has no contents and its name is again unused. If a vertex array
    object that is currently bound is deleted, the binding for that object
    reverts to zero and the default vertex array becomes current. Unused names
    in arrays are silently ignored, as is the value zero.
    
    Args:
        n: the number of vertex array objects to be deleted.
        arrays: the address of an array containing the n names of the objects to
            be deleted.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_vertex_arrays(n, arrays):
    '''
    generate vertex array object names.
    
    gl.gen_vertex_arrays returns n vertex array object names in arrays. There is
    no guarantee that the names form a contiguous set of integers; however, it
    is guaranteed that none of the returned names was in use immediately before
    the call to gl.gen_vertex_arrays.
    
    Args:
        n: the number of vertex array object names to generate.
        arrays: an array in which the generated vertex array object names are
            stored.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_vertex_array(array):
    '''
    determine if a name corresponds to a vertex array object.
    
    gl.is_vertex_array returns gl.TRUE if array is currently the name of a
    vertex array object. If array is zero, or if array is not the name of a
    vertex array object, or if an error occurs, gl.is_vertex_array returns
    gl.FALSE. If array is a name returned by gl.gen_vertex_arrays, by that has
    not yet been bound through a call to gl.bind_vertex_array, then the name is
    not a vertex array object and gl.is_vertex_array returns gl.FALSE.
    
    Args:
        array: a value that may be the name of a vertex array object.
    '''

@accepts(t.enum, t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_integeri_v(target, index, data):
    pass

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def begin_transform_feedback(primitivemode):
    '''
    start transform feedback operation.
    
    Args:
        primitivemode: the output type of the primitives that will be recorded
            into the buffer objects that are bound for transform feedback.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def end_transform_feedback():
    pass

@accepts(t.enum, t.uint, t.uint, t.intptr, t.sizeiptr)
@returns(t.void)
@binds(dll)
def bind_buffer_range(target, index, buffer, offset, size):
    '''
    bind a range within a buffer object to an indexed buffer target.
    
    gl.bind_buffer_range binds a range the buffer object buffer represented by
    offset and size to the binding point at index index of the array of targets
    specified by target. Each target represents an indexed array of buffer
    binding points, as well as a single general binding point that can be used
    by other buffer manipulation functions such as gl.bind_buffer or
    gl.map_buffer. In addition to binding a range of buffer to the indexed
    buffer binding target, gl.bind_buffer_range also binds the range to the
    generic buffer binding point specified by target.
    
    Args:
        target: the target of the bind operation.
        index: the index of the binding point within the array specified by
            target.
        buffer: the name of a buffer object to bind to the specified binding
            point.
        offset: the starting offset in basic machine units into the buffer
            object buffer.
        size: the amount of data in machine units that can be read from the
            buffer object while used as an indexed target.
    '''

@accepts(t.enum, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def bind_buffer_base(target, index, buffer):
    '''
    bind a buffer object to an indexed buffer target.
    
    gl.bind_buffer_base binds the buffer object buffer to the binding point at
    index index of the array of targets specified by target. Each target
    represents an indexed array of buffer binding points, as well as a single
    general binding point that can be used by other buffer manipulation
    functions such as gl.bind_buffer or gl.map_buffer. In addition to binding
    buffer to the indexed buffer binding target, gl.bind_buffer_base also binds
    buffer to the generic buffer binding point specified by target.
    
    Args:
        target: the target of the bind operation.
        index: the index of the binding point within the array specified by
            target.
        buffer: the name of a buffer object to bind to the specified binding
            point.
    '''

@accepts(t.uint, t.sizei, POINTER(t.char_p), t.enum)
@returns(t.void)
@binds(dll)
def transform_feedback_varyings(program, count, varyings, buffermode):
    '''
    specify values to record in transform feedback buffers.
    
    Args:
        program: the name of the target program object.
        count: the number of varying variables used for transform feedback.
        varyings: an array of count zero-terminated strings specifying the names
            of the varying variables to use for transform feedback.
        buffermode: identifies the mode used to capture the varying variables
            when transform feedback is active.
    '''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.sizei), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_transform_feedback_varying(program, index, bufsize, length, size, type, name):
    '''
    retrieve information about varying variables selected for transform feedback.
    
    Args:
        program: the name of the target program object.
        index: the index of the varying variable whose information to retrieve.
        bufsize: the maximum number of characters, including the null
            terminator, that may be written into name.
        length: the address of a variable which will receive the number of
            characters written into name, excluding the null-terminator.
        size: the address of a variable that will receive the size of the
            varying.
        type: the address of a variable that will recieve the type of the
            varying.
        name: the address of a buffer into which will be written the name of the
            varying.
    '''

@accepts(t.uint, t.int, t.enum, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def vertex_attrib_i_pointer(index, size, type, stride, pointer):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_vertex_attrib_iiv(index, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_vertex_attrib_iuiv(index, pname, params):
    pass

@accepts(t.uint, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def vertex_attrib_i4i(index, x, y, z, w):
    pass

@accepts(t.uint, t.uint, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def vertex_attrib_i4ui(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex_attrib_i4iv(index, v):
    pass

@accepts(t.uint, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def vertex_attrib_i4uiv(index, v):
    pass

@accepts(t.uint, t.int, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_uniformuiv(program, location, params):
    pass

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_frag_data_location(program, name):
    '''
    query the bindings of color numbers to user-defined varying out variables.
    
    gl.get_frag_data_location retrieves the assigned color number binding for
    the user-defined varying out variable name for program program. program must
    have previously been linked. name must be a null-terminated string. If name
    is not the name of an active user-defined varying out fragment shader
    variable within program, -1 will be returned.
    
    Args:
        program: the name of the program containing varying out variable whose
            binding to query.
        name: the name of the user-defined varying out variable whose binding to
            query.
    '''

@accepts(t.int, t.uint)
@returns(t.void)
@binds(dll)
def uniform1ui(location, v0):
    pass

@accepts(t.int, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def uniform2ui(location, v0, v1):
    pass

@accepts(t.int, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def uniform3ui(location, v0, v1, v2):
    pass

@accepts(t.int, t.uint, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def uniform4ui(location, v0, v1, v2, v3):
    pass

@accepts(t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform1uiv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform2uiv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform3uiv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform4uiv(location, count, value):
    pass

@accepts(t.enum, t.int, POINTER(t.int))
@returns(t.void)
@binds(dll)
def clear_bufferiv(buffer, drawbuffer, value):
    pass

@accepts(t.enum, t.int, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def clear_bufferuiv(buffer, drawbuffer, value):
    pass

@accepts(t.enum, t.int, POINTER(t.float))
@returns(t.void)
@binds(dll)
def clear_bufferfv(buffer, drawbuffer, value):
    pass

@accepts(t.enum, t.int, t.float, t.int)
@returns(t.void)
@binds(dll)
def clear_bufferfi(buffer, drawbuffer, depth, stencil):
    pass

@accepts(t.enum, t.uint)
@returns(POINTER(t.ubyte))
@binds(dll)
def get_stringi(name, index):
    pass

@accepts(t.enum, t.enum, t.intptr, t.intptr, t.sizeiptr)
@returns(t.void)
@binds(dll)
def copy_buffer_sub_data(readtarget, writetarget, readoffset, writeoffset, size):
    '''
    copy all or part of the data store of a buffer object to the data store of
another buffer object.
    
    gl.copy_buffer_sub_data and gl.copy_named_buffer_sub_data copy part of the
    data store attached to a source buffer object to the data store attached to
    a destination buffer object. The number of basic machine units indicated by
    size is copied from the source at offset readOffset to the destination at
    writeOffset. readOffset, writeOffset and size are in terms of basic machine
    units.
    
    Args:
        readtarget: the target to which the source buffer object is bound for
            glcopybuffersubdata.
        writetarget: the target to which the destination buffer object is bound
            for glcopybuffersubdata.
        readoffset: the offset, in basic machine units, within the data store of
            the source buffer object at which data will be read.
        writeoffset: the offset, in basic machine units, within the data store
            of the destination buffer object at which data will be written.
        size: the size, in basic machine units, of the data to be copied from
            the source buffer object to the destination buffer object.
    '''

@accepts(t.uint, t.sizei, POINTER(t.char_p), POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_uniform_indices(program, uniformcount, uniformnames, uniformindices):
    '''
    retrieve the index of a named uniform block.
    
    gl.get_uniform_indices retrieves the indices of a number of uniforms within
    program.
    
    Args:
        program: the name of a program containing uniforms whose indices to
            query.
        uniformcount: the number of uniforms whose indices to query.
        uniformnames: the address of an array of pointers to buffers containing
            the names of the queried uniforms.
        uniformindices: the address of an array that will receive the indices of
            the uniforms.
    '''

@accepts(t.uint, t.sizei, POINTER(t.uint), t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_active_uniformsiv(program, uniformcount, uniformindices, pname, params):
    '''
    Returns information about several active uniform variables for the specified
program object.
    
    gl.get_active_uniformsiv queries the value of the parameter named pname for
    each of the uniforms within program whose indices are specified in the array
    of uniformCount unsigned integers uniformIndices. Upon success, the value of
    the parameter for each uniform is written into the corresponding entry in
    the array whose address is given in params. If an error is generated,
    nothing is written into params.
    
    Args:
        program: the program object to be queried.
        uniformcount: both the number of elements in the array of indices
            uniformindices and the number of parameters written to params upon
            successful return.
        uniformindices: the address of an array of uniformcount integers
            containing the indices of uniforms within program whose parameter
            pname should be queried.
        pname: the property of each uniform in uniformindices that should be
            written into the corresponding element of params.
        params: the address of an array of uniformcount integers which are to
            receive the value of pname for each uniform in uniformindices.
    '''

@accepts(t.uint, t.char_p)
@returns(t.uint)
@binds(dll)
def get_uniform_block_index(program, uniformblockname):
    '''
    retrieve the index of a named uniform block.
    
    gl.get_uniform_block_index retrieves the index of a uniform block within
    program.
    
    Args:
        program: the name of a program containing the uniform block.
        uniformblockname: the address an array of characters to containing the
            name of the uniform block whose index to retrieve.
    '''

@accepts(t.uint, t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_active_uniform_blockiv(program, uniformblockindex, pname, params):
    pass

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_uniform_block_name(program, uniformblockindex, bufsize, length, uniformblockname):
    '''
    retrieve the name of an active uniform block.
    
    gl.get_active_uniform_block_name retrieves the name of the active uniform
    block at uniformBlockIndex within program.
    
    Args:
        program: the name of a program containing the uniform block.
        uniformblockindex: the index of the uniform block within program.
        bufsize: the size of the buffer addressed by uniformblockname.
        length: the address of a variable to receive the number of characters
            that were written to uniformblockname.
        uniformblockname: the address an array of characters to receive the name
            of the uniform block at uniformblockindex.
    '''

@accepts(t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def uniform_block_binding(program, uniformblockindex, uniformblockbinding):
    '''
    assign a binding point to an active uniform block.
    
    Args:
        program: the name of a program object containing the active uniform
            block whose binding to assign.
        uniformblockindex: the index of the active uniform block within program
            whose binding to assign.
        uniformblockbinding: the binding point to which to bind the uniform
            block with index uniformblockindex within program.
    '''

@accepts(t.enum, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def draw_arrays_instanced(mode, first, count, instancecount):
    '''
    draw multiple instances of a range of elements.
    
    gl.draw_arrays_instanced behaves identically to gl.draw_arrays except that
    primcount instances of the range of elements are executed and the value of
    the internal counter instanceID advances for each iteration. instanceID is
    an internal 32-bit integer counter that may be read by a vertex shader as
    gl_InstanceID.
    
    Args:
        mode: what kind of primitives to render.
        first: the starting index in the enabled arrays.
        count: the number of indices to be rendered.
        instancecount: the number of instances of the specified range of indices
            to be rendered.
    '''

@accepts(t.enum, t.sizei, t.enum, t.void, t.sizei)
@returns(t.void)
@binds(dll)
def draw_elements_instanced(mode, count, type, indices, instancecount):
    '''
    draw multiple instances of a set of elements.
    
    gl.draw_elements_instanced behaves identically to gl.draw_elements except
    that primcount instances of the set of elements are executed and the value
    of the internal counter instanceID advances for each iteration. instanceID
    is an internal 32-bit integer counter that may be read by a vertex shader as
    gl_InstanceID.
    
    Args:
        mode: what kind of primitives to render.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        instancecount: the number of instances of the specified range of indices
            to be rendered.
    '''

@accepts(t.enum, t.bitfield)
@returns(t.sync)
@binds(dll)
def fence_sync(condition, flags):
    '''
    create a new sync object and insert it into the GL command stream.
    
    gl.fence_sync creates a new fence sync object, inserts a fence command into
    the GL command stream and associates it with that sync object, and returns a
    non-zero name corresponding to the sync object.
    
    Args:
        condition: the condition that must be met to set the sync object's state
            to signaled.
        flags: a bitwise combination of flags controlling the behavior of the
            sync object.
    '''

@accepts(t.sync)
@returns(t.boolean)
@binds(dll)
def is_sync(sync):
    '''
    determine if a name corresponds to a sync object.
    
    gl.is_sync returns gl.TRUE if sync is currently the name of a sync object.
    If sync is not the name of a sync object, or if an error occurs, gl.is_sync
    returns gl.FALSE. Note that zero is not the name of a sync object.
    
    Args:
        sync: a value that may be the name of a sync object.
    '''

@accepts(t.sync)
@returns(t.void)
@binds(dll)
def delete_sync(sync):
    '''
    delete a sync object.
    
    gl.delete_sync deletes the sync object specified by sync. If the fence
    command corresponding to the specified sync object has completed, or if no
    gl.wait_sync or gl.client_wait_sync commands are blocking on sync, the
    object is deleted immediately. Otherwise, sync is flagged for deletion and
    will be deleted when it is no longer associated with any fence command and
    is no longer blocking any gl.wait_sync or gl.client_wait_sync command. In
    either case, after gl.delete_sync returns, the name sync is invalid and can
    no longer be used to refer to the sync object.
    
    Args:
        sync: the sync object to be deleted.
    '''

@accepts(t.sync, t.bitfield, t.uint64)
@returns(t.enum)
@binds(dll)
def client_wait_sync(sync, flags, timeout):
    '''
    block and wait for a sync object to become signaled.
    
    gl.client_wait_sync causes the client to block and wait for the sync object
    specified by sync to become signaled. If sync is signaled when
    gl.client_wait_sync is called, gl.client_wait_sync returns immediately,
    otherwise it will block and wait for up to timeout nanoseconds for sync to
    become signaled.
    
    Args:
        sync: the sync object whose status to wait on.
        flags: a bitfield controlling the command flushing behavior.
        timeout: the timeout, specified in nanoseconds, for which the
            implementation should wait for sync to become signaled.
    '''

@accepts(t.sync, t.bitfield, t.uint64)
@returns(t.void)
@binds(dll)
def wait_sync(sync, flags, timeout):
    '''
    instruct the GL server to block until the specified sync object becomes signaled.
    
    gl.wait_sync causes the GL server to block and wait until sync becomes
    signaled. sync is the name of an existing sync object upon which to wait.
    flags and timeout are currently not used and must be set to zero and the
    special value gl.TIMEOUT_IGNORED, respectivelyflags and timeout are
    placeholders for anticipated future extensions of sync object capabilities.
    They must have these reserved values in order that existing code calling
    gl.wait_sync operate properly in the presence of such extensions.
    
    Args:
        sync: the sync object whose status to wait on.
        flags: a bitfield controlling the command flushing behavior.
        timeout: the timeout that the server should wait before continuing.
    '''

@accepts(t.enum, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_integer64v(pname, data):
    pass

@accepts(t.sync, t.enum, t.sizei, POINTER(t.sizei), POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_synciv(sync, pname, bufsize, length, values):
    pass

@accepts(t.enum, t.uint, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_integer64i_v(target, index, data):
    pass

@accepts(t.enum, t.enum, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_buffer_parameteri64v(target, pname, params):
    pass

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_samplers(count, samplers):
    '''
    generate sampler object names.
    
    gl.gen_samplers returns n sampler object names in samplers. There is no
    guarantee that the names form a contiguous set of integers; however, it is
    guaranteed that none of the returned names was in use immediately before the
    call to gl.gen_samplers.
    
    Args:
        count: the number of sampler object names to generate.
        samplers: an array in which the generated sampler object names are
            stored.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_samplers(count, samplers):
    '''
    delete named sampler objects.
    
    gl.delete_samplers deletes n sampler objects named by the elements of the
    array samplers. After a sampler object is deleted, its name is again unused.
    If a sampler object that is currently bound to a sampler unit is deleted, it
    is as though gl.bind_sampler is called with unit set to the unit the sampler
    is bound to and sampler zero. Unused names in samplers are silently ignored,
    as is the reserved name zero.
    
    Args:
        count: the number of sampler objects to be deleted.
        samplers: an array of sampler objects to be deleted.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_sampler(sampler):
    '''
    determine if a name corresponds to a sampler object.
    
    gl.is_sampler returns gl.TRUE if id is currently the name of a sampler
    object. If id is zero, or is a non-zero value that is not currently the name
    of a sampler object, or if an error occurs, gl.is_sampler returns gl.FALSE.
    
    Args:
        sampler: a value that may be the name of a sampler object.
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def bind_sampler(unit, sampler):
    '''
    bind a named sampler to a texturing target.
    
    gl.bind_sampler binds sampler to the texture unit at index unit. sampler
    must be zero or the name of a sampler object previously returned from a call
    to gl.gen_samplers. unit must be less than the value of
    gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS.
    
    Args:
        unit: the index of the texture unit to which the sampler is bound.
        sampler: the name of a sampler.
    '''

@accepts(t.uint, t.enum, t.int)
@returns(t.void)
@binds(dll)
def sampler_parameteri(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def sampler_parameteriv(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, t.float)
@returns(t.void)
@binds(dll)
def sampler_parameterf(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def sampler_parameterfv(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_sampler_parameteriv(sampler, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_sampler_parameterfv(sampler, pname, params):
    pass

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def vertex_attrib_divisor(index, divisor):
    '''
    modify the rate at which generic vertex attributes advance during instanced
rendering.
    
    gl.vertex_attrib_divisor modifies the rate at which generic vertex
    attributes advance when rendering multiple instances of primitives in a
    single draw call. If divisor is zero, the attribute at slot index advances
    once per vertex. If divisor is non-zero, the attribute advances once per
    divisor instances of the set of vertices being rendered. An attribute is
    referred to as instanced if its gl.VERTEX_ATTRIB_ARRAY_DIVISOR value is non-
    zero.
    
    Args:
        index: the index of the generic vertex attribute.
        divisor: the number of instances that will pass between updates of the
            generic attribute at slot index.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def bind_transform_feedback(target, id):
    '''
    bind a transform feedback object.
    
    gl.bind_transform_feedback binds the transform feedback object with name id
    to the current GL state. id must be a name previously returned from a call
    to gl.gen_transform_feedbacks. If id has not previously been bound, a new
    transform feedback object with name id and initialized with with the default
    transform state vector is created.
    
    Args:
        target: the target to which to bind the transform feedback object id.
        id: the name of a transform feedback object reserved by
            glgentransformfeedbacks.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_transform_feedbacks(n, ids):
    '''
    delete transform feedback objects.
    
    gl.delete_transform_feedbacks deletes the n transform feedback objects whose
    names are stored in the array ids. Unused names in ids are ignored, as is
    the name zero. After a transform feedback object is deleted, its name is
    again unused and it has no contents. If an active transform feedback object
    is deleted, its name immediately becomes unused, but the underlying object
    is not deleted until it is no longer active.
    
    Args:
        n: the number of transform feedback objects to delete.
        ids: an array of names of transform feedback objects to delete.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_transform_feedbacks(n, ids):
    '''
    reserve transform feedback object names.
    
    gl.gen_transform_feedbacks returns n previously unused transform feedback
    object names in ids. These names are marked as used, for the purposes of
    gl.gen_transform_feedbacks only, but they acquire transform feedback state
    only when they are first bound.
    
    Args:
        n: the number of transform feedback object names to reserve.
        ids: an array of into which the reserved names will be written.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_transform_feedback(id):
    '''
    determine if a name corresponds to a transform feedback object.
    
    gl.is_transform_feedback returns gl.TRUE if id is currently the name of a
    transform feedback object. If id is zero, or if id is not the name of a
    transform feedback object, or if an error occurs, gl.is_transform_feedback
    returns gl.FALSE. If id is a name returned by gl.gen_transform_feedbacks,
    but that has not yet been bound through a call to
    gl.bind_transform_feedback, then the name is not a transform feedback object
    and gl.is_transform_feedback returns gl.FALSE.
    
    Args:
        id: a value that may be the name of a transform feedback object.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def pause_transform_feedback():
    '''
    pause transform feedback operations.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def resume_transform_feedback():
    '''
    resume transform feedback operations.
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), POINTER(t.enum), t.void)
@returns(t.void)
@binds(dll)
def get_program_binary(program, bufsize, length, binaryformat, binary):
    '''
    return a binary representation of a program object's compiled and linked
executable source.
    
    gl.get_program_binary returns a binary representation of the compiled and
    linked executable for program into the array of bytes whose address is
    specified in binary. The maximum number of bytes that may be written into
    binary is specified by bufSize. If the program binary is greater in size
    than bufSize bytes, then an error is generated, otherwise the actual number
    of bytes written into binary is returned in the variable whose address is
    given by length. If length is None, then no length is returned.
    
    Args:
        program: the name of a program object whose binary representation to
            retrieve.
        length: the address of a variable to receive the number of bytes written
            into binary.
        binaryformat: the address of a variable to receive a token indicating
            the format of the binary data returned by the gl.
        binary: the address an array into which the gl will return program's
            binary representation.
    '''

@accepts(t.uint, t.enum, t.void, t.sizei)
@returns(t.void)
@binds(dll)
def program_binary(program, binaryformat, binary, length):
    '''
    load a program object with a program binary.
    
    gl.program_binary loads a program object with a program binary previously
    returned from gl.get_program_binary. binaryFormat and binary must be those
    returned by a previous call to gl.get_program_binary, and length must be the
    length returned by gl.get_program_binary, or by gl.get_program when called
    with pname set to gl.PROGRAM_BINARY_LENGTH. If these conditions are not met,
    loading the program binary will fail and program's gl.LINK_STATUS will be
    set to gl.FALSE.
    
    Args:
        program: the name of a program object into which to load a program
            binary.
        binaryformat: the format of the binary data in binary.
        binary: the address an array containing the binary to be loaded into
            program.
        length: the number of bytes contained in binary.
    '''

@accepts(t.uint, t.enum, t.int)
@returns(t.void)
@binds(dll)
def program_parameteri(program, pname, value):
    pass

@accepts(t.enum, t.sizei, POINTER(t.enum))
@returns(t.void)
@binds(dll)
def invalidate_framebuffer(target, numattachments, attachments):
    '''
    invalidate the content of some or all of a framebuffer's attachments.
    
    gl.invalidate_framebuffer and gl.invalidate_named_framebuffer_data
    invalidate the entire contents of a specified set of attachments of a
    framebuffer.
    
    Args:
        target: the target to which the framebuffer object is attached for
            glinvalidateframebuffer.
        numattachments: the number of entries in the attachments array.
        attachments: a pointer to an array identifying the attachments to be
            invalidated.
    '''

@accepts(t.enum, t.sizei, POINTER(t.enum), t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def invalidate_sub_framebuffer(target, numattachments, attachments, x, y, width, height):
    '''
    invalidate the content of a region of some or all of a framebuffer's attachments.
    
    gl.invalidate_sub_framebuffer and gl.invalidate_named_framebuffer_sub_data
    invalidate the contents of a specified region of a specified set of
    attachments of a framebuffer.
    
    Args:
        target: the target to which the framebuffer object is attached for
            glinvalidatesubframebuffer.
        numattachments: the number of entries in the attachments array.
        attachments: a pointer to an array identifying the attachments to be
            invalidated.
        x: the x offset of the region to be invalidated.
        y: the y offset of the region to be invalidated.
        width: the width of the region to be invalidated.
        height: the height of the region to be invalidated.
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def tex_storage2_d(target, levels, internalformat, width, height):
    '''
    simultaneously specify storage for all levels of a two-dimensional or one-
dimensional array texture.
    
    Args:
        target: the target to which the texture object is bound for
            gltexstorage2d.
        levels: the number of texture levels.
        internalformat: the sized internal format to be used to store texture
            image data.
        width: the width of the texture, in texels.
        height: the height of the texture, in texels.
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def tex_storage3_d(target, levels, internalformat, width, height, depth):
    '''
    simultaneously specify storage for all levels of a three-dimensional, two-
dimensional array or cube-map array texture.
    
    Args:
        target: the target to which the texture object is bound for
            gltexstorage3d.
        levels: the number of texture levels.
        internalformat: the sized internal format to be used to store texture
            image data.
        width: the width of the texture, in texels.
        height: the height of the texture, in texels.
        depth: the depth of the texture, in texels.
    '''

@accepts(t.enum, t.enum, t.enum, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_internalformativ(target, internalformat, pname, bufsize, params):
    pass

READ_BUFFER = 0x0C02
UNPACK_ROW_LENGTH = 0x0CF2
UNPACK_SKIP_ROWS = 0x0CF3
UNPACK_SKIP_PIXELS = 0x0CF4
PACK_ROW_LENGTH = 0x0D02
PACK_SKIP_ROWS = 0x0D03
PACK_SKIP_PIXELS = 0x0D04
COLOR = 0x1800
DEPTH = 0x1801
STENCIL = 0x1802
RED = 0x1903
RGB8 = 0x8051
RGBA8 = 0x8058
RGB10_A2 = 0x8059
TEXTURE_BINDING_3D = 0x806A
UNPACK_SKIP_IMAGES = 0x806D
UNPACK_IMAGE_HEIGHT = 0x806E
TEXTURE_3D = 0x806F
TEXTURE_WRAP_R = 0x8072
MAX_3D_TEXTURE_SIZE = 0x8073
UNSIGNED_INT_2_10_10_10_REV = 0x8368
MAX_ELEMENTS_VERTICES = 0x80E8
MAX_ELEMENTS_INDICES = 0x80E9
TEXTURE_MIN_LOD = 0x813A
TEXTURE_MAX_LOD = 0x813B
TEXTURE_BASE_LEVEL = 0x813C
TEXTURE_MAX_LEVEL = 0x813D
MIN = 0x8007
MAX = 0x8008
DEPTH_COMPONENT24 = 0x81A6
MAX_TEXTURE_LOD_BIAS = 0x84FD
TEXTURE_COMPARE_MODE = 0x884C
TEXTURE_COMPARE_FUNC = 0x884D
CURRENT_QUERY = 0x8865
QUERY_RESULT = 0x8866
QUERY_RESULT_AVAILABLE = 0x8867
BUFFER_MAPPED = 0x88BC
BUFFER_MAP_POINTER = 0x88BD
STREAM_READ = 0x88E1
STREAM_COPY = 0x88E2
STATIC_READ = 0x88E5
STATIC_COPY = 0x88E6
DYNAMIC_READ = 0x88E9
DYNAMIC_COPY = 0x88EA
MAX_DRAW_BUFFERS = 0x8824
DRAW_BUFFER0 = 0x8825
DRAW_BUFFER1 = 0x8826
DRAW_BUFFER2 = 0x8827
DRAW_BUFFER3 = 0x8828
DRAW_BUFFER4 = 0x8829
DRAW_BUFFER5 = 0x882A
DRAW_BUFFER6 = 0x882B
DRAW_BUFFER7 = 0x882C
DRAW_BUFFER8 = 0x882D
DRAW_BUFFER9 = 0x882E
DRAW_BUFFER10 = 0x882F
DRAW_BUFFER11 = 0x8830
DRAW_BUFFER12 = 0x8831
DRAW_BUFFER13 = 0x8832
DRAW_BUFFER14 = 0x8833
DRAW_BUFFER15 = 0x8834
MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49
MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A
SAMPLER_3D = 0x8B5F
SAMPLER_2D_SHADOW = 0x8B62
FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B
PIXEL_PACK_BUFFER = 0x88EB
PIXEL_UNPACK_BUFFER = 0x88EC
PIXEL_PACK_BUFFER_BINDING = 0x88ED
PIXEL_UNPACK_BUFFER_BINDING = 0x88EF
FLOAT_MAT2x3 = 0x8B65
FLOAT_MAT2x4 = 0x8B66
FLOAT_MAT3x2 = 0x8B67
FLOAT_MAT3x4 = 0x8B68
FLOAT_MAT4x2 = 0x8B69
FLOAT_MAT4x3 = 0x8B6A
SRGB = 0x8C40
SRGB8 = 0x8C41
SRGB8_ALPHA8 = 0x8C43
COMPARE_REF_TO_TEXTURE = 0x884E
MAJOR_VERSION = 0x821B
MINOR_VERSION = 0x821C
NUM_EXTENSIONS = 0x821D
RGBA32F = 0x8814
RGB32F = 0x8815
RGBA16F = 0x881A
RGB16F = 0x881B
VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD
MAX_ARRAY_TEXTURE_LAYERS = 0x88FF
MIN_PROGRAM_TEXEL_OFFSET = 0x8904
MAX_PROGRAM_TEXEL_OFFSET = 0x8905
MAX_VARYING_COMPONENTS = 0x8B4B
TEXTURE_2D_ARRAY = 0x8C1A
TEXTURE_BINDING_2D_ARRAY = 0x8C1D
R11F_G11F_B10F = 0x8C3A
UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B
RGB9_E5 = 0x8C3D
UNSIGNED_INT_5_9_9_9_REV = 0x8C3E
TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76
TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F
MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80
TRANSFORM_FEEDBACK_VARYINGS = 0x8C83
TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84
TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85
TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88
RASTERIZER_DISCARD = 0x8C89
MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A
MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B
INTERLEAVED_ATTRIBS = 0x8C8C
SEPARATE_ATTRIBS = 0x8C8D
TRANSFORM_FEEDBACK_BUFFER = 0x8C8E
TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F
RGBA32UI = 0x8D70
RGB32UI = 0x8D71
RGBA16UI = 0x8D76
RGB16UI = 0x8D77
RGBA8UI = 0x8D7C
RGB8UI = 0x8D7D
RGBA32I = 0x8D82
RGB32I = 0x8D83
RGBA16I = 0x8D88
RGB16I = 0x8D89
RGBA8I = 0x8D8E
RGB8I = 0x8D8F
RED_INTEGER = 0x8D94
RGB_INTEGER = 0x8D98
RGBA_INTEGER = 0x8D99
SAMPLER_2D_ARRAY = 0x8DC1
SAMPLER_2D_ARRAY_SHADOW = 0x8DC4
SAMPLER_CUBE_SHADOW = 0x8DC5
UNSIGNED_INT_VEC2 = 0x8DC6
UNSIGNED_INT_VEC3 = 0x8DC7
UNSIGNED_INT_VEC4 = 0x8DC8
INT_SAMPLER_2D = 0x8DCA
INT_SAMPLER_3D = 0x8DCB
INT_SAMPLER_CUBE = 0x8DCC
INT_SAMPLER_2D_ARRAY = 0x8DCF
UNSIGNED_INT_SAMPLER_2D = 0x8DD2
UNSIGNED_INT_SAMPLER_3D = 0x8DD3
UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4
UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7
BUFFER_ACCESS_FLAGS = 0x911F
BUFFER_MAP_LENGTH = 0x9120
BUFFER_MAP_OFFSET = 0x9121
DEPTH_COMPONENT32F = 0x8CAC
DEPTH32F_STENCIL8 = 0x8CAD
FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD
FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210
FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211
FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212
FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213
FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214
FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215
FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216
FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217
FRAMEBUFFER_DEFAULT = 0x8218
FRAMEBUFFER_UNDEFINED = 0x8219
DEPTH_STENCIL_ATTACHMENT = 0x821A
DEPTH_STENCIL = 0x84F9
UNSIGNED_INT_24_8 = 0x84FA
DEPTH24_STENCIL8 = 0x88F0
UNSIGNED_NORMALIZED = 0x8C17
DRAW_FRAMEBUFFER_BINDING = 0x8CA6
READ_FRAMEBUFFER = 0x8CA8
DRAW_FRAMEBUFFER = 0x8CA9
READ_FRAMEBUFFER_BINDING = 0x8CAA
RENDERBUFFER_SAMPLES = 0x8CAB
FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4
MAX_COLOR_ATTACHMENTS = 0x8CDF
COLOR_ATTACHMENT1 = 0x8CE1
COLOR_ATTACHMENT2 = 0x8CE2
COLOR_ATTACHMENT3 = 0x8CE3
COLOR_ATTACHMENT4 = 0x8CE4
COLOR_ATTACHMENT5 = 0x8CE5
COLOR_ATTACHMENT6 = 0x8CE6
COLOR_ATTACHMENT7 = 0x8CE7
COLOR_ATTACHMENT8 = 0x8CE8
COLOR_ATTACHMENT9 = 0x8CE9
COLOR_ATTACHMENT10 = 0x8CEA
COLOR_ATTACHMENT11 = 0x8CEB
COLOR_ATTACHMENT12 = 0x8CEC
COLOR_ATTACHMENT13 = 0x8CED
COLOR_ATTACHMENT14 = 0x8CEE
COLOR_ATTACHMENT15 = 0x8CEF
COLOR_ATTACHMENT16 = 0x8CF0
COLOR_ATTACHMENT17 = 0x8CF1
COLOR_ATTACHMENT18 = 0x8CF2
COLOR_ATTACHMENT19 = 0x8CF3
COLOR_ATTACHMENT20 = 0x8CF4
COLOR_ATTACHMENT21 = 0x8CF5
COLOR_ATTACHMENT22 = 0x8CF6
COLOR_ATTACHMENT23 = 0x8CF7
COLOR_ATTACHMENT24 = 0x8CF8
COLOR_ATTACHMENT25 = 0x8CF9
COLOR_ATTACHMENT26 = 0x8CFA
COLOR_ATTACHMENT27 = 0x8CFB
COLOR_ATTACHMENT28 = 0x8CFC
COLOR_ATTACHMENT29 = 0x8CFD
COLOR_ATTACHMENT30 = 0x8CFE
COLOR_ATTACHMENT31 = 0x8CFF
FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56
MAX_SAMPLES = 0x8D57
HALF_FLOAT = 0x140B
MAP_READ_BIT = 0x0001
MAP_WRITE_BIT = 0x0002
MAP_INVALIDATE_RANGE_BIT = 0x0004
MAP_INVALIDATE_BUFFER_BIT = 0x0008
MAP_FLUSH_EXPLICIT_BIT = 0x0010
MAP_UNSYNCHRONIZED_BIT = 0x0020
RG = 0x8227
RG_INTEGER = 0x8228
R8 = 0x8229
RG8 = 0x822B
R16F = 0x822D
R32F = 0x822E
RG16F = 0x822F
RG32F = 0x8230
R8I = 0x8231
R8UI = 0x8232
R16I = 0x8233
R16UI = 0x8234
R32I = 0x8235
R32UI = 0x8236
RG8I = 0x8237
RG8UI = 0x8238
RG16I = 0x8239
RG16UI = 0x823A
RG32I = 0x823B
RG32UI = 0x823C
VERTEX_ARRAY_BINDING = 0x85B5
R8_SNORM = 0x8F94
RG8_SNORM = 0x8F95
RGB8_SNORM = 0x8F96
RGBA8_SNORM = 0x8F97
SIGNED_NORMALIZED = 0x8F9C
PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69
COPY_READ_BUFFER = 0x8F36
COPY_WRITE_BUFFER = 0x8F37
COPY_READ_BUFFER_BINDING = 0x8F36
COPY_WRITE_BUFFER_BINDING = 0x8F37
UNIFORM_BUFFER = 0x8A11
UNIFORM_BUFFER_BINDING = 0x8A28
UNIFORM_BUFFER_START = 0x8A29
UNIFORM_BUFFER_SIZE = 0x8A2A
MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B
MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D
MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E
MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F
MAX_UNIFORM_BLOCK_SIZE = 0x8A30
MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31
MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33
UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34
ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35
ACTIVE_UNIFORM_BLOCKS = 0x8A36
UNIFORM_TYPE = 0x8A37
UNIFORM_SIZE = 0x8A38
UNIFORM_NAME_LENGTH = 0x8A39
UNIFORM_BLOCK_INDEX = 0x8A3A
UNIFORM_OFFSET = 0x8A3B
UNIFORM_ARRAY_STRIDE = 0x8A3C
UNIFORM_MATRIX_STRIDE = 0x8A3D
UNIFORM_IS_ROW_MAJOR = 0x8A3E
UNIFORM_BLOCK_BINDING = 0x8A3F
UNIFORM_BLOCK_DATA_SIZE = 0x8A40
UNIFORM_BLOCK_NAME_LENGTH = 0x8A41
UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42
UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43
UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44
UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46
INVALID_INDEX = 0xFFFFFFFF
MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122
MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125
MAX_SERVER_WAIT_TIMEOUT = 0x9111
OBJECT_TYPE = 0x9112
SYNC_CONDITION = 0x9113
SYNC_STATUS = 0x9114
SYNC_FLAGS = 0x9115
SYNC_FENCE = 0x9116
SYNC_GPU_COMMANDS_COMPLETE = 0x9117
UNSIGNALED = 0x9118
SIGNALED = 0x9119
ALREADY_SIGNALED = 0x911A
TIMEOUT_EXPIRED = 0x911B
CONDITION_SATISFIED = 0x911C
WAIT_FAILED = 0x911D
SYNC_FLUSH_COMMANDS_BIT = 0x00000001
TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF
VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE
ANY_SAMPLES_PASSED = 0x8C2F
ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A
SAMPLER_BINDING = 0x8919
RGB10_A2UI = 0x906F
TEXTURE_SWIZZLE_R = 0x8E42
TEXTURE_SWIZZLE_G = 0x8E43
TEXTURE_SWIZZLE_B = 0x8E44
TEXTURE_SWIZZLE_A = 0x8E45
GREEN = 0x1904
BLUE = 0x1905
INT_2_10_10_10_REV = 0x8D9F
TRANSFORM_FEEDBACK = 0x8E22
TRANSFORM_FEEDBACK_PAUSED = 0x8E23
TRANSFORM_FEEDBACK_ACTIVE = 0x8E24
TRANSFORM_FEEDBACK_BINDING = 0x8E25
PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257
PROGRAM_BINARY_LENGTH = 0x8741
NUM_PROGRAM_BINARY_FORMATS = 0x87FE
PROGRAM_BINARY_FORMATS = 0x87FF
COMPRESSED_R11_EAC = 0x9270
COMPRESSED_SIGNED_R11_EAC = 0x9271
COMPRESSED_RG11_EAC = 0x9272
COMPRESSED_SIGNED_RG11_EAC = 0x9273
COMPRESSED_RGB8_ETC2 = 0x9274
COMPRESSED_SRGB8_ETC2 = 0x9275
COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276
COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277
COMPRESSED_RGBA8_ETC2_EAC = 0x9278
COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279
TEXTURE_IMMUTABLE_FORMAT = 0x912F
MAX_ELEMENT_INDEX = 0x8D6B
NUM_SAMPLE_COUNTS = 0x9380
TEXTURE_IMMUTABLE_LEVELS = 0x82DF