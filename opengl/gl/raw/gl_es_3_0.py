#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def read_buffer(src):
    '''
    select a color buffer source for pixels
    
    Args:
        src: Specifies a color buffer
    '''

@accepts(t.enum, t.uint, t.uint, t.sizei, t.enum, t.void)
@returns(t.void)
@binds(dll)
def draw_range_elements(mode, start, end, count, type, indices):
    '''
    render primitives from array data
    
    Args:
        mode: Specifies what kind of primitives to render
        start: Specifies the minimum array index contained in indices
        end: Specifies the maximum array index contained in indices
        count: Specifies the number of elements to be rendered
        type: Specifies the type of the values in indices
        indices: Specifies a pointer to the location where the indices are
            stored
    '''

@accepts(t.enum, t.int, t.int, t.sizei, t.sizei, t.sizei, t.int, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def tex_image3_d(target, level, internalformat, width, height, depth, border, format, type, pixels):
    '''
    specify a three-dimensional texture image
    
    Args:
        target: Specifies the target texture
        level: Specifies the level-of-detail number
        internalformat: Specifies the number of color components in the texture
        width: Specifies the width of the texture image
        height: Specifies the height of the texture image
        depth: Specifies the depth of the texture image, or the number of layers
            in a texture array
        border: This value must be 0
        format: Specifies the format of the pixel data
        type: Specifies the data type of the pixel data
        pixels: Specifies a pointer to the image data in memory
    '''

@accepts(t.enum, t.int, t.int, t.int, t.int, t.sizei, t.sizei, t.sizei, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def tex_sub_image3_d(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels):
    '''
    specify a three-dimensional texture subimage
    
    Args:
        target: Specifies the target to which the texture is bound for
            gl.tex_sub_image3D
        level: Specifies the level-of-detail number
        xoffset: Specifies a texel offset in the x direction within the texture
            array
        yoffset: Specifies a texel offset in the y direction within the texture
            array
        zoffset: Specifies a texel offset in the z direction within the texture
            array
        width: Specifies the width of the texture subimage
        height: Specifies the height of the texture subimage
        depth: Specifies the depth of the texture subimage
        format: Specifies the format of the pixel data
        type: Specifies the data type of the pixel data
        pixels: Specifies a pointer to the image data in memory
    '''

@accepts(t.enum, t.int, t.int, t.int, t.int, t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def copy_tex_sub_image3_d(target, level, xoffset, yoffset, zoffset, x, y, width, height):
    '''
    copy a three-dimensional texture subimage
    
    Args:
        target: Specifies the target to which the texture object is bound for
            gl.copy_tex_sub_image3D function
        level: Specifies the level-of-detail number
        xoffset: Specifies a texel offset in the x direction within the texture
            array
        yoffset: Specifies a texel offset in the y direction within the texture
            array
        zoffset: Specifies a texel offset in the z direction within the texture
            array
        x: Specify the window coordinates of the lower left corner of the
            rectangular region of pixels to be copied
        y: Specify the window coordinates of the lower left corner of the
            rectangular region of pixels to be copied
        width: Specifies the width of the texture subimage
        height: Specifies the height of the texture subimage
    '''

@accepts(t.enum, t.int, t.enum, t.sizei, t.sizei, t.sizei, t.int, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def compressed_tex_image3_d(target, level, internalformat, width, height, depth, border, imagesize, data):
    '''
    specify a three-dimensional texture image in a compressed format
    
    Args:
        target: Specifies the target texture
        level: Specifies the level-of-detail number
        internalformat: Specifies the format of the compressed image data stored
            at address data
        width: Specifies the width of the texture image
        height: Specifies the height of the texture image
        depth: Specifies the depth of the texture image
        border: This value must be 0
        imagesize: Specifies the number of unsigned bytes of image data starting
            at the address specified by data
        data: Specifies a pointer to the compressed image data in memory
    '''

@accepts(t.enum, t.int, t.int, t.int, t.int, t.sizei, t.sizei, t.sizei, t.enum, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def compressed_tex_sub_image3_d(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imagesize, data):
    '''
    specify a three-dimensional texture subimage in a compressed format
    
    Args:
        target: Specifies the target to which the texture is bound for
            gl.compressed_tex_sub_image3D function
        level: Specifies the level-of-detail number
        xoffset: Specifies a texel offset in the x direction within the texture
            array
        yoffset: Specifies a texel offset in the y direction within the texture
            array
        width: Specifies the width of the texture subimage
        height: Specifies the height of the texture subimage
        depth: Specifies the depth of the texture subimage
        format: Specifies the format of the compressed image data stored at
            address data
        imagesize: Specifies the number of unsigned bytes of image data starting
            at the address specified by data
        data: Specifies a pointer to the compressed image data in memory
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_queries(n, ids):
    '''
    generate query object names
    
    Args:
        n: Specifies the number of query object names to be generated
        ids: Specifies an array in which the generated query object names are
            stored
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_queries(n, ids):
    '''
    delete named query objects
    
    Args:
        n: Specifies the number of query objects to be deleted
        ids: Specifies an array of query objects to be deleted
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_query(id):
    '''
    determine if a name corresponds to a query object
    
    Args:
        id: Specifies a value that may be the name of a query object
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def begin_query(target, id):
    '''
    delimit the boundaries of a query object
    
    Args:
        target: Specifies the target type of query object established between
            gl.begin_query and the subsequent gl.end_query
        id: Specifies the name of a query object
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def end_query(target):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_queryiv(target, pname, params):
    '''
    return parameters of a query object target
    
    Args:
        target: Specifies a query object target
        pname: Specifies the symbolic name of a query object target parameter
        params: Returns the requested data
    '''

@accepts(t.uint, t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_query_objectuiv(id, pname, params):
    pass

@accepts(t.enum)
@returns(t.boolean)
@binds(dll)
def unmap_buffer(target):
    '''
    release the mapping of a buffer object's data store into the client's address
space
    
    Args:
        target: Specifies the target to which the buffer object is bound for
            gl.unmap_buffer, which must be one of the buffer binding targets in
            the following table:
    '''

@accepts(t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def get_buffer_pointerv(target, pname, params):
    '''
    return the pointer to a mapped buffer object's data store
    
    Args:
        target: Specifies the target to which the buffer object is bound for
            gl.get_buffer_pointerv, which must be one of the buffer binding
            targets in the following table:
        pname: Specifies the name of the pointer to be returned
        params: Returns the pointer value specified by pname
    '''

@accepts(t.sizei, POINTER(t.enum))
@returns(t.void)
@binds(dll)
def draw_buffers(n, bufs):
    '''
    Specifies a list of color buffers to be drawn into
    
    Args:
        n: Specifies the number of buffers in bufs
        bufs: Points to an array of symbolic constants specifying the buffers
            into which fragment colors or data values will be written
    '''

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix2x3fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix3x2fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix2x4fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix4x2fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix3x4fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix4x3fv(location, count, transpose, value):
    pass

@accepts(t.int, t.int, t.int, t.int, t.int, t.int, t.int, t.int, t.bitfield, t.enum)
@returns(t.void)
@binds(dll)
def blit_framebuffer(srcx0, srcy0, srcx1, srcy1, dstx0, dsty0, dstx1, dsty1, mask, filter):
    '''
    copy a block of pixels from one framebuffer object to another
    
    Args:
        srcx0: Specify the bounds of the source rectangle within the read buffer
            of the read framebuffer
        srcy0: Specify the bounds of the source rectangle within the read buffer
            of the read framebuffer
        srcx1: Specify the bounds of the source rectangle within the read buffer
            of the read framebuffer
        srcy1: Specify the bounds of the source rectangle within the read buffer
            of the read framebuffer
        dstx0: Specify the bounds of the destination rectangle within the write
            buffer of the write framebuffer
        dsty0: Specify the bounds of the destination rectangle within the write
            buffer of the write framebuffer
        dstx1: Specify the bounds of the destination rectangle within the write
            buffer of the write framebuffer
        dsty1: Specify the bounds of the destination rectangle within the write
            buffer of the write framebuffer
        mask: The bitwise OR of the flags indicating which buffers are to be
            copied
        filter: Specifies the interpolation to be applied if the image is
            stretched
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def renderbuffer_storage_multisample(target, samples, internalformat, width, height):
    '''
    establish data storage, format, dimensions and sample count of a renderbuffer
object's image
    
    Args:
        target: Specifies a binding target of the allocation for
            gl.renderbuffer_storage_multisample function
        samples: Specifies the number of samples to be used for the renderbuffer
            object's storage
        internalformat: Specifies the internal format to use for the
            renderbuffer object's image
        width: Specifies the width of the renderbuffer, in pixels
        height: Specifies the height of the renderbuffer, in pixels
    '''

@accepts(t.enum, t.enum, t.uint, t.int, t.int)
@returns(t.void)
@binds(dll)
def framebuffer_texture_layer(target, attachment, texture, level, layer):
    '''
    attach a single layer of a texture object as a logical buffer of a framebuffer
object
    
    Args:
        target: Specifies the target to which the framebuffer is bound for
            gl.framebuffer_texture_layer
        attachment: Specifies the attachment point of the framebuffer
        texture: Specifies the name of an existing texture object to attach
        level: Specifies the mipmap level of the texture object to attach
        layer: Specifies the layer of the texture object to attach
    '''

@accepts(t.enum, t.intptr, t.sizeiptr, t.bitfield)
@returns(t.void)
@binds(dll)
def map_buffer_range(target, offset, length, access):
    '''
    map all or part of a buffer object's data store into the client's address space
    
    Args:
        target: Specifies the target to which the buffer object is bound for
            gl.map_buffer_range, which must be one of the buffer binding targets
            in the following table:
        offset: Specifies the starting offset within the buffer of the range to
            be mapped
        length: Specifies the length of the range to be mapped
        access: Specifies a combination of access flags indicating the desired
            access to the mapped range
    '''

@accepts(t.enum, t.intptr, t.sizeiptr)
@returns(t.void)
@binds(dll)
def flush_mapped_buffer_range(target, offset, length):
    '''
    indicate modifications to a range of a mapped buffer
    
    Args:
        target: Specifies the target to which the buffer object is bound for
            gl.flush_mapped_buffer_range, which must be one of the buffer
            binding targets in the following table:
        offset: Specifies the start of the buffer subrange, in basic machine
            units
        length: Specifies the length of the buffer subrange, in basic machine
            units
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def bind_vertex_array(array):
    '''
    bind a vertex array object
    
    Args:
        array: Specifies the name of the vertex array to bind
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_vertex_arrays(n, arrays):
    '''
    delete vertex array objects
    
    Args:
        n: Specifies the number of vertex array objects to be deleted
        arrays: Specifies the address of an array containing the n names of the
            objects to be deleted
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_vertex_arrays(n, arrays):
    '''
    generate vertex array object names
    
    Args:
        n: Specifies the number of vertex array object names to generate
        arrays: Specifies an array in which the generated vertex array object
            names are stored
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_vertex_array(array):
    '''
    determine if a name corresponds to a vertex array object
    
    Args:
        array: Specifies a value that may be the name of a vertex array object
    '''

@accepts(t.enum, t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_integeri_v(target, index, data):
    pass

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def begin_transform_feedback(primitivemode):
    '''
    start transform feedback operation
    
    Args:
        primitivemode: Specify the output type of the primitives that will be
            recorded into the buffer objects that are bound for transform
            feedback
    '''

@accepts()
@returns(t.void)
@binds(dll)
def end_transform_feedback():
    pass

@accepts(t.enum, t.uint, t.uint, t.intptr, t.sizeiptr)
@returns(t.void)
@binds(dll)
def bind_buffer_range(target, index, buffer, offset, size):
    '''
    bind a range within a buffer object to an indexed buffer target
    
    Args:
        target: Specify the target of the bind operation
        index: Specify the index of the binding point within the array specified
            by target
        buffer: The name of a buffer object to bind to the specified binding
            point
        offset: The starting offset in basic machine units into the buffer
            object buffer
        size: The amount of data in machine units that can be read from the
            buffer object while used as an indexed target
    '''

@accepts(t.enum, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def bind_buffer_base(target, index, buffer):
    '''
    bind a buffer object to an indexed buffer target
    
    Args:
        target: Specify the target of the bind operation
        index: Specify the index of the binding point within the array specified
            by target
        buffer: The name of a buffer object to bind to the specified binding
            point
    '''

@accepts(t.uint, t.sizei, POINTER(t.char_p), t.enum)
@returns(t.void)
@binds(dll)
def transform_feedback_varyings(program, count, varyings, buffermode):
    '''
    specify values to record in transform feedback buffers
    
    Args:
        program: The name of the target program object
        count: The number of varying variables used for transform feedback
        varyings: An array of count zero-terminated strings specifying the names
            of the varying variables to use for transform feedback
        buffermode: Identifies the mode used to capture the varying variables
            when transform feedback is active
    '''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.sizei), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_transform_feedback_varying(program, index, bufsize, length, size, type, name):
    '''
    retrieve information about varying variables selected for transform feedback
    
    Args:
        program: The name of the target program object
        index: The index of the varying variable whose information to retrieve
        bufsize: The maximum number of characters, including the null
            terminator, that may be written into name
        length: The address of a variable which will receive the number of
            characters written into name, excluding the null-terminator
        size: The address of a variable that will receive the size of the
            varying
        type: The address of a variable that will recieve the type of the
            varying
        name: The address of a buffer into which will be written the name of the
            varying
    '''

@accepts(t.uint, t.int, t.enum, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def vertex_attrib_i_pointer(index, size, type, stride, pointer):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_vertex_attrib_iiv(index, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_vertex_attrib_iuiv(index, pname, params):
    pass

@accepts(t.uint, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def vertex_attrib_i4i(index, x, y, z, w):
    pass

@accepts(t.uint, t.uint, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def vertex_attrib_i4ui(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex_attrib_i4iv(index, v):
    pass

@accepts(t.uint, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def vertex_attrib_i4uiv(index, v):
    pass

@accepts(t.uint, t.int, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_uniformuiv(program, location, params):
    pass

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_frag_data_location(program, name):
    '''
    query the bindings of color numbers to user-defined varying out variables
    
    Args:
        program: The name of the program containing varying out variable whose
            binding to query
        name: The name of the user-defined varying out variable whose binding to
            query
    '''

@accepts(t.int, t.uint)
@returns(t.void)
@binds(dll)
def uniform1ui(location, v0):
    pass

@accepts(t.int, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def uniform2ui(location, v0, v1):
    pass

@accepts(t.int, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def uniform3ui(location, v0, v1, v2):
    pass

@accepts(t.int, t.uint, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def uniform4ui(location, v0, v1, v2, v3):
    pass

@accepts(t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform1uiv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform2uiv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform3uiv(location, count, value):
    pass

@accepts(t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def uniform4uiv(location, count, value):
    pass

@accepts(t.enum, t.int, POINTER(t.int))
@returns(t.void)
@binds(dll)
def clear_bufferiv(buffer, drawbuffer, value):
    pass

@accepts(t.enum, t.int, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def clear_bufferuiv(buffer, drawbuffer, value):
    pass

@accepts(t.enum, t.int, POINTER(t.float))
@returns(t.void)
@binds(dll)
def clear_bufferfv(buffer, drawbuffer, value):
    pass

@accepts(t.enum, t.int, t.float, t.int)
@returns(t.void)
@binds(dll)
def clear_bufferfi(buffer, drawbuffer, depth, stencil):
    pass

@accepts(t.enum, t.uint)
@returns(POINTER(t.ubyte))
@binds(dll)
def get_stringi(name, index):
    pass

@accepts(t.enum, t.enum, t.intptr, t.intptr, t.sizeiptr)
@returns(t.void)
@binds(dll)
def copy_buffer_sub_data(readtarget, writetarget, readoffset, writeoffset, size):
    '''
    copy all or part of the data store of a buffer object to the data store of
another buffer object
    
    Args:
        readtarget: Specifies the target to which the source buffer object is
            bound for gl.copy_buffer_sub_data
        writetarget: Specifies the target to which the destination buffer object
            is bound for gl.copy_buffer_sub_data
        readoffset: Specifies the offset, in basic machine units, within the
            data store of the source buffer object at which data will be read
        writeoffset: Specifies the offset, in basic machine units, within the
            data store of the destination buffer object at which data will be
            written
        size: Specifies the size, in basic machine units, of the data to be
            copied from the source buffer object to the destination buffer
            object
    '''

@accepts(t.uint, t.sizei, POINTER(t.char_p), POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_uniform_indices(program, uniformcount, uniformnames, uniformindices):
    '''
    retrieve the index of a named uniform block
    
    Args:
        program: Specifies the name of a program containing uniforms whose
            indices to query
        uniformcount: Specifies the number of uniforms whose indices to query
        uniformnames: Specifies the address of an array of pointers to buffers
            containing the names of the queried uniforms
        uniformindices: Specifies the address of an array that will receive the
            indices of the uniforms
    '''

@accepts(t.uint, t.sizei, POINTER(t.uint), t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_active_uniformsiv(program, uniformcount, uniformindices, pname, params):
    '''
    Returns information about several active uniform variables for the specified
program object
    
    Args:
        program: Specifies the program object to be queried
        uniformcount: Specifies both the number of elements in the array of
            indices uniformIndices and the number of parameters written to
            params upon successful return
        uniformindices: Specifies the address of an array of uniformCount
            integers containing the indices of uniforms within program whose
            parameter pname should be queried
        pname: Specifies the property of each uniform in uniformIndices that
            should be written into the corresponding element of params
        params: Specifies the address of an array of uniformCount integers which
            are to receive the value of pname for each uniform in uniformIndices
    '''

@accepts(t.uint, t.char_p)
@returns(t.uint)
@binds(dll)
def get_uniform_block_index(program, uniformblockname):
    '''
    retrieve the index of a named uniform block
    
    Args:
        program: Specifies the name of a program containing the uniform block
        uniformblockname: Specifies the address an array of characters to
            containing the name of the uniform block whose index to retrieve
    '''

@accepts(t.uint, t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_active_uniform_blockiv(program, uniformblockindex, pname, params):
    pass

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_uniform_block_name(program, uniformblockindex, bufsize, length, uniformblockname):
    '''
    retrieve the name of an active uniform block
    
    Args:
        program: Specifies the name of a program containing the uniform block
        uniformblockindex: Specifies the index of the uniform block within
            program
        bufsize: Specifies the size of the buffer addressed by uniformBlockName
        length: Specifies the address of a variable to receive the number of
            characters that were written to uniformBlockName
        uniformblockname: Specifies the address an array of characters to
            receive the name of the uniform block at uniformBlockIndex
    '''

@accepts(t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def uniform_block_binding(program, uniformblockindex, uniformblockbinding):
    '''
    assign a binding point to an active uniform block
    
    Args:
        program: The name of a program object containing the active uniform
            block whose binding to assign
        uniformblockindex: The index of the active uniform block within program
            whose binding to assign
        uniformblockbinding: Specifies the binding point to which to bind the
            uniform block with index uniformBlockIndex within program
    '''

@accepts(t.enum, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def draw_arrays_instanced(mode, first, count, instancecount):
    '''
    draw multiple instances of a range of elements
    
    Args:
        mode: Specifies what kind of primitives to render
        first: Specifies the starting index in the enabled arrays
        count: Specifies the number of indices to be rendered
        instancecount: Specifies the number of instances of the specified range
            of indices to be rendered
    '''

@accepts(t.enum, t.sizei, t.enum, t.void, t.sizei)
@returns(t.void)
@binds(dll)
def draw_elements_instanced(mode, count, type, indices, instancecount):
    '''
    draw multiple instances of a set of elements
    
    Args:
        mode: Specifies what kind of primitives to render
        count: Specifies the number of elements to be rendered
        type: Specifies the type of the values in indices
        indices: Specifies a pointer to the location where the indices are
            stored
        instancecount: Specifies the number of instances of the specified range
            of indices to be rendered
    '''

@accepts(t.enum, t.bitfield)
@returns(t.sync)
@binds(dll)
def fence_sync(condition, flags):
    '''
    create a new sync object and insert it into the GL command stream
    
    Args:
        condition: Specifies the condition that must be met to set the sync
            object's state to signaled
        flags: Specifies a bitwise combination of flags controlling the behavior
            of the sync object
    '''

@accepts(t.sync)
@returns(t.boolean)
@binds(dll)
def is_sync(sync):
    '''
    determine if a name corresponds to a sync object
    
    Args:
        sync: Specifies a value that may be the name of a sync object
    '''

@accepts(t.sync)
@returns(t.void)
@binds(dll)
def delete_sync(sync):
    '''
    delete a sync object
    
    Args:
        sync: The sync object to be deleted
    '''

@accepts(t.sync, t.bitfield, t.uint64)
@returns(t.enum)
@binds(dll)
def client_wait_sync(sync, flags, timeout):
    '''
    block and wait for a sync object to become signaled
    
    Args:
        sync: The sync object whose status to wait on
        flags: A bitfield controlling the command flushing behavior
        timeout: The timeout, specified in nanoseconds, for which the
            implementation should wait for sync to become signaled
    '''

@accepts(t.sync, t.bitfield, t.uint64)
@returns(t.void)
@binds(dll)
def wait_sync(sync, flags, timeout):
    '''
    instruct the GL server to block until the specified sync object becomes signaled
    
    Args:
        sync: Specifies the sync object whose status to wait on
        flags: A bitfield controlling the command flushing behavior
        timeout: Specifies the timeout that the server should wait before
            continuing
    '''

@accepts(t.enum, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_integer64v(pname, data):
    pass

@accepts(t.sync, t.enum, t.sizei, POINTER(t.sizei), POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_synciv(sync, pname, bufsize, length, values):
    pass

@accepts(t.enum, t.uint, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_integer64i_v(target, index, data):
    pass

@accepts(t.enum, t.enum, POINTER(t.int64))
@returns(t.void)
@binds(dll)
def get_buffer_parameteri64v(target, pname, params):
    pass

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_samplers(count, samplers):
    '''
    generate sampler object names
    
    Args:
        count: Specifies the number of sampler object names to generate
        samplers: Specifies an array in which the generated sampler object names
            are stored
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_samplers(count, samplers):
    '''
    delete named sampler objects
    
    Args:
        count: Specifies the number of sampler objects to be deleted
        samplers: Specifies an array of sampler objects to be deleted
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_sampler(sampler):
    '''
    determine if a name corresponds to a sampler object
    
    Args:
        sampler: Specifies a value that may be the name of a sampler object
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def bind_sampler(unit, sampler):
    '''
    bind a named sampler to a texturing target
    
    Args:
        unit: Specifies the index of the texture unit to which the sampler is
            bound
        sampler: Specifies the name of a sampler
    '''

@accepts(t.uint, t.enum, t.int)
@returns(t.void)
@binds(dll)
def sampler_parameteri(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def sampler_parameteriv(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, t.float)
@returns(t.void)
@binds(dll)
def sampler_parameterf(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def sampler_parameterfv(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_sampler_parameteriv(sampler, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_sampler_parameterfv(sampler, pname, params):
    pass

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def vertex_attrib_divisor(index, divisor):
    '''
    modify the rate at which generic vertex attributes advance during instanced
rendering
    
    Args:
        index: Specify the index of the generic vertex attribute
        divisor: Specify the number of instances that will pass between updates
            of the generic attribute at slot index
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def bind_transform_feedback(target, id):
    '''
    bind a transform feedback object
    
    Args:
        target: Specifies the target to which to bind the transform feedback
            object id
        id: Specifies the name of a transform feedback object reserved by
            gl.gen_transform_feedbacks
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_transform_feedbacks(n, ids):
    '''
    delete transform feedback objects
    
    Args:
        n: Specifies the number of transform feedback objects to delete
        ids: Specifies an array of names of transform feedback objects to delete
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_transform_feedbacks(n, ids):
    '''
    reserve transform feedback object names
    
    Args:
        n: Specifies the number of transform feedback object names to reserve
        ids: Specifies an array of into which the reserved names will be written
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_transform_feedback(id):
    '''
    determine if a name corresponds to a transform feedback object
    
    Args:
        id: Specifies a value that may be the name of a transform feedback
            object
    '''

@accepts()
@returns(t.void)
@binds(dll)
def pause_transform_feedback():
    '''
    pause transform feedback operations
    '''

@accepts()
@returns(t.void)
@binds(dll)
def resume_transform_feedback():
    '''
    resume transform feedback operations
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), POINTER(t.enum), t.void)
@returns(t.void)
@binds(dll)
def get_program_binary(program, bufsize, length, binaryformat, binary):
    '''
    return a binary representation of a program object's compiled and linked
executable source
    
    Args:
        program: Specifies the name of a program object whose binary
            representation to retrieve
        length: Specifies the address of a variable to receive the number of
            bytes written into binary
        binaryformat: Specifies the address of a variable to receive a token
            indicating the format of the binary data returned by the GL
        binary: Specifies the address an array into which the GL will return
            program's binary representation
    '''

@accepts(t.uint, t.enum, t.void, t.sizei)
@returns(t.void)
@binds(dll)
def program_binary(program, binaryformat, binary, length):
    '''
    load a program object with a program binary
    
    Args:
        program: Specifies the name of a program object into which to load a
            program binary
        binaryformat: Specifies the format of the binary data in binary
        binary: Specifies the address an array containing the binary to be
            loaded into program
        length: Specifies the number of bytes contained in binary
    '''

@accepts(t.uint, t.enum, t.int)
@returns(t.void)
@binds(dll)
def program_parameteri(program, pname, value):
    pass

@accepts(t.enum, t.sizei, POINTER(t.enum))
@returns(t.void)
@binds(dll)
def invalidate_framebuffer(target, numattachments, attachments):
    '''
    invalidate the content of some or all of a framebuffer's attachments
    
    Args:
        target: Specifies the target to which the framebuffer object is attached
            for gl.invalidate_framebuffer
        numattachments: Specifies the number of entries in the attachments array
        attachments: Specifies a pointer to an array identifying the attachments
            to be invalidated
    '''

@accepts(t.enum, t.sizei, POINTER(t.enum), t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def invalidate_sub_framebuffer(target, numattachments, attachments, x, y, width, height):
    '''
    invalidate the content of a region of some or all of a framebuffer's attachments
    
    Args:
        target: Specifies the target to which the framebuffer object is attached
            for gl.invalidate_sub_framebuffer
        numattachments: Specifies the number of entries in the attachments array
        attachments: Specifies a pointer to an array identifying the attachments
            to be invalidated
        x: Specifies the X offset of the region to be invalidated
        y: Specifies the Y offset of the region to be invalidated
        width: Specifies the width of the region to be invalidated
        height: Specifies the height of the region to be invalidated
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def tex_storage2_d(target, levels, internalformat, width, height):
    '''
    simultaneously specify storage for all levels of a two-dimensional or one-
dimensional array texture
    
    Args:
        target: Specifies the target to which the texture object is bound for
            gl.tex_storage2D
        levels: Specify the number of texture levels
        internalformat: Specifies the sized internal format to be used to store
            texture image data
        width: Specifies the width of the texture, in texels
        height: Specifies the height of the texture, in texels
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def tex_storage3_d(target, levels, internalformat, width, height, depth):
    '''
    simultaneously specify storage for all levels of a three-dimensional, two-
dimensional array or cube-map array texture
    
    Args:
        target: Specifies the target to which the texture object is bound for
            gl.tex_storage3D
        levels: Specify the number of texture levels
        internalformat: Specifies the sized internal format to be used to store
            texture image data
        width: Specifies the width of the texture, in texels
        height: Specifies the height of the texture, in texels
        depth: Specifies the depth of the texture, in texels
    '''

@accepts(t.enum, t.enum, t.enum, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_internalformativ(target, internalformat, pname, bufsize, params):
    pass

READ_BUFFER = 0x0C02
UNPACK_ROW_LENGTH = 0x0CF2
UNPACK_SKIP_ROWS = 0x0CF3
UNPACK_SKIP_PIXELS = 0x0CF4
PACK_ROW_LENGTH = 0x0D02
PACK_SKIP_ROWS = 0x0D03
PACK_SKIP_PIXELS = 0x0D04
COLOR = 0x1800
DEPTH = 0x1801
STENCIL = 0x1802
RED = 0x1903
RGB8 = 0x8051
RGBA8 = 0x8058
RGB10_A2 = 0x8059
TEXTURE_BINDING_3D = 0x806A
UNPACK_SKIP_IMAGES = 0x806D
UNPACK_IMAGE_HEIGHT = 0x806E
TEXTURE_3D = 0x806F
TEXTURE_WRAP_R = 0x8072
MAX_3D_TEXTURE_SIZE = 0x8073
UNSIGNED_INT_2_10_10_10_REV = 0x8368
MAX_ELEMENTS_VERTICES = 0x80E8
MAX_ELEMENTS_INDICES = 0x80E9
TEXTURE_MIN_LOD = 0x813A
TEXTURE_MAX_LOD = 0x813B
TEXTURE_BASE_LEVEL = 0x813C
TEXTURE_MAX_LEVEL = 0x813D
MIN = 0x8007
MAX = 0x8008
DEPTH_COMPONENT24 = 0x81A6
MAX_TEXTURE_LOD_BIAS = 0x84FD
TEXTURE_COMPARE_MODE = 0x884C
TEXTURE_COMPARE_FUNC = 0x884D
CURRENT_QUERY = 0x8865
QUERY_RESULT = 0x8866
QUERY_RESULT_AVAILABLE = 0x8867
BUFFER_MAPPED = 0x88BC
BUFFER_MAP_POINTER = 0x88BD
STREAM_READ = 0x88E1
STREAM_COPY = 0x88E2
STATIC_READ = 0x88E5
STATIC_COPY = 0x88E6
DYNAMIC_READ = 0x88E9
DYNAMIC_COPY = 0x88EA
MAX_DRAW_BUFFERS = 0x8824
DRAW_BUFFER0 = 0x8825
DRAW_BUFFER1 = 0x8826
DRAW_BUFFER2 = 0x8827
DRAW_BUFFER3 = 0x8828
DRAW_BUFFER4 = 0x8829
DRAW_BUFFER5 = 0x882A
DRAW_BUFFER6 = 0x882B
DRAW_BUFFER7 = 0x882C
DRAW_BUFFER8 = 0x882D
DRAW_BUFFER9 = 0x882E
DRAW_BUFFER10 = 0x882F
DRAW_BUFFER11 = 0x8830
DRAW_BUFFER12 = 0x8831
DRAW_BUFFER13 = 0x8832
DRAW_BUFFER14 = 0x8833
DRAW_BUFFER15 = 0x8834
MAX_FRAGMENT_UNIFORM_COMPONENTS = 0x8B49
MAX_VERTEX_UNIFORM_COMPONENTS = 0x8B4A
SAMPLER_3D = 0x8B5F
SAMPLER_2D_SHADOW = 0x8B62
FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B
PIXEL_PACK_BUFFER = 0x88EB
PIXEL_UNPACK_BUFFER = 0x88EC
PIXEL_PACK_BUFFER_BINDING = 0x88ED
PIXEL_UNPACK_BUFFER_BINDING = 0x88EF
FLOAT_MAT2x3 = 0x8B65
FLOAT_MAT2x4 = 0x8B66
FLOAT_MAT3x2 = 0x8B67
FLOAT_MAT3x4 = 0x8B68
FLOAT_MAT4x2 = 0x8B69
FLOAT_MAT4x3 = 0x8B6A
SRGB = 0x8C40
SRGB8 = 0x8C41
SRGB8_ALPHA8 = 0x8C43
COMPARE_REF_TO_TEXTURE = 0x884E
MAJOR_VERSION = 0x821B
MINOR_VERSION = 0x821C
NUM_EXTENSIONS = 0x821D
RGBA32F = 0x8814
RGB32F = 0x8815
RGBA16F = 0x881A
RGB16F = 0x881B
VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD
MAX_ARRAY_TEXTURE_LAYERS = 0x88FF
MIN_PROGRAM_TEXEL_OFFSET = 0x8904
MAX_PROGRAM_TEXEL_OFFSET = 0x8905
MAX_VARYING_COMPONENTS = 0x8B4B
TEXTURE_2D_ARRAY = 0x8C1A
TEXTURE_BINDING_2D_ARRAY = 0x8C1D
R11F_G11F_B10F = 0x8C3A
UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B
RGB9_E5 = 0x8C3D
UNSIGNED_INT_5_9_9_9_REV = 0x8C3E
TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = 0x8C76
TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F
MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 0x8C80
TRANSFORM_FEEDBACK_VARYINGS = 0x8C83
TRANSFORM_FEEDBACK_BUFFER_START = 0x8C84
TRANSFORM_FEEDBACK_BUFFER_SIZE = 0x8C85
TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88
RASTERIZER_DISCARD = 0x8C89
MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 0x8C8A
MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 0x8C8B
INTERLEAVED_ATTRIBS = 0x8C8C
SEPARATE_ATTRIBS = 0x8C8D
TRANSFORM_FEEDBACK_BUFFER = 0x8C8E
TRANSFORM_FEEDBACK_BUFFER_BINDING = 0x8C8F
RGBA32UI = 0x8D70
RGB32UI = 0x8D71
RGBA16UI = 0x8D76
RGB16UI = 0x8D77
RGBA8UI = 0x8D7C
RGB8UI = 0x8D7D
RGBA32I = 0x8D82
RGB32I = 0x8D83
RGBA16I = 0x8D88
RGB16I = 0x8D89
RGBA8I = 0x8D8E
RGB8I = 0x8D8F
RED_INTEGER = 0x8D94
RGB_INTEGER = 0x8D98
RGBA_INTEGER = 0x8D99
SAMPLER_2D_ARRAY = 0x8DC1
SAMPLER_2D_ARRAY_SHADOW = 0x8DC4
SAMPLER_CUBE_SHADOW = 0x8DC5
UNSIGNED_INT_VEC2 = 0x8DC6
UNSIGNED_INT_VEC3 = 0x8DC7
UNSIGNED_INT_VEC4 = 0x8DC8
INT_SAMPLER_2D = 0x8DCA
INT_SAMPLER_3D = 0x8DCB
INT_SAMPLER_CUBE = 0x8DCC
INT_SAMPLER_2D_ARRAY = 0x8DCF
UNSIGNED_INT_SAMPLER_2D = 0x8DD2
UNSIGNED_INT_SAMPLER_3D = 0x8DD3
UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4
UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7
BUFFER_ACCESS_FLAGS = 0x911F
BUFFER_MAP_LENGTH = 0x9120
BUFFER_MAP_OFFSET = 0x9121
DEPTH_COMPONENT32F = 0x8CAC
DEPTH32F_STENCIL8 = 0x8CAD
FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD
FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210
FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211
FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212
FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213
FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214
FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215
FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216
FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217
FRAMEBUFFER_DEFAULT = 0x8218
FRAMEBUFFER_UNDEFINED = 0x8219
DEPTH_STENCIL_ATTACHMENT = 0x821A
DEPTH_STENCIL = 0x84F9
UNSIGNED_INT_24_8 = 0x84FA
DEPTH24_STENCIL8 = 0x88F0
UNSIGNED_NORMALIZED = 0x8C17
DRAW_FRAMEBUFFER_BINDING = 0x8CA6
READ_FRAMEBUFFER = 0x8CA8
DRAW_FRAMEBUFFER = 0x8CA9
READ_FRAMEBUFFER_BINDING = 0x8CAA
RENDERBUFFER_SAMPLES = 0x8CAB
FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4
MAX_COLOR_ATTACHMENTS = 0x8CDF
COLOR_ATTACHMENT1 = 0x8CE1
COLOR_ATTACHMENT2 = 0x8CE2
COLOR_ATTACHMENT3 = 0x8CE3
COLOR_ATTACHMENT4 = 0x8CE4
COLOR_ATTACHMENT5 = 0x8CE5
COLOR_ATTACHMENT6 = 0x8CE6
COLOR_ATTACHMENT7 = 0x8CE7
COLOR_ATTACHMENT8 = 0x8CE8
COLOR_ATTACHMENT9 = 0x8CE9
COLOR_ATTACHMENT10 = 0x8CEA
COLOR_ATTACHMENT11 = 0x8CEB
COLOR_ATTACHMENT12 = 0x8CEC
COLOR_ATTACHMENT13 = 0x8CED
COLOR_ATTACHMENT14 = 0x8CEE
COLOR_ATTACHMENT15 = 0x8CEF
COLOR_ATTACHMENT16 = 0x8CF0
COLOR_ATTACHMENT17 = 0x8CF1
COLOR_ATTACHMENT18 = 0x8CF2
COLOR_ATTACHMENT19 = 0x8CF3
COLOR_ATTACHMENT20 = 0x8CF4
COLOR_ATTACHMENT21 = 0x8CF5
COLOR_ATTACHMENT22 = 0x8CF6
COLOR_ATTACHMENT23 = 0x8CF7
COLOR_ATTACHMENT24 = 0x8CF8
COLOR_ATTACHMENT25 = 0x8CF9
COLOR_ATTACHMENT26 = 0x8CFA
COLOR_ATTACHMENT27 = 0x8CFB
COLOR_ATTACHMENT28 = 0x8CFC
COLOR_ATTACHMENT29 = 0x8CFD
COLOR_ATTACHMENT30 = 0x8CFE
COLOR_ATTACHMENT31 = 0x8CFF
FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56
MAX_SAMPLES = 0x8D57
HALF_FLOAT = 0x140B
MAP_READ_BIT = 0x0001
MAP_WRITE_BIT = 0x0002
MAP_INVALIDATE_RANGE_BIT = 0x0004
MAP_INVALIDATE_BUFFER_BIT = 0x0008
MAP_FLUSH_EXPLICIT_BIT = 0x0010
MAP_UNSYNCHRONIZED_BIT = 0x0020
RG = 0x8227
RG_INTEGER = 0x8228
R8 = 0x8229
RG8 = 0x822B
R16F = 0x822D
R32F = 0x822E
RG16F = 0x822F
RG32F = 0x8230
R8I = 0x8231
R8UI = 0x8232
R16I = 0x8233
R16UI = 0x8234
R32I = 0x8235
R32UI = 0x8236
RG8I = 0x8237
RG8UI = 0x8238
RG16I = 0x8239
RG16UI = 0x823A
RG32I = 0x823B
RG32UI = 0x823C
VERTEX_ARRAY_BINDING = 0x85B5
R8_SNORM = 0x8F94
RG8_SNORM = 0x8F95
RGB8_SNORM = 0x8F96
RGBA8_SNORM = 0x8F97
SIGNED_NORMALIZED = 0x8F9C
PRIMITIVE_RESTART_FIXED_INDEX = 0x8D69
COPY_READ_BUFFER = 0x8F36
COPY_WRITE_BUFFER = 0x8F37
COPY_READ_BUFFER_BINDING = 0x8F36
COPY_WRITE_BUFFER_BINDING = 0x8F37
UNIFORM_BUFFER = 0x8A11
UNIFORM_BUFFER_BINDING = 0x8A28
UNIFORM_BUFFER_START = 0x8A29
UNIFORM_BUFFER_SIZE = 0x8A2A
MAX_VERTEX_UNIFORM_BLOCKS = 0x8A2B
MAX_FRAGMENT_UNIFORM_BLOCKS = 0x8A2D
MAX_COMBINED_UNIFORM_BLOCKS = 0x8A2E
MAX_UNIFORM_BUFFER_BINDINGS = 0x8A2F
MAX_UNIFORM_BLOCK_SIZE = 0x8A30
MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31
MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33
UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34
ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35
ACTIVE_UNIFORM_BLOCKS = 0x8A36
UNIFORM_TYPE = 0x8A37
UNIFORM_SIZE = 0x8A38
UNIFORM_NAME_LENGTH = 0x8A39
UNIFORM_BLOCK_INDEX = 0x8A3A
UNIFORM_OFFSET = 0x8A3B
UNIFORM_ARRAY_STRIDE = 0x8A3C
UNIFORM_MATRIX_STRIDE = 0x8A3D
UNIFORM_IS_ROW_MAJOR = 0x8A3E
UNIFORM_BLOCK_BINDING = 0x8A3F
UNIFORM_BLOCK_DATA_SIZE = 0x8A40
UNIFORM_BLOCK_NAME_LENGTH = 0x8A41
UNIFORM_BLOCK_ACTIVE_UNIFORMS = 0x8A42
UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43
UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44
UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46
INVALID_INDEX = 0xFFFFFFFF
MAX_VERTEX_OUTPUT_COMPONENTS = 0x9122
MAX_FRAGMENT_INPUT_COMPONENTS = 0x9125
MAX_SERVER_WAIT_TIMEOUT = 0x9111
OBJECT_TYPE = 0x9112
SYNC_CONDITION = 0x9113
SYNC_STATUS = 0x9114
SYNC_FLAGS = 0x9115
SYNC_FENCE = 0x9116
SYNC_GPU_COMMANDS_COMPLETE = 0x9117
UNSIGNALED = 0x9118
SIGNALED = 0x9119
ALREADY_SIGNALED = 0x911A
TIMEOUT_EXPIRED = 0x911B
CONDITION_SATISFIED = 0x911C
WAIT_FAILED = 0x911D
SYNC_FLUSH_COMMANDS_BIT = 0x00000001
TIMEOUT_IGNORED = 0xFFFFFFFFFFFFFFFF
VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE
ANY_SAMPLES_PASSED = 0x8C2F
ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A
SAMPLER_BINDING = 0x8919
RGB10_A2UI = 0x906F
TEXTURE_SWIZZLE_R = 0x8E42
TEXTURE_SWIZZLE_G = 0x8E43
TEXTURE_SWIZZLE_B = 0x8E44
TEXTURE_SWIZZLE_A = 0x8E45
GREEN = 0x1904
BLUE = 0x1905
INT_2_10_10_10_REV = 0x8D9F
TRANSFORM_FEEDBACK = 0x8E22
TRANSFORM_FEEDBACK_PAUSED = 0x8E23
TRANSFORM_FEEDBACK_ACTIVE = 0x8E24
TRANSFORM_FEEDBACK_BINDING = 0x8E25
PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257
PROGRAM_BINARY_LENGTH = 0x8741
NUM_PROGRAM_BINARY_FORMATS = 0x87FE
PROGRAM_BINARY_FORMATS = 0x87FF
COMPRESSED_R11_EAC = 0x9270
COMPRESSED_SIGNED_R11_EAC = 0x9271
COMPRESSED_RG11_EAC = 0x9272
COMPRESSED_SIGNED_RG11_EAC = 0x9273
COMPRESSED_RGB8_ETC2 = 0x9274
COMPRESSED_SRGB8_ETC2 = 0x9275
COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276
COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277
COMPRESSED_RGBA8_ETC2_EAC = 0x9278
COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279
TEXTURE_IMMUTABLE_FORMAT = 0x912F
MAX_ELEMENT_INDEX = 0x8D6B
NUM_SAMPLE_COUNTS = 0x9380
TEXTURE_IMMUTABLE_LEVELS = 0x82DF