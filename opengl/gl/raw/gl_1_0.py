#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def cull_face(mode):
    '''
    specify whether front- or back-facing facets can be culled.
    
    gl.cull_face specifies whether front- or back-facing facets are culled (as
    specified by mode) when facet culling is enabled. Facet culling is initially
    disabled. To enable and disable facet culling, call the gl.enable and
    gl.disable commands with the argument gl.CULL_FACE. Facets include
    triangles, quadrilaterals, polygons, and rectangles.
    
    Args:
        mode: whether front- or back-facing facets are candidates for culling.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def front_face(mode):
    '''
    define front- and back-facing polygons.
    
    Args:
        mode: the orientation of front-facing polygons.
    '''

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def hint(target, mode):
    '''
    specify implementation-specific hints.
    
    Args:
        target: a symbolic constant indicating the behavior to be controlled.
        mode: a symbolic constant indicating the desired behavior.
    '''

@accepts(t.float)
@returns(t.void)
@binds(dll)
def line_width(width):
    '''
    specify the width of rasterized lines.
    
    gl.line_width specifies the rasterized width of both aliased and antialiased
    lines. Using a line width other than 1 has different effects, depending on
    whether line antialiasing is enabled. To enable and disable line
    antialiasing, call gl.enable and gl.disable with argument gl.LINE_SMOOTH.
    Line antialiasing is initially disabled.
    
    Args:
        width: the width of rasterized lines.
    '''

@accepts(t.float)
@returns(t.void)
@binds(dll)
def point_size(size):
    '''
    specify the diameter of rasterized points.
    
    gl.point_size specifies the rasterized diameter of points. If point size
    mode is disabled (see gl.enable with parameter gl.PROGRAM_POINT_SIZE), this
    value will be used to rasterize points. Otherwise, the value written to the
    shading language built-in variable gl_PointSize will be used.
    
    Args:
        size: the diameter of rasterized points.
    '''

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def polygon_mode(face, mode):
    '''
    select a polygon rasterization mode.
    
    gl.polygon_mode controls the interpretation of polygons for rasterization.
    face describes which polygons mode applies to: both front and back-facing
    polygons (gl.FRONT_AND_BACK). The polygon mode affects only the final
    rasterization of polygons. In particular, a polygon's vertices are lit and
    the polygon is clipped and possibly culled before these modes are applied.
    
    Args:
        face: the polygons that mode applies to.
        mode: how polygons will be rasterized.
    '''

@accepts(t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def scissor(x, y, width, height):
    '''
    define the scissor box.
    
    gl.scissor defines a rectangle, called the scissor box, in window
    coordinates. The first two arguments, x and y, specify the lower left corner
    of the box. width and height specify the width and height of the box.
    
    Args:
        x: the lower left corner of the scissor box.
        y: the lower left corner of the scissor box.
        width: the width and height of the scissor box.
        height: the width and height of the scissor box.
    '''

@accepts(t.enum, t.enum, t.float)
@returns(t.void)
@binds(dll)
def tex_parameterf(target, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def tex_parameterfv(target, pname, params):
    pass

@accepts(t.enum, t.enum, t.int)
@returns(t.void)
@binds(dll)
def tex_parameteri(target, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_parameteriv(target, pname, params):
    pass

@accepts(t.enum, t.int, t.int, t.sizei, t.int, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def tex_image1_d(target, level, internalformat, width, border, format, type, pixels):
    '''
    specify a one-dimensional texture image.
    
    Args:
        target: the target texture.
        level: the level-of-detail number.
        internalformat: the number of color components in the texture.
        width: the width of the texture image.
        border: this value must be 0.
        format: the format of the pixel data.
        type: the data type of the pixel data.
        pixels: a pointer to the image data in memory.
    '''

@accepts(t.enum, t.int, t.int, t.sizei, t.sizei, t.int, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def tex_image2_d(target, level, internalformat, width, height, border, format, type, pixels):
    '''
    specify a two-dimensional texture image.
    
    Args:
        target: the target texture.
        level: the level-of-detail number.
        internalformat: the number of color components in the texture.
        width: the width of the texture image.
        height: the height of the texture image, or the number of layers in a
            texture array, in the case of the gl_texture_1d_array and
            gl_proxy_texture_1d_array targets.
        border: this value must be 0.
        format: the format of the pixel data.
        type: the data type of the pixel data.
        pixels: a pointer to the image data in memory.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def draw_buffer(buf):
    '''
    specify which color buffers are to be drawn into.
    
    Args:
        buf: for default framebuffer, the argument specifies up to four color
            buffers to be drawn into.
    '''

@accepts(t.bitfield)
@returns(t.void)
@binds(dll)
def clear(mask):
    '''
    clear buffers to preset values.
    
    gl.clear sets the bitplane area of the window to values previously selected
    by gl.clear_color, gl.clear_depth, and gl.clear_stencil. Multiple color
    buffers can be cleared simultaneously by selecting more than one buffer at a
    time using gl.draw_buffer.
    
    Args:
        mask: bitwise or of masks that indicate the buffers to be cleared.
    '''

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def clear_color(red, green, blue, alpha):
    '''
    specify clear values for the color buffers.
    
    gl.clear_color specifies the red, green, blue, and alpha values used by
    gl.clear to clear the color buffers. Values specified by gl.clear_color are
    clamped to the range 0 1.
    
    Args:
        red: the red, green, blue, and alpha values used when the color buffers
            are cleared.
        green: the red, green, blue, and alpha values used when the color
            buffers are cleared.
        blue: the red, green, blue, and alpha values used when the color buffers
            are cleared.
        alpha: the red, green, blue, and alpha values used when the color
            buffers are cleared.
    '''

@accepts(t.int)
@returns(t.void)
@binds(dll)
def clear_stencil(s):
    '''
    specify the clear value for the stencil buffer.
    
    gl.clear_stencil specifies the index used by gl.clear to clear the stencil
    buffer. s is masked with 2 m - 1, where.
    
    Args:
        s: the index used when the stencil buffer is cleared.
    '''

@accepts(t.double)
@returns(t.void)
@binds(dll)
def clear_depth(depth):
    '''
    specify the clear value for the depth buffer.
    
    gl.clear_depth specifies the depth value used by gl.clear to clear the depth
    buffer. Values specified by gl.clear_depth are clamped to the range 0 1.
    
    Args:
        depth: the depth value used when the depth buffer is cleared.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def stencil_mask(mask):
    '''
    control the front and back writing of individual bits in the stencil planes.
    
    gl.stencil_mask controls the writing of individual bits in the stencil
    planes. The least significant n bits of mask, where.
    
    Args:
        mask: a bit mask to enable and disable writing of individual bits in the
            stencil planes.
    '''

@accepts(t.boolean, t.boolean, t.boolean, t.boolean)
@returns(t.void)
@binds(dll)
def color_mask(red, green, blue, alpha):
    '''
    enable and disable writing of frame buffer color components.
    
    gl.color_mask and gl.color_maski specify whether the individual color
    components in the frame buffer can or cannot be written. gl.color_maski sets
    the mask for a specific draw buffer, whereas gl.color_mask sets the mask for
    all draw buffers. If red is gl.FALSE, for example, no change is made to the
    red component of any pixel in any of the color buffers, regardless of the
    drawing operation attempted.
    
    Args:
        red: whether red, green, blue, and alpha are to be written into the
            frame buffer.
        green: whether red, green, blue, and alpha are to be written into the
            frame buffer.
        blue: whether red, green, blue, and alpha are to be written into the
            frame buffer.
        alpha: whether red, green, blue, and alpha are to be written into the
            frame buffer.
    '''

@accepts(t.boolean)
@returns(t.void)
@binds(dll)
def depth_mask(flag):
    '''
    enable or disable writing into the depth buffer.
    
    gl.depth_mask specifies whether the depth buffer is enabled for writing. If
    flag is gl.FALSE, depth buffer writing is disabled. Otherwise, it is
    enabled. Initially, depth buffer writing is enabled.
    
    Args:
        flag: whether the depth buffer is enabled for writing.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def disable(cap):
    pass

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def enable(cap):
    '''
    enable or disable server-side GL capabilities.
    
    gl.enable and gl.disable enable and disable various capabilities. Use
    gl.is_enabled or gl.get to determine the current setting of any capability.
    The initial value for each capability with the exception of gl.DITHER and
    gl.MULTISAMPLE is gl.FALSE. The initial value for gl.DITHER and
    gl.MULTISAMPLE is gl.TRUE.
    
    Args:
        cap: a symbolic constant indicating a gl capability.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def finish():
    '''
    block until all GL execution is complete.
    
    gl.finish requires a round trip to the server.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def flush():
    '''
    force execution of GL commands in finite time.
    
    gl.flush can return at any time. It does not wait until the execution of all
    previously issued GL commands is complete.
    '''

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_func(sfactor, dfactor):
    '''
    specify pixel arithmetic.
    
    gl.blend_func defines the operation of blending for all draw buffers when it
    is enabled. gl.blend_funci defines the operation of blending for a single
    draw buffer specified by buf when enabled for that draw buffer. sfactor
    specifies which method is used to scale the source color components. dfactor
    specifies which method is used to scale the destination color components.
    
    Args:
        sfactor: how the red, green, blue, and alpha source blending factors are
            computed.
        dfactor: how the red, green, blue, and alpha destination blending
            factors are computed.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def logic_op(opcode):
    '''
    specify a logical pixel operation for rendering.
    
    gl.logic_op specifies a logical operation that, when enabled, is applied
    between the incoming RGBA color and the RGBA color at the corresponding
    location in the frame buffer. To enable or disable the logical operation,
    call gl.enable and gl.disable using the symbolic constant gl.COLOR_LOGIC_OP.
    The initial value is disabled.
    
    Args:
        opcode: a symbolic constant that selects a logical operation.
    '''

@accepts(t.enum, t.int, t.uint)
@returns(t.void)
@binds(dll)
def stencil_func(func, ref, mask):
    '''
    set front and back function and reference value for stencil testing.
    
    Args:
        func: the test function.
        ref: the reference value for the stencil test.
        mask: a mask that is anded with both the reference value and the stored
            stencil value when the test is done.
    '''

@accepts(t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def stencil_op(fail, zfail, zpass):
    '''
    set front and back stencil test actions.
    
    gl.stencil_op takes three arguments that indicate what happens to the stored
    stencil value while stenciling is enabled. If the stencil test fails, no
    change is made to the pixel's color or depth buffers, and sfail specifies
    what happens to the stencil buffer contents. The following eight actions are
    possible.
    
    Args:
        fail: the action to take when the stencil test fails.
        zfail: the stencil action when the stencil test passes, but the depth
            test fails.
        zpass: the stencil action when both the stencil test and the depth test
            pass, or when the stencil test passes and either there is no depth
            buffer or depth testing is not enabled.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def depth_func(func):
    '''
    specify the value used for depth buffer comparisons.
    
    gl.depth_func specifies the function used to compare each incoming pixel
    depth value with the depth value present in the depth buffer. The comparison
    is performed only if depth testing is enabled. (See gl.enable and gl.disable
    of gl.DEPTH_TEST.).
    
    Args:
        func: the depth comparison function.
    '''

@accepts(t.enum, t.float)
@returns(t.void)
@binds(dll)
def pixel_storef(pname, param):
    pass

@accepts(t.enum, t.int)
@returns(t.void)
@binds(dll)
def pixel_storei(pname, param):
    pass

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def read_buffer(src):
    '''
    select a color buffer source for pixels.
    
    gl.read_buffer specifies a color buffer as the source for subsequent
    gl.read_pixels, gl.copy_tex_image1D, gl.copy_tex_image2D,
    gl.copy_tex_sub_image1D, gl.copy_tex_sub_image2D, and
    gl.copy_tex_sub_image3D commands. mode accepts one of twelve or more
    predefined values. In a fully configured system, gl.FRONT, gl.LEFT, and
    gl.FRONT_LEFT all name the front left buffer, gl.FRONT_RIGHT and gl.RIGHT
    name the front right buffer, and gl.BACK_LEFT and gl.BACK name the back left
    buffer. Further more, the constants gl.COLOR_ATTACHMENTi may be used to
    indicate the ith color attachment where i ranges from zero to the value of
    gl.MAX_COLOR_ATTACHMENTS minus one.
    
    Args:
        src: a color buffer.
    '''

@accepts(t.int, t.int, t.sizei, t.sizei, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def read_pixels(x, y, width, height, format, type, pixels):
    '''
    read a block of pixels from the frame buffer.
    
    gl.read_pixels and gl.readn_pixels return pixel data from the frame buffer,
    starting with the pixel whose lower left corner is at location (x, y), into
    client memory starting at location data. Several parameters control the
    processing of the pixel data before it is placed into client memory. These
    parameters are set with gl.pixel_store. This reference page describes the
    effects on gl.read_pixels and gl.readn_pixels of most, but not all of the
    parameters specified by these three commands.
    
    Args:
        x: the window coordinates of the first pixel that is read from the frame
            buffer.
        y: the window coordinates of the first pixel that is read from the frame
            buffer.
        width: the dimensions of the pixel rectangle.
        height: the dimensions of the pixel rectangle.
        format: the format of the pixel data.
        type: the data type of the pixel data.
        pixels: returns the pixel data.
    '''

@accepts(t.enum, POINTER(t.boolean))
@returns(t.void)
@binds(dll)
def get_booleanv(pname, data):
    pass

@accepts(t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def get_doublev(pname, data):
    pass

@accepts()
@returns(t.enum)
@binds(dll)
def get_error():
    '''
    return error information.
    '''

@accepts(t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_floatv(pname, data):
    pass

@accepts(t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_integerv(pname, data):
    pass

@accepts(t.enum)
@returns(POINTER(t.ubyte))
@binds(dll)
def get_string(name):
    '''
    return a string describing the current GL connection.
    
    gl.get_string returns a pointer to a static string describing some aspect of
    the current GL connection.
    
    Args:
        name: a symbolic constant, one of gl_vendor, gl_renderer, gl_version, or
            gl_shading_language_version.
    '''

@accepts(t.enum, t.int, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def get_tex_image(target, level, format, type, pixels):
    '''
    return a texture image.
    
    gl.get_tex_image, gl.getn_tex_image and gl.get_texture_image functions
    return a texture image into pixels. For gl.get_tex_image and
    gl.getn_tex_image, target specifies whether the desired texture image is one
    specified by gl.tex_image1D (gl.TEXTURE_1D), gl.tex_image2D
    (gl.TEXTURE_1D_ARRAY, gl.TEXTURE_RECTANGLE, gl.TEXTURE_2D or any of
    gl.TEXTURE_CUBE_MAP_*), or gl.tex_image3D (gl.TEXTURE_2D_ARRAY,
    gl.TEXTURE_3D, gl.TEXTURE_CUBE_MAP_ARRAY). For gl.get_texture_image, texture
    specifies the texture object name. In addition to types of textures accepted
    by gl.get_tex_image and gl.getn_tex_image, the function also accepts cube
    map texture objects (with effective target gl.TEXTURE_CUBE_MAP).
    
    Args:
        target: the target to which the texture is bound for glgetteximage and
            glgetnteximage functions.
        level: the level-of-detail number of the desired image.
        format: a pixel format for the returned data.
        type: a pixel type for the returned data.
        pixels: returns the texture image.
    '''

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_tex_parameterfv(target, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_tex_parameteriv(target, pname, params):
    pass

@accepts(t.enum, t.int, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_tex_level_parameterfv(target, level, pname, params):
    pass

@accepts(t.enum, t.int, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_tex_level_parameteriv(target, level, pname, params):
    pass

@accepts(t.enum)
@returns(t.boolean)
@binds(dll)
def is_enabled(cap):
    '''
    test whether a capability is enabled.
    
    gl.is_enabled returns gl.TRUE if cap is an enabled capability and returns
    gl.FALSE otherwise. Boolean states that are indexed may be tested with
    gl.is_enabledi. For gl.is_enabledi, index specifies the index of the
    capability to test. index must be between zero and the count of indexed
    capabilities for cap.
    
    Args:
        cap: a symbolic constant indicating a gl capability.
    '''

@accepts(t.double, t.double)
@returns(t.void)
@binds(dll)
def depth_range(near, far):
    '''
    specify mapping of depth values from normalized device coordinates to window
coordinates.
    
    Args:
        near: the mapping of the near clipping plane to window coordinates.
        far: the mapping of the far clipping plane to window coordinates.
    '''

@accepts(t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def viewport(x, y, width, height):
    '''
    set the viewport.
    
    gl.viewport specifies the affine transformation of x and.
    
    Args:
        x: the lower left corner of the viewport rectangle, in pixels.
        y: the lower left corner of the viewport rectangle, in pixels.
        width: the width and height of the viewport.
        height: the width and height of the viewport.
    '''

@accepts(t.uint, t.enum)
@returns(t.void)
@binds(dll)
def new_list(list, mode):
    '''
    create or replace a display list.
    
    gl.new_list has two arguments. The first argument, list, is a positive
    integer that becomes the unique name for the display list. Names can be
    created and reserved with gl.gen_lists and tested for uniqueness with
    gl.is_list.
    
    Args:
        list: the display-list name.
        mode: the compilation mode, which can be gl_compile or
            gl_compile_and_execute.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def end_list():
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def call_list(list):
    '''
    execute a display list.
    
    gl.call_list causes the named display list to be executed. The commands
    saved in the display list are executed in order, just as if they were called
    without using a display list. If list has not been defined as a display
    list, gl.call_list is ignored.
    
    Args:
        list: the integer name of the display list to be executed.
    '''

@accepts(t.sizei, t.enum, t.void)
@returns(t.void)
@binds(dll)
def call_lists(n, type, lists):
    '''
    execute a list of display lists.
    
    gl.call_lists causes each display list in the list of names passed as lists
    to be executed. As a result, the commands saved in each display list are
    executed in order, just as if they were called without using a display list.
    Names of display lists that have not been defined are ignored.
    
    Args:
        n: the number of display lists to be executed.
        type: the type of values in lists.
        lists: the address of an array of name offsets in the display list.
    '''

@accepts(t.uint, t.sizei)
@returns(t.void)
@binds(dll)
def delete_lists(list, range):
    '''
    delete a contiguous group of display lists.
    
    gl.delete_lists causes a contiguous group of display lists to be deleted.
    list is the name of the first display list to be deleted, and range is the
    number of display lists to delete. All display lists d with list <= d <=
    list + range - 1 are deleted.
    
    Args:
        list: the integer name of the first display list to delete.
        range: the number of display lists to delete.
    '''

@accepts(t.sizei)
@returns(t.uint)
@binds(dll)
def gen_lists(range):
    '''
    generate a contiguous set of empty display lists.
    
    gl.gen_lists has one argument, range. It returns an integer n such that
    range contiguous empty display lists, named n, n + 1, ..., n + range - 1,
    are created. If range is 0, if there is no group of range contiguous names
    available, or if any error is generated, no display lists are generated, and
    0 is returned.
    
    Args:
        range: the number of contiguous empty display lists to be generated.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def list_base(base):
    '''
    set the display-list base for gl.call_lists.
    
    Args:
        base: an integer offset that will be added to glcalllists offsets to
            generate display-list names.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def begin(mode):
    '''
    delimit the vertices of a primitive or a group of like primitives.
    
    gl.begin and gl.end delimit the vertices that define a primitive or a group
    of like primitives. gl.begin accepts a single argument that specifies in
    which of ten ways the vertices are interpreted.
    
    Args:
        mode: the primitive or primitives that will be created from vertices
            presented between glbegin and the subsequent glend.
    '''

@accepts(t.sizei, t.sizei, t.float, t.float, t.float, t.float, POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def bitmap(width, height, xorig, yorig, xmove, ymove, bitmap):
    '''
    draw a bitmap.
    
    gl.bitmap takes seven arguments. The first pair specifies the width and
    height of the bitmap image. The second pair specifies the location of the
    bitmap origin relative to the lower left corner of the bitmap image. The
    third pair of arguments specifies x and y offsets to be added to the current
    raster position after the bitmap has been drawn.
    
    Args:
        width: the pixel width and height of the bitmap image.
        height: the pixel width and height of the bitmap image.
        xorig: the location of the origin in the bitmap image.
        yorig: the location of the origin in the bitmap image.
        xmove: the x and y offsets to be added to the current raster position
            after the bitmap is drawn.
        ymove: the x and y offsets to be added to the current raster position
            after the bitmap is drawn.
        bitmap: the address of the bitmap image.
    '''

@accepts(t.byte, t.byte, t.byte)
@returns(t.void)
@binds(dll)
def color3b(red, green, blue):
    pass

@accepts(POINTER(t.byte))
@returns(t.void)
@binds(dll)
def color3bv(v):
    pass

@accepts(t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def color3d(red, green, blue):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def color3dv(v):
    pass

@accepts(t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def color3f(red, green, blue):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def color3fv(v):
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def color3i(red, green, blue):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def color3iv(v):
    pass

@accepts(t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def color3s(red, green, blue):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def color3sv(v):
    pass

@accepts(t.ubyte, t.ubyte, t.ubyte)
@returns(t.void)
@binds(dll)
def color3ub(red, green, blue):
    pass

@accepts(POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def color3ubv(v):
    pass

@accepts(t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def color3ui(red, green, blue):
    pass

@accepts(POINTER(t.uint))
@returns(t.void)
@binds(dll)
def color3uiv(v):
    pass

@accepts(t.ushort, t.ushort, t.ushort)
@returns(t.void)
@binds(dll)
def color3us(red, green, blue):
    pass

@accepts(POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def color3usv(v):
    pass

@accepts(t.byte, t.byte, t.byte, t.byte)
@returns(t.void)
@binds(dll)
def color4b(red, green, blue, alpha):
    pass

@accepts(POINTER(t.byte))
@returns(t.void)
@binds(dll)
def color4bv(v):
    pass

@accepts(t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def color4d(red, green, blue, alpha):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def color4dv(v):
    pass

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def color4f(red, green, blue, alpha):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def color4fv(v):
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def color4i(red, green, blue, alpha):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def color4iv(v):
    pass

@accepts(t.short, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def color4s(red, green, blue, alpha):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def color4sv(v):
    pass

@accepts(t.ubyte, t.ubyte, t.ubyte, t.ubyte)
@returns(t.void)
@binds(dll)
def color4ub(red, green, blue, alpha):
    pass

@accepts(POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def color4ubv(v):
    pass

@accepts(t.uint, t.uint, t.uint, t.uint)
@returns(t.void)
@binds(dll)
def color4ui(red, green, blue, alpha):
    pass

@accepts(POINTER(t.uint))
@returns(t.void)
@binds(dll)
def color4uiv(v):
    pass

@accepts(t.ushort, t.ushort, t.ushort, t.ushort)
@returns(t.void)
@binds(dll)
def color4us(red, green, blue, alpha):
    pass

@accepts(POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def color4usv(v):
    pass

@accepts(t.boolean)
@returns(t.void)
@binds(dll)
def edge_flag(flag):
    '''
    flag edges as either boundary or nonboundary.
    
    Args:
        flag: the current edge flag value, either gl_true or gl_false.
    '''

@accepts(POINTER(t.boolean))
@returns(t.void)
@binds(dll)
def edge_flagv(flag):
    pass

@accepts()
@returns(t.void)
@binds(dll)
def end():
    pass

@accepts(t.double)
@returns(t.void)
@binds(dll)
def indexd(c):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def indexdv(c):
    pass

@accepts(t.float)
@returns(t.void)
@binds(dll)
def indexf(c):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def indexfv(c):
    pass

@accepts(t.int)
@returns(t.void)
@binds(dll)
def indexi(c):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def indexiv(c):
    pass

@accepts(t.short)
@returns(t.void)
@binds(dll)
def indexs(c):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def indexsv(c):
    pass

@accepts(t.byte, t.byte, t.byte)
@returns(t.void)
@binds(dll)
def normal3b(nx, ny, nz):
    pass

@accepts(POINTER(t.byte))
@returns(t.void)
@binds(dll)
def normal3bv(v):
    pass

@accepts(t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def normal3d(nx, ny, nz):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def normal3dv(v):
    pass

@accepts(t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def normal3f(nx, ny, nz):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def normal3fv(v):
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def normal3i(nx, ny, nz):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def normal3iv(v):
    pass

@accepts(t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def normal3s(nx, ny, nz):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def normal3sv(v):
    pass

@accepts(t.double, t.double)
@returns(t.void)
@binds(dll)
def raster_pos2d(x, y):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def raster_pos2dv(v):
    pass

@accepts(t.float, t.float)
@returns(t.void)
@binds(dll)
def raster_pos2f(x, y):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def raster_pos2fv(v):
    pass

@accepts(t.int, t.int)
@returns(t.void)
@binds(dll)
def raster_pos2i(x, y):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def raster_pos2iv(v):
    pass

@accepts(t.short, t.short)
@returns(t.void)
@binds(dll)
def raster_pos2s(x, y):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def raster_pos2sv(v):
    pass

@accepts(t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def raster_pos3d(x, y, z):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def raster_pos3dv(v):
    pass

@accepts(t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def raster_pos3f(x, y, z):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def raster_pos3fv(v):
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def raster_pos3i(x, y, z):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def raster_pos3iv(v):
    pass

@accepts(t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def raster_pos3s(x, y, z):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def raster_pos3sv(v):
    pass

@accepts(t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def raster_pos4d(x, y, z, w):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def raster_pos4dv(v):
    pass

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def raster_pos4f(x, y, z, w):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def raster_pos4fv(v):
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def raster_pos4i(x, y, z, w):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def raster_pos4iv(v):
    pass

@accepts(t.short, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def raster_pos4s(x, y, z, w):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def raster_pos4sv(v):
    pass

@accepts(t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def rectd(x1, y1, x2, y2):
    pass

@accepts(POINTER(t.double), POINTER(t.double))
@returns(t.void)
@binds(dll)
def rectdv(v1, v2):
    pass

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def rectf(x1, y1, x2, y2):
    pass

@accepts(POINTER(t.float), POINTER(t.float))
@returns(t.void)
@binds(dll)
def rectfv(v1, v2):
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def recti(x1, y1, x2, y2):
    pass

@accepts(POINTER(t.int), POINTER(t.int))
@returns(t.void)
@binds(dll)
def rectiv(v1, v2):
    pass

@accepts(t.short, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def rects(x1, y1, x2, y2):
    pass

@accepts(POINTER(t.short), POINTER(t.short))
@returns(t.void)
@binds(dll)
def rectsv(v1, v2):
    pass

@accepts(t.double)
@returns(t.void)
@binds(dll)
def tex_coord1d(s):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def tex_coord1dv(v):
    pass

@accepts(t.float)
@returns(t.void)
@binds(dll)
def tex_coord1f(s):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def tex_coord1fv(v):
    pass

@accepts(t.int)
@returns(t.void)
@binds(dll)
def tex_coord1i(s):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_coord1iv(v):
    pass

@accepts(t.short)
@returns(t.void)
@binds(dll)
def tex_coord1s(s):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def tex_coord1sv(v):
    pass

@accepts(t.double, t.double)
@returns(t.void)
@binds(dll)
def tex_coord2d(s, t):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def tex_coord2dv(v):
    pass

@accepts(t.float, t.float)
@returns(t.void)
@binds(dll)
def tex_coord2f(s, t):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def tex_coord2fv(v):
    pass

@accepts(t.int, t.int)
@returns(t.void)
@binds(dll)
def tex_coord2i(s, t):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_coord2iv(v):
    pass

@accepts(t.short, t.short)
@returns(t.void)
@binds(dll)
def tex_coord2s(s, t):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def tex_coord2sv(v):
    pass

@accepts(t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def tex_coord3d(s, t, r):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def tex_coord3dv(v):
    pass

@accepts(t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def tex_coord3f(s, t, r):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def tex_coord3fv(v):
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def tex_coord3i(s, t, r):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_coord3iv(v):
    pass

@accepts(t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def tex_coord3s(s, t, r):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def tex_coord3sv(v):
    pass

@accepts(t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def tex_coord4d(s, t, r, q):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def tex_coord4dv(v):
    pass

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def tex_coord4f(s, t, r, q):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def tex_coord4fv(v):
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def tex_coord4i(s, t, r, q):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_coord4iv(v):
    pass

@accepts(t.short, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def tex_coord4s(s, t, r, q):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def tex_coord4sv(v):
    pass

@accepts(t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex2d(x, y):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex2dv(v):
    pass

@accepts(t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex2f(x, y):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex2fv(v):
    pass

@accepts(t.int, t.int)
@returns(t.void)
@binds(dll)
def vertex2i(x, y):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex2iv(v):
    pass

@accepts(t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex2s(x, y):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex2sv(v):
    pass

@accepts(t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex3d(x, y, z):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex3dv(v):
    pass

@accepts(t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex3f(x, y, z):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex3fv(v):
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def vertex3i(x, y, z):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex3iv(v):
    pass

@accepts(t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex3s(x, y, z):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex3sv(v):
    pass

@accepts(t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def vertex4d(x, y, z, w):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def vertex4dv(v):
    pass

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex4f(x, y, z, w):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex4fv(v):
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def vertex4i(x, y, z, w):
    pass

@accepts(POINTER(t.int))
@returns(t.void)
@binds(dll)
def vertex4iv(v):
    pass

@accepts(t.short, t.short, t.short, t.short)
@returns(t.void)
@binds(dll)
def vertex4s(x, y, z, w):
    pass

@accepts(POINTER(t.short))
@returns(t.void)
@binds(dll)
def vertex4sv(v):
    pass

@accepts(t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def clip_plane(plane, equation):
    '''
    specify a plane against which all geometry is clipped.
    
    gl.clip_plane specifies a half-space using a four-component plane equation.
    When gl.clip_plane is called, equation is transformed by the inverse of the
    modelview matrix and stored in the resulting eye coordinates. Subsequent
    changes to the modelview matrix have no effect on the stored plane-equation
    components. If the dot product of the eye coordinates of a vertex with the
    stored plane equation components is positive or zero, the vertex is in with
    respect to that clipping plane.
    
    Args:
        plane: which clipping plane is being positioned.
        equation: the address of an array of four double-precision floating-
            point values.
    '''

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def color_material(face, mode):
    '''
    cause a material color to track the current color.
    
    gl.color_material specifies which material parameters track the current
    color. When gl.COLOR_MATERIAL is enabled, the material parameter or
    parameters specified by mode, of the material or materials specified by
    face, track the current color at all times.
    
    Args:
        face: whether front, back, or both front and back material parameters
            should track the current color.
        mode: which of several material parameters track the current color.
    '''

@accepts(t.enum, t.float)
@returns(t.void)
@binds(dll)
def fogf(pname, param):
    pass

@accepts(t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def fogfv(pname, params):
    pass

@accepts(t.enum, t.int)
@returns(t.void)
@binds(dll)
def fogi(pname, param):
    pass

@accepts(t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def fogiv(pname, params):
    pass

@accepts(t.enum, t.enum, t.float)
@returns(t.void)
@binds(dll)
def lightf(light, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def lightfv(light, pname, params):
    pass

@accepts(t.enum, t.enum, t.int)
@returns(t.void)
@binds(dll)
def lighti(light, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def lightiv(light, pname, params):
    pass

@accepts(t.enum, t.float)
@returns(t.void)
@binds(dll)
def light_modelf(pname, param):
    pass

@accepts(t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def light_modelfv(pname, params):
    pass

@accepts(t.enum, t.int)
@returns(t.void)
@binds(dll)
def light_modeli(pname, param):
    pass

@accepts(t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def light_modeliv(pname, params):
    pass

@accepts(t.int, t.ushort)
@returns(t.void)
@binds(dll)
def line_stipple(factor, pattern):
    '''
    specify the line stipple pattern.
    
    Args:
        factor: a multiplier for each bit in the line stipple pattern.
        pattern: a 16-bit integer whose bit pattern determines which fragments
            of a line will be drawn when the line is rasterized.
    '''

@accepts(t.enum, t.enum, t.float)
@returns(t.void)
@binds(dll)
def materialf(face, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def materialfv(face, pname, params):
    pass

@accepts(t.enum, t.enum, t.int)
@returns(t.void)
@binds(dll)
def materiali(face, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def materialiv(face, pname, params):
    pass

@accepts(POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def polygon_stipple(mask):
    '''
    set the polygon stippling pattern.
    
    Args:
        mask: a pointer to a 32 * 32 stipple pattern that will be unpacked from
            memory in the same way that gldrawpixels unpacks pixels.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def shade_model(mode):
    '''
    select flat or smooth shading.
    
    Args:
        mode: a symbolic value representing a shading technique.
    '''

@accepts(t.enum, t.enum, t.float)
@returns(t.void)
@binds(dll)
def tex_envf(target, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def tex_envfv(target, pname, params):
    pass

@accepts(t.enum, t.enum, t.int)
@returns(t.void)
@binds(dll)
def tex_envi(target, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_enviv(target, pname, params):
    pass

@accepts(t.enum, t.enum, t.double)
@returns(t.void)
@binds(dll)
def tex_gend(coord, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def tex_gendv(coord, pname, params):
    pass

@accepts(t.enum, t.enum, t.float)
@returns(t.void)
@binds(dll)
def tex_genf(coord, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def tex_genfv(coord, pname, params):
    pass

@accepts(t.enum, t.enum, t.int)
@returns(t.void)
@binds(dll)
def tex_geni(coord, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_geniv(coord, pname, params):
    pass

@accepts(t.sizei, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def feedback_buffer(size, type, buffer):
    '''
    controls feedback mode.
    
    gl.feedback_buffer has three arguments: buffer is a pointer to an array of
    floating-point values into which feedback information is placed. size
    indicates the size of the array. type is a symbolic constant describing the
    information that is fed back for each vertex. gl.feedback_buffer must be
    issued before feedback mode is enabled (by calling gl.render_mode with
    argument gl.FEEDBACK).
    
    Args:
        size: the maximum number of values that can be written into buffer.
        type: a symbolic constant that describes the information that will be
            returned for each vertex.
        buffer: returns the feedback data.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def select_buffer(size, buffer):
    '''
    establish a buffer for selection mode values.
    
    gl.select_buffer has two arguments: buffer is a pointer to an array of
    unsigned integers, and size indicates the size of the array. buffer returns
    values from the name stack (see gl.init_names, gl.load_name, gl.push_name)
    when the rendering mode is gl.SELECT (see gl.render_mode). gl.select_buffer
    must be issued before selection mode is enabled, and it must not be issued
    while the rendering mode is gl.SELECT.
    
    Args:
        size: the size of buffer.
        buffer: returns the selection data.
    '''

@accepts(t.enum)
@returns(t.int)
@binds(dll)
def render_mode(mode):
    '''
    set rasterization mode.
    
    gl.render_mode sets the rasterization mode.
    
    Args:
        mode: the rasterization mode.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def init_names():
    '''
    initialize the name stack.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def load_name(name):
    '''
    load a name onto the name stack.
    
    gl.load_name causes name to replace the value on the top of the name stack.
    
    Args:
        name: a name that will replace the top value on the name stack.
    '''

@accepts(t.float)
@returns(t.void)
@binds(dll)
def pass_through(token):
    '''
    place a marker in the feedback buffer.
    
    gl.pass_through inserts a user-defined marker in the feedback buffer when it
    is executed in feedback mode. token is returned as if it were a primitive;
    it is indicated with its own unique identifying value:
    gl.PASS_THROUGH_TOKEN. The order of gl.pass_through commands with respect to
    the specification of graphics primitives is maintained.
    
    Args:
        token: a marker value to be placed in the feedback buffer following a
            gl_pass_through_token.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def pop_name():
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def push_name(name):
    '''
    push and pop the name stack.
    
    gl.push_name causes name to be pushed onto the name stack. gl.pop_name pops
    one name off the top of the stack.
    
    Args:
        name: a name that will be pushed onto the name stack.
    '''

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def clear_accum(red, green, blue, alpha):
    '''
    specify clear values for the accumulation buffer.
    
    gl.clear_accum specifies the red, green, blue, and alpha values used by
    gl.clear to clear the accumulation buffer.
    
    Args:
        red: the red, green, blue, and alpha values used when the accumulation
            buffer is cleared.
        green: the red, green, blue, and alpha values used when the accumulation
            buffer is cleared.
        blue: the red, green, blue, and alpha values used when the accumulation
            buffer is cleared.
        alpha: the red, green, blue, and alpha values used when the accumulation
            buffer is cleared.
    '''

@accepts(t.float)
@returns(t.void)
@binds(dll)
def clear_index(c):
    '''
    specify the clear value for the color index buffers.
    
    gl.clear_index specifies the index used by gl.clear to clear the color index
    buffers. c is not clamped. Rather, c is converted to a fixed-point value
    with unspecified precision to the right of the binary point. The integer
    part of this value is then masked with 2 m - 1, where m is the number of
    bits in a color index stored in the frame buffer.
    
    Args:
        c: the index used when the color index buffers are cleared.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def index_mask(mask):
    '''
    control the writing of individual bits in the color index buffers.
    
    gl.index_mask controls the writing of individual bits in the color index
    buffers. The least significant n bits of mask, where n is the number of bits
    in a color index buffer, specify a mask. Where a 1 (one) appears in the
    mask, it's possible to write to the corresponding bit in the color index
    buffer (or buffers). Where a 0 (zero) appears, the corresponding bit is
    write-protected.
    
    Args:
        mask: a bit mask to enable and disable the writing of individual bits in
            the color index buffers.
    '''

@accepts(t.enum, t.float)
@returns(t.void)
@binds(dll)
def accum(op, value):
    '''
    operate on the accumulation buffer.
    
    gl.accum operates on the accumulation buffer. The first argument, op, is a
    symbolic constant that selects an accumulation buffer operation. The second
    argument, value, is a floating-point value to be used in that operation.
    Five operations are specified: gl.ACCUM, gl.LOAD, gl.ADD, gl.MULT, and
    gl.RETURN.
    
    Args:
        op: the accumulation buffer operation.
        value: a floating-point value used in the accumulation buffer operation.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def pop_attrib():
    pass

@accepts(t.bitfield)
@returns(t.void)
@binds(dll)
def push_attrib(mask):
    '''
    push and pop the server attribute stack.
    
    gl.push_attrib takes one argument, a mask that indicates which groups of
    state variables to save on the attribute stack. Symbolic constants are used
    to set bits in the mask. mask is typically constructed by specifying the
    bitwise-or of several of these constants together. The special mask
    gl.ALL_ATTRIB_BITS can be used to save all stackable states.
    
    Args:
        mask: a mask that indicates which attributes to save.
    '''

@accepts(t.enum, t.double, t.double, t.int, t.int, POINTER(t.double))
@returns(t.void)
@binds(dll)
def map1d(target, u1, u2, stride, order, points):
    pass

@accepts(t.enum, t.float, t.float, t.int, t.int, POINTER(t.float))
@returns(t.void)
@binds(dll)
def map1f(target, u1, u2, stride, order, points):
    pass

@accepts(t.enum, t.double, t.double, t.int, t.int, t.double, t.double, t.int, t.int, POINTER(t.double))
@returns(t.void)
@binds(dll)
def map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points):
    pass

@accepts(t.enum, t.float, t.float, t.int, t.int, t.float, t.float, t.int, t.int, POINTER(t.float))
@returns(t.void)
@binds(dll)
def map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points):
    pass

@accepts(t.int, t.double, t.double)
@returns(t.void)
@binds(dll)
def map_grid1d(un, u1, u2):
    pass

@accepts(t.int, t.float, t.float)
@returns(t.void)
@binds(dll)
def map_grid1f(un, u1, u2):
    pass

@accepts(t.int, t.double, t.double, t.int, t.double, t.double)
@returns(t.void)
@binds(dll)
def map_grid2d(un, u1, u2, vn, v1, v2):
    pass

@accepts(t.int, t.float, t.float, t.int, t.float, t.float)
@returns(t.void)
@binds(dll)
def map_grid2f(un, u1, u2, vn, v1, v2):
    pass

@accepts(t.double)
@returns(t.void)
@binds(dll)
def eval_coord1d(u):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def eval_coord1dv(u):
    pass

@accepts(t.float)
@returns(t.void)
@binds(dll)
def eval_coord1f(u):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def eval_coord1fv(u):
    pass

@accepts(t.double, t.double)
@returns(t.void)
@binds(dll)
def eval_coord2d(u, v):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def eval_coord2dv(u):
    pass

@accepts(t.float, t.float)
@returns(t.void)
@binds(dll)
def eval_coord2f(u, v):
    pass

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def eval_coord2fv(u):
    pass

@accepts(t.enum, t.int, t.int)
@returns(t.void)
@binds(dll)
def eval_mesh1(mode, i1, i2):
    pass

@accepts(t.int)
@returns(t.void)
@binds(dll)
def eval_point1(i):
    pass

@accepts(t.enum, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def eval_mesh2(mode, i1, i2, j1, j2):
    pass

@accepts(t.int, t.int)
@returns(t.void)
@binds(dll)
def eval_point2(i, j):
    pass

@accepts(t.enum, t.float)
@returns(t.void)
@binds(dll)
def alpha_func(func, ref):
    '''
    specify the alpha test function.
    
    gl.alpha_func operates on all pixel write operations, including those
    resulting from the scan conversion of points, lines, polygons, and bitmaps,
    and from pixel draw and copy operations. gl.alpha_func does not affect
    screen clear operations.
    
    Args:
        func: the alpha comparison function.
        ref: the reference value that incoming alpha values are compared to.
    '''

@accepts(t.float, t.float)
@returns(t.void)
@binds(dll)
def pixel_zoom(xfactor, yfactor):
    '''
    specify the pixel zoom factors.
    
    gl.pixel_zoom specifies values for the x and y zoom factors. During the
    execution of gl.draw_pixels or gl.copy_pixels, if ( xr, yr ) is the current
    raster position, and a given element is in the mth row and nth column of the
    pixel rectangle, then pixels whose centers are in the rectangle with corners
    at.
    
    Args:
        xfactor: the x and y zoom factors for pixel write operations.
        yfactor: the x and y zoom factors for pixel write operations.
    '''

@accepts(t.enum, t.float)
@returns(t.void)
@binds(dll)
def pixel_transferf(pname, param):
    pass

@accepts(t.enum, t.int)
@returns(t.void)
@binds(dll)
def pixel_transferi(pname, param):
    pass

@accepts(t.enum, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def pixel_mapfv(map, mapsize, values):
    pass

@accepts(t.enum, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def pixel_mapuiv(map, mapsize, values):
    pass

@accepts(t.enum, t.sizei, POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def pixel_mapusv(map, mapsize, values):
    pass

@accepts(t.int, t.int, t.sizei, t.sizei, t.enum)
@returns(t.void)
@binds(dll)
def copy_pixels(x, y, width, height, type):
    '''
    copy pixels in the frame buffer.
    
    gl.copy_pixels copies a screen-aligned rectangle of pixels from the
    specified frame buffer location to a region relative to the current raster
    position. Its operation is well defined only if the entire pixel source
    region is within the exposed portion of the window. Results of copies from
    outside the window, or from regions of the window that are not exposed, are
    hardware dependent and undefined.
    
    Args:
        x: the window coordinates of the lower left corner of the rectangular
            region of pixels to be copied.
        y: the window coordinates of the lower left corner of the rectangular
            region of pixels to be copied.
        width: the dimensions of the rectangular region of pixels to be copied.
        height: the dimensions of the rectangular region of pixels to be copied.
        type: whether color values, depth values, or stencil values are to be
            copied.
    '''

@accepts(t.sizei, t.sizei, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def draw_pixels(width, height, format, type, pixels):
    '''
    write a block of pixels to the frame buffer.
    
    gl.draw_pixels reads pixel data from memory and writes it into the frame
    buffer relative to the current raster position, provided that the raster
    position is valid. Use gl.raster_pos or gl.window_pos to set the current
    raster position; use gl.get with argument gl.CURRENT_RASTER_POSITION_VALID
    to determine if the specified raster position is valid, and gl.get with
    argument gl.CURRENT_RASTER_POSITION to query the raster position.
    
    Args:
        width: the dimensions of the pixel rectangle to be written into the
            frame buffer.
        height: the dimensions of the pixel rectangle to be written into the
            frame buffer.
        format: the format of the pixel data.
        type: the data type for data.
        pixels: a pointer to the pixel data.
    '''

@accepts(t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def get_clip_plane(plane, equation):
    '''
    return the coefficients of the specified clipping plane.
    
    gl.get_clip_plane returns in equation the four coefficients of the plane
    equation for plane.
    
    Args:
        plane: a clipping plane.
        equation: returns four double-precision values that are the coefficients
            of the plane equation of plane in eye coordinates.
    '''

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_lightfv(light, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_lightiv(light, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def get_mapdv(target, query, v):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_mapfv(target, query, v):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_mapiv(target, query, v):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_materialfv(face, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_materialiv(face, pname, params):
    pass

@accepts(t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_pixel_mapfv(map, values):
    pass

@accepts(t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_pixel_mapuiv(map, values):
    pass

@accepts(t.enum, POINTER(t.ushort))
@returns(t.void)
@binds(dll)
def get_pixel_mapusv(map, values):
    pass

@accepts(POINTER(t.ubyte))
@returns(t.void)
@binds(dll)
def get_polygon_stipple(mask):
    '''
    return the polygon stipple pattern.
    
    gl.get_polygon_stipple returns to pattern a 32 * 32 polygon stipple pattern.
    The pattern is packed into memory as if gl.read_pixels with both height and
    width of 32, type of gl.BITMAP, and format of gl.COLOR_INDEX were called,
    and the stipple pattern were stored in an internal 32 * 32 color index
    buffer. Unlike gl.read_pixels, however, pixel transfer operations (shift,
    offset, pixel map) are not applied to the returned stipple image.
    
    Args:
        mask: returns the stipple pattern.
    '''

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_tex_envfv(target, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_tex_enviv(target, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.double))
@returns(t.void)
@binds(dll)
def get_tex_gendv(coord, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_tex_genfv(coord, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_tex_geniv(coord, pname, params):
    pass

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_list(list):
    '''
    determine if a name corresponds to a display list.
    
    gl.is_list returns gl.TRUE if list is the name of a display list and returns
    gl.FALSE if it is not, or if an error occurs.
    
    Args:
        list: a potential display list name.
    '''

@accepts(t.double, t.double, t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def frustum(left, right, bottom, top, znear, zfar):
    '''
    multiply the current matrix by a perspective matrix.
    
    gl.frustum describes a perspective matrix that produces a perspective
    projection. The current matrix (see gl.matrix_mode) is multiplied by this
    matrix and the result replaces the current matrix, as if gl.
    
    Args:
        left: the coordinates for the left and right vertical clipping planes.
        right: the coordinates for the left and right vertical clipping planes.
        bottom: the coordinates for the bottom and top horizontal clipping
            planes.
        top: the coordinates for the bottom and top horizontal clipping planes.
        znear: the distances to the near and far depth clipping planes.
        zfar: the distances to the near and far depth clipping planes.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def load_identity():
    '''
    replace the current matrix with the identity matrix.
    '''

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def load_matrixf(m):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def load_matrixd(m):
    pass

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def matrix_mode(mode):
    '''
    specify which matrix is the current matrix.
    
    gl.matrix_mode sets the current matrix mode.
    
    Args:
        mode: which matrix stack is the target for subsequent matrix operations.
    '''

@accepts(POINTER(t.float))
@returns(t.void)
@binds(dll)
def mult_matrixf(m):
    pass

@accepts(POINTER(t.double))
@returns(t.void)
@binds(dll)
def mult_matrixd(m):
    pass

@accepts(t.double, t.double, t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def ortho(left, right, bottom, top, znear, zfar):
    '''
    multiply the current matrix with an orthographic matrix.
    
    gl.ortho describes a transformation that produces a parallel projection. The
    current matrix (see gl.matrix_mode) is multiplied by this matrix and the
    result replaces the current matrix, as if gl.
    
    Args:
        left: the coordinates for the left and right vertical clipping planes.
        right: the coordinates for the left and right vertical clipping planes.
        bottom: the coordinates for the bottom and top horizontal clipping
            planes.
        top: the coordinates for the bottom and top horizontal clipping planes.
        znear: the distances to the nearer and farther depth clipping planes.
        zfar: the distances to the nearer and farther depth clipping planes.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def pop_matrix():
    pass

@accepts()
@returns(t.void)
@binds(dll)
def push_matrix():
    '''
    push and pop the current matrix stack.
    '''

@accepts(t.double, t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def rotated(angle, x, y, z):
    pass

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def rotatef(angle, x, y, z):
    pass

@accepts(t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def scaled(x, y, z):
    pass

@accepts(t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def scalef(x, y, z):
    pass

@accepts(t.double, t.double, t.double)
@returns(t.void)
@binds(dll)
def translated(x, y, z):
    pass

@accepts(t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def translatef(x, y, z):
    pass
