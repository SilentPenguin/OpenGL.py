#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def active_texture(texture):
    '''
    select active texture unit.
    
    gl.active_texture selects which texture unit subsequent texture state calls
    will affect. The number of texture units an implementation supports is
    implementation dependent, but must be at least 80.
    
    Args:
        texture: which texture unit to make active.
    '''

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def attach_shader(program, shader):
    '''
    Attaches a shader object to a program object.
    
    Args:
        program: the program object to which a shader object will be attached.
        shader: the shader object that is to be attached.
    '''

@accepts(t.uint, t.uint, t.char_p)
@returns(t.void)
@binds(dll)
def bind_attrib_location(program, index, name):
    '''
    Associates a generic vertex attribute index with a named attribute variable.
    
    gl.bind_attrib_location is used to associate a user-defined attribute
    variable in the program object specified by program with a generic vertex
    attribute index. The name of the user-defined attribute variable is passed
    as a null terminated string in name. The generic vertex attribute index to
    be bound to this variable is specified by index. When program is made part
    of current state, values provided via the generic vertex attribute index
    will modify the value of the user-defined attribute variable specified by
    name.
    
    Args:
        program: the handle of the program object in which the association is to
            be made.
        index: the index of the generic vertex attribute to be bound.
        name: a null terminated string containing the name of the vertex shader
            attribute variable to which index is to be bound.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def bind_buffer(target, buffer):
    '''
    bind a named buffer object.
    
    gl.bind_buffer binds a buffer object to the specified buffer binding point.
    Calling gl.bind_buffer with target set to one of the accepted symbolic
    constants and buffer set to the name of a buffer object binds that buffer
    object name to the target. If no buffer object with name buffer exists, one
    is created with that name. When a buffer object is bound to a target, the
    previous binding for that target is automatically broken.
    
    Args:
        target: the target to which the buffer object is bound, which must be
            one of the buffer binding targets in the following table:.
        buffer: the name of a buffer object.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def bind_framebuffer(target, framebuffer):
    '''
    bind a framebuffer to a framebuffer target.
    
    gl.bind_framebuffer binds the framebuffer object with name framebuffer to
    the framebuffer target specified by target. target must be either
    gl.DRAW_FRAMEBUFFER, gl.READ_FRAMEBUFFER or gl.FRAMEBUFFER. If a framebuffer
    object is bound to gl.DRAW_FRAMEBUFFER or gl.READ_FRAMEBUFFER, it becomes
    the target for rendering or readback operations, respectively, until it is
    deleted or another framebuffer is bound to the corresponding bind point.
    Calling gl.bind_framebuffer with target set to gl.FRAMEBUFFER binds
    framebuffer to both the read and draw framebuffer targets.
    
    Args:
        target: the framebuffer target of the binding operation.
        framebuffer: the name of the framebuffer object to bind.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def bind_renderbuffer(target, renderbuffer):
    '''
    bind a renderbuffer to a renderbuffer target.
    
    gl.bind_renderbuffer binds the renderbuffer object with name renderbuffer to
    the renderbuffer target specified by target. target must be gl.RENDERBUFFER.
    renderbuffer is the name of a renderbuffer object previously returned from a
    call to gl.gen_renderbuffers, or zero to break the existing binding of a
    renderbuffer object to target.
    
    Args:
        target: the renderbuffer target of the binding operation.
        renderbuffer: the name of the renderbuffer object to bind.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def bind_texture(target, texture):
    '''
    bind a named texture to a texturing target.
    
    gl.bind_texture lets you create or use a named texture. Calling
    gl.bind_texture with target set to gl.TEXTURE_1D, gl.TEXTURE_2D,
    gl.TEXTURE_3D, gl.TEXTURE_1D_ARRAY, gl.TEXTURE_2D_ARRAY,
    gl.TEXTURE_RECTANGLE, gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_ARRAY,
    gl.TEXTURE_BUFFER, gl.TEXTURE_2D_MULTISAMPLE or
    gl.TEXTURE_2D_MULTISAMPLE_ARRAY and texture set to the name of the new
    texture binds the texture name to the target. When a texture is bound to a
    target, the previous binding for that target is automatically broken.
    
    Args:
        target: the target to which the texture is bound.
        texture: the name of a texture.
    '''

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def blend_color(red, green, blue, alpha):
    '''
    set the blend color.
    
    Args:
        red: the components of gl_blend_color.
        green: the components of gl_blend_color.
        blue: the components of gl_blend_color.
        alpha: the components of gl_blend_color.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def blend_equation(mode):
    '''
    specify the equation used for both the RGB blend equation and the Alpha blend
equation.
    
    Args:
        mode: how source and destination colors are combined.
    '''

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_equation_separate(modergb, modealpha):
    '''
    set the RGB blend equation and the alpha blend equation separately.
    
    Args:
        modergb: the rgb blend equation, how the red, green, and blue components
            of the source and destination colors are combined.
        modealpha: the alpha blend equation, how the alpha component of the
            source and destination colors are combined.
    '''

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_func(sfactor, dfactor):
    '''
    specify pixel arithmetic.
    
    gl.blend_func defines the operation of blending for all draw buffers when it
    is enabled. gl.blend_funci defines the operation of blending for a single
    draw buffer specified by buf when enabled for that draw buffer. sfactor
    specifies which method is used to scale the source color components. dfactor
    specifies which method is used to scale the destination color components.
    
    Args:
        sfactor: how the red, green, blue, and alpha source blending factors are
            computed.
        dfactor: how the red, green, blue, and alpha destination blending
            factors are computed.
    '''

@accepts(t.enum, t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_func_separate(sfactorrgb, dfactorrgb, sfactoralpha, dfactoralpha):
    '''
    specify pixel arithmetic for RGB and alpha components separately.
    
    gl.blend_func_separate defines the operation of blending for all draw
    buffers when it is enabled. gl.blend_func_separatei defines the operation of
    blending for a single draw buffer specified by buf when enabled for that
    draw buffer. srcRGB specifies which method is used to scale the source RGB-
    color components. dstRGB specifies which method is used to scale the
    destination RGB-color components.
    
    Args:
        sfactorrgb: how the red, green, and blue blending factors are computed.
        dfactorrgb: how the red, green, and blue destination blending factors
            are computed.
        sfactoralpha: specified how the alpha source blending factor is
            computed.
        dfactoralpha: specified how the alpha destination blending factor is
            computed.
    '''

@accepts(t.enum, t.sizeiptr, t.void, t.enum)
@returns(t.void)
@binds(dll)
def buffer_data(target, size, data, usage):
    '''
    creates and initializes a buffer object's data store.
    
    gl.buffer_data and gl.named_buffer_data create a new data store for a buffer
    object. In case of gl.buffer_data, the buffer object currently bound to
    target is used. For gl.named_buffer_data, a buffer object associated with ID
    specified by the caller in buffer will be used instead.
    
    Args:
        target: the target to which the buffer object is bound for glbufferdata,
            which must be one of the buffer binding targets in the following
            table:.
        size: the size in bytes of the buffer object's new data store.
        data: a pointer to data that will be copied into the data store for
            initialization, or null if no data is to be copied.
        usage: the expected usage pattern of the data store.
    '''

@accepts(t.enum, t.intptr, t.sizeiptr, t.void)
@returns(t.void)
@binds(dll)
def buffer_sub_data(target, offset, size, data):
    '''
    updates a subset of a buffer object's data store.
    
    gl.buffer_sub_data and gl.named_buffer_sub_data redefine some or all of the
    data store for the specified buffer object. Data starting at byte offset
    offset and extending for size bytes is copied to the data store from the
    memory pointed to by data. offset and size must define a range lying
    entirely within the buffer object's data store.
    
    Args:
        target: the target to which the buffer object is bound for
            glbuffersubdata, which must be one of the buffer binding targets in
            the following table:.
        offset: the offset into the buffer object's data store where data
            replacement will begin, measured in bytes.
        size: the size in bytes of the data store region being replaced.
        data: a pointer to the new data that will be copied into the data store.
    '''

@accepts(t.enum)
@returns(t.enum)
@binds(dll)
def check_framebuffer_status(target):
    '''
    check the completeness status of a framebuffer.
    
    gl.check_framebuffer_status and gl.check_named_framebuffer_status return the
    completeness status of a framebuffer object when treated as a read or draw
    framebuffer, depending on the value of target.
    
    Args:
        target: the target to which the framebuffer is bound for
            glcheckframebufferstatus, and the target against which framebuffer
            completeness of framebuffer is checked for
            glchecknamedframebufferstatus.
    '''

@accepts(t.bitfield)
@returns(t.void)
@binds(dll)
def clear(mask):
    '''
    clear buffers to preset values.
    
    gl.clear sets the bitplane area of the window to values previously selected
    by gl.clear_color, gl.clear_depth, and gl.clear_stencil. Multiple color
    buffers can be cleared simultaneously by selecting more than one buffer at a
    time using gl.draw_buffer.
    
    Args:
        mask: bitwise or of masks that indicate the buffers to be cleared.
    '''

@accepts(t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def clear_color(red, green, blue, alpha):
    '''
    specify clear values for the color buffers.
    
    gl.clear_color specifies the red, green, blue, and alpha values used by
    gl.clear to clear the color buffers. Values specified by gl.clear_color are
    clamped to the range 0 1.
    
    Args:
        red: the red, green, blue, and alpha values used when the color buffers
            are cleared.
        green: the red, green, blue, and alpha values used when the color
            buffers are cleared.
        blue: the red, green, blue, and alpha values used when the color buffers
            are cleared.
        alpha: the red, green, blue, and alpha values used when the color
            buffers are cleared.
    '''

@accepts(t.float)
@returns(t.void)
@binds(dll)
def clear_depthf(d):
    pass

@accepts(t.int)
@returns(t.void)
@binds(dll)
def clear_stencil(s):
    '''
    specify the clear value for the stencil buffer.
    
    gl.clear_stencil specifies the index used by gl.clear to clear the stencil
    buffer. s is masked with 2 m - 1 , where.
    
    Args:
        s: the index used when the stencil buffer is cleared.
    '''

@accepts(t.boolean, t.boolean, t.boolean, t.boolean)
@returns(t.void)
@binds(dll)
def color_mask(red, green, blue, alpha):
    '''
    enable and disable writing of frame buffer color components.
    
    gl.color_mask and gl.color_maski specify whether the individual color
    components in the frame buffer can or cannot be written. gl.color_maski sets
    the mask for a specific draw buffer, whereas gl.color_mask sets the mask for
    all draw buffers. If red is gl.FALSE, for example, no change is made to the
    red component of any pixel in any of the color buffers, regardless of the
    drawing operation attempted.
    
    Args:
        red: whether red, green, blue, and alpha are to be written into the
            frame buffer.
        green: whether red, green, blue, and alpha are to be written into the
            frame buffer.
        blue: whether red, green, blue, and alpha are to be written into the
            frame buffer.
        alpha: whether red, green, blue, and alpha are to be written into the
            frame buffer.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def compile_shader(shader):
    '''
    Compiles a shader object.
    
    gl.compile_shader compiles the source code strings that have been stored in
    the shader object specified by shader.
    
    Args:
        shader: the shader object to be compiled.
    '''

@accepts(t.enum, t.int, t.enum, t.sizei, t.sizei, t.int, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def compressed_tex_image2_d(target, level, internalformat, width, height, border, imagesize, data):
    '''
    specify a two-dimensional texture image in a compressed format.
    
    Args:
        target: the target texture.
        level: the level-of-detail number.
        internalformat: the format of the compressed image data stored at
            address data.
        width: the width of the texture image.
        height: the height of the texture image.
        border: this value must be 0.
        imagesize: the number of unsigned bytes of image data starting at the
            address specified by data.
        data: a pointer to the compressed image data in memory.
    '''

@accepts(t.enum, t.int, t.int, t.int, t.sizei, t.sizei, t.enum, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def compressed_tex_sub_image2_d(target, level, xoffset, yoffset, width, height, format, imagesize, data):
    '''
    specify a two-dimensional texture subimage in a compressed format.
    
    Args:
        target: the target to which the texture is bound for
            glcompressedtexsubimage2d function.
        level: the level-of-detail number.
        xoffset: a texel offset in the x direction within the texture array.
        yoffset: a texel offset in the y direction within the texture array.
        width: the width of the texture subimage.
        height: the height of the texture subimage.
        format: the format of the compressed image data stored at address data.
        imagesize: the number of unsigned bytes of image data starting at the
            address specified by data.
        data: a pointer to the compressed image data in memory.
    '''

@accepts(t.enum, t.int, t.enum, t.int, t.int, t.sizei, t.sizei, t.int)
@returns(t.void)
@binds(dll)
def copy_tex_image2_d(target, level, internalformat, x, y, width, height, border):
    '''
    copy pixels into a 2D texture image.
    
    Args:
        target: the target texture.
        level: the level-of-detail number.
        internalformat: the internal format of the texture.
        x: the window coordinates of the lower left corner of the rectangular
            region of pixels to be copied.
        y: the window coordinates of the lower left corner of the rectangular
            region of pixels to be copied.
        width: the width of the texture image.
        height: the height of the texture image.
        border: must be 0.
    '''

@accepts(t.enum, t.int, t.int, t.int, t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def copy_tex_sub_image2_d(target, level, xoffset, yoffset, x, y, width, height):
    '''
    copy a two-dimensional texture subimage.
    
    Args:
        target: the target to which the texture object is bound for
            glcopytexsubimage2d function.
        level: the level-of-detail number.
        xoffset: a texel offset in the x direction within the texture array.
        yoffset: a texel offset in the y direction within the texture array.
        x: the window coordinates of the lower left corner of the rectangular
            region of pixels to be copied.
        y: the window coordinates of the lower left corner of the rectangular
            region of pixels to be copied.
        width: the width of the texture subimage.
        height: the height of the texture subimage.
    '''

@accepts()
@returns(t.uint)
@binds(dll)
def create_program():
    '''
    Creates a program object.
    '''

@accepts(t.enum)
@returns(t.uint)
@binds(dll)
def create_shader(type):
    '''
    Creates a shader object.
    
    gl.create_shader creates an empty shader object and returns a non-zero value
    by which it can be referenced. A shader object is used to maintain the
    source code strings that define a shader. shaderType indicates the type of
    shader to be created. Five types of shader are supported.
    
    Args:
        type: the type of shader to be created.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def cull_face(mode):
    '''
    specify whether front- or back-facing facets can be culled.
    
    gl.cull_face specifies whether front- or back-facing facets are culled when
    facet culling is enabled. Facet culling is initially disabled. To enable and
    disable facet culling, call the gl.enable and gl.disable commands with the
    argument gl.CULL_FACE. Facets include triangles, quadrilaterals, polygons,
    and rectangles.
    
    Args:
        mode: whether front- or back-facing facets are candidates for culling.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_buffers(n, buffers):
    '''
    delete named buffer objects.
    
    gl.delete_buffers deletes n buffer objects named by the elements of the
    array buffers. After a buffer object is deleted, it has no contents, and its
    name is free for reuse. If a buffer object that is currently bound is
    deleted, the binding reverts to 0.
    
    Args:
        n: the number of buffer objects to be deleted.
        buffers: an array of buffer objects to be deleted.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_framebuffers(n, framebuffers):
    '''
    delete framebuffer objects.
    
    gl.delete_framebuffers deletes the n framebuffer objects whose names are
    stored in the array addressed by framebuffers. The name zero is reserved by
    the GL and is silently ignored, should it occur in framebuffers, as are
    other unused names. Once a framebuffer object is deleted, its name is again
    unused and it has no attachments. If a framebuffer that is currently bound
    to one or more of the targets gl.DRAW_FRAMEBUFFER or gl.READ_FRAMEBUFFER is
    deleted, it is as though gl.bind_framebuffer had been executed with the
    corresponding target and framebuffer zero.
    
    Args:
        n: the number of framebuffer objects to be deleted.
        framebuffers: a pointer to an array containing n framebuffer objects to
            be deleted.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def delete_program(program):
    '''
    Deletes a program object.
    
    gl.delete_program frees the memory and invalidates the name associated with
    the program object specified by program. This command effectively undoes the
    effects of a call to gl.create_program.
    
    Args:
        program: the program object to be deleted.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_renderbuffers(n, renderbuffers):
    '''
    delete renderbuffer objects.
    
    gl.delete_renderbuffers deletes the n renderbuffer objects whose names are
    stored in the array addressed by renderbuffers. The name zero is reserved by
    the GL and is silently ignored, should it occur in renderbuffers, as are
    other unused names. Once a renderbuffer object is deleted, its name is again
    unused and it has no contents. If a renderbuffer that is currently bound to
    the target gl.RENDERBUFFER is deleted, it is as though gl.bind_renderbuffer
    had been executed with a target of gl.RENDERBUFFER and a name of zero.
    
    Args:
        n: the number of renderbuffer objects to be deleted.
        renderbuffers: a pointer to an array containing n renderbuffer objects
            to be deleted.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def delete_shader(shader):
    '''
    Deletes a shader object.
    
    gl.delete_shader frees the memory and invalidates the name associated with
    the shader object specified by shader. This command effectively undoes the
    effects of a call to gl.create_shader.
    
    Args:
        shader: the shader object to be deleted.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def delete_textures(n, textures):
    '''
    delete named textures.
    
    gl.delete_textures deletes n textures named by the elements of the array
    textures. After a texture is deleted, it has no contents or dimensionality,
    and its name is free for reuse. If a texture that is currently bound is
    deleted, the binding reverts to 0.
    
    Args:
        n: the number of textures to be deleted.
        textures: an array of textures to be deleted.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def depth_func(func):
    '''
    specify the value used for depth buffer comparisons.
    
    gl.depth_func specifies the function used to compare each incoming pixel
    depth value with the depth value present in the depth buffer. The comparison
    is performed only if depth testing is enabled.
    
    Args:
        func: the depth comparison function.
    '''

@accepts(t.boolean)
@returns(t.void)
@binds(dll)
def depth_mask(flag):
    '''
    enable or disable writing into the depth buffer.
    
    gl.depth_mask specifies whether the depth buffer is enabled for writing. If
    flag is gl.FALSE, depth buffer writing is disabled. Otherwise, it is
    enabled. Initially, depth buffer writing is enabled.
    
    Args:
        flag: whether the depth buffer is enabled for writing.
    '''

@accepts(t.float, t.float)
@returns(t.void)
@binds(dll)
def depth_rangef(n, f):
    pass

@accepts(t.uint, t.uint)
@returns(t.void)
@binds(dll)
def detach_shader(program, shader):
    '''
    Detaches a shader object from a program object to which it is attached.
    
    gl.detach_shader detaches the shader object specified by shader from the
    program object specified by program. This command can be used to undo the
    effect of the command gl.attach_shader.
    
    Args:
        program: the program object from which to detach the shader object.
        shader: the shader object to be detached.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def disable(cap):
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def disable_vertex_attrib_array(index):
    pass

@accepts(t.enum, t.int, t.sizei)
@returns(t.void)
@binds(dll)
def draw_arrays(mode, first, count):
    '''
    render primitives from array data.
    
    gl.draw_arrays specifies multiple geometric primitives with very few
    subroutine calls. Instead of calling a GL procedure to pass each individual
    vertex, normal, texture coordinate, edge flag, or color, you can prespecify
    separate arrays of vertices, normals, and colors and use them to construct a
    sequence of primitives with a single call to gl.draw_arrays.
    
    Args:
        mode: what kind of primitives to render.
        first: the starting index in the enabled arrays.
        count: the number of indices to be rendered.
    '''

@accepts(t.enum, t.sizei, t.enum, t.void)
@returns(t.void)
@binds(dll)
def draw_elements(mode, count, type, indices):
    '''
    render primitives from array data.
    
    gl.draw_elements specifies multiple geometric primitives with very few
    subroutine calls. Instead of calling a GL function to pass each individual
    vertex, normal, texture coordinate, edge flag, or color, you can prespecify
    separate arrays of vertices, normals, and so on, and use them to construct a
    sequence of primitives with a single call to gl.draw_elements.
    
    Args:
        mode: what kind of primitives to render.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def enable(cap):
    '''
    enable or disable server-side GL capabilities.
    
    gl.enable and gl.disable enable and disable various capabilities. Use
    gl.is_enabled or gl.get to determine the current setting of any capability.
    The initial value for each capability with the exception of gl.DITHER and
    gl.MULTISAMPLE is gl.FALSE. The initial value for gl.DITHER and
    gl.MULTISAMPLE is gl.TRUE.
    
    Args:
        cap: a symbolic constant indicating a gl capability.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def enable_vertex_attrib_array(index):
    '''
    Enable or disable a generic vertex attribute array.
    
    gl.enable_vertex_attrib_array and gl.enable_vertex_array_attrib enable the
    generic vertex attribute array specified by index.
    gl.enable_vertex_attrib_array uses currently bound vertex array object for
    the operation, whereas gl.enable_vertex_array_attrib updates state of the
    vertex array object with ID vaobj.
    
    Args:
        index: the index of the generic vertex attribute to be enabled or
            disabled.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def finish():
    '''
    block until all GL execution is complete.
    
    gl.finish requires a round trip to the server.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def flush():
    '''
    force execution of GL commands in finite time.
    
    gl.flush can return at any time. It does not wait until the execution of all
    previously issued GL commands is complete.
    '''

@accepts(t.enum, t.enum, t.enum, t.uint)
@returns(t.void)
@binds(dll)
def framebuffer_renderbuffer(target, attachment, renderbuffertarget, renderbuffer):
    '''
    attach a renderbuffer as a logical buffer of a framebuffer object.
    
    gl.framebuffer_renderbuffer and gl.named_framebuffer_renderbuffer attaches a
    renderbuffer as one of the logical buffers of the specified framebuffer
    object. Renderbuffers cannot be attached to the default draw and read
    framebuffer, so they are not valid targets of these commands.
    
    Args:
        target: the target to which the framebuffer is bound for
            glframebufferrenderbuffer.
        attachment: the attachment point of the framebuffer.
        renderbuffertarget: the renderbuffer target.
        renderbuffer: the name of an existing renderbuffer object of type
            renderbuffertarget to attach.
    '''

@accepts(t.enum, t.enum, t.enum, t.uint, t.int)
@returns(t.void)
@binds(dll)
def framebuffer_texture2_d(target, attachment, textarget, texture, level):
    pass

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def front_face(mode):
    '''
    define front- and back-facing polygons.
    
    Args:
        mode: the orientation of front-facing polygons.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_buffers(n, buffers):
    '''
    generate buffer object names.
    
    gl.gen_buffers returns n buffer object names in buffers. There is no
    guarantee that the names form a contiguous set of integers; however, it is
    guaranteed that none of the returned names was in use immediately before the
    call to gl.gen_buffers.
    
    Args:
        n: the number of buffer object names to be generated.
        buffers: an array in which the generated buffer object names are stored.
    '''

@accepts(t.enum)
@returns(t.void)
@binds(dll)
def generate_mipmap(target):
    '''
    generate mipmaps for a specified texture object.
    
    gl.generate_mipmap and gl.generate_texture_mipmap generates mipmaps for the
    specified texture object. For gl.generate_mipmap, the texture object is that
    bound to to target. For gl.generate_texture_mipmap, texture is the name of
    the texture object.
    
    Args:
        target: the target to which the texture object is bound for
            glgeneratemipmap.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_framebuffers(n, framebuffers):
    '''
    generate framebuffer object names.
    
    gl.gen_framebuffers returns n framebuffer object names in ids. There is no
    guarantee that the names form a contiguous set of integers; however, it is
    guaranteed that none of the returned names was in use immediately before the
    call to gl.gen_framebuffers.
    
    Args:
        n: the number of framebuffer object names to generate.
        framebuffers: an array in which the generated framebuffer object names
            are stored.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_renderbuffers(n, renderbuffers):
    '''
    generate renderbuffer object names.
    
    gl.gen_renderbuffers returns n renderbuffer object names in renderbuffers.
    There is no guarantee that the names form a contiguous set of integers;
    however, it is guaranteed that none of the returned names was in use
    immediately before the call to gl.gen_renderbuffers.
    
    Args:
        n: the number of renderbuffer object names to generate.
        renderbuffers: an array in which the generated renderbuffer object names
            are stored.
    '''

@accepts(t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def gen_textures(n, textures):
    '''
    generate texture names.
    
    gl.gen_textures returns n texture names in textures. There is no guarantee
    that the names form a contiguous set of integers; however, it is guaranteed
    that none of the returned names was in use immediately before the call to
    gl.gen_textures.
    
    Args:
        n: the number of texture names to be generated.
        textures: an array in which the generated texture names are stored.
    '''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.int), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_attrib(program, index, bufsize, length, size, type, name):
    '''
    Returns information about an active attribute variable for the specified program
object.
    
    gl.get_active_attrib returns information about an active attribute variable
    in the program object specified by program. The number of active attributes
    can be obtained by calling gl.get_program with the value
    gl.ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active
    attribute variable. Permissible values for index range from zero to the
    number of active attribute variables minus one.
    
    Args:
        program: the program object to be queried.
        index: the index of the attribute variable to be queried.
        bufsize: the maximum number of characters opengl is allowed to write in
            the character buffer indicated by name.
        length: returns the number of characters actually written by opengl in
            the string indicated by name (excluding the null terminator) if a
            value other than null is passed.
        size: returns the size of the attribute variable.
        type: returns the data type of the attribute variable.
        name: returns a null terminated string containing the name of the
            attribute variable.
    '''

@accepts(t.uint, t.uint, t.sizei, POINTER(t.sizei), POINTER(t.int), POINTER(t.enum), t.char_p)
@returns(t.void)
@binds(dll)
def get_active_uniform(program, index, bufsize, length, size, type, name):
    '''
    Returns information about an active uniform variable for the specified program
object.
    
    gl.get_active_uniform returns information about an active uniform variable
    in the program object specified by program. The number of active uniform
    variables can be obtained by calling gl.get_program with the value
    gl.ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform
    variable. Permissible values for index range from zero to the number of
    active uniform variables minus one.
    
    Args:
        program: the program object to be queried.
        index: the index of the uniform variable to be queried.
        bufsize: the maximum number of characters opengl is allowed to write in
            the character buffer indicated by name.
        length: returns the number of characters actually written by opengl in
            the string indicated by name (excluding the null terminator) if a
            value other than null is passed.
        size: returns the size of the uniform variable.
        type: returns the data type of the uniform variable.
        name: returns a null terminated string containing the name of the
            uniform variable.
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_attached_shaders(program, maxcount, count, shaders):
    '''
    Returns the handles of the shader objects attached to a program object.
    
    gl.get_attached_shaders returns the names of the shader objects attached to
    program. The names of shader objects that are attached to program will be
    returned in shaders. The actual number of shader names written into shaders
    is returned in count. If no shader objects are attached to program, count is
    set to 0.
    
    Args:
        program: the program object to be queried.
        maxcount: the size of the array for storing the returned object names.
        count: returns the number of names actually returned in shaders.
        shaders: an array that is used to return the names of attached shader
            objects.
    '''

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_attrib_location(program, name):
    '''
    Returns the location of an attribute variable.
    
    gl.get_attrib_location queries the previously linked program object
    specified by program for the attribute variable specified by name and
    returns the index of the generic vertex attribute that is bound to that
    attribute variable. If name is a matrix attribute variable, the index of the
    first column of the matrix is returned. If the named attribute variable is
    not an active attribute in the specified program object or if name starts
    with the reserved prefix "gl_", a value of -1 is returned.
    
    Args:
        program: the program object to be queried.
        name: points to a null terminated string containing the name of the
            attribute variable whose location is to be queried.
    '''

@accepts(t.enum, POINTER(t.boolean))
@returns(t.void)
@binds(dll)
def get_booleanv(pname, data):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_buffer_parameteriv(target, pname, params):
    '''
    return parameters of a buffer object.
    
    gl.get_buffer_parameteriv returns in data a selected parameter of the buffer
    object specified by target.
    
    Args:
        target: the target buffer object.
        pname: the symbolic name of a buffer object parameter.
        params: returns the requested parameter.
    '''

@accepts()
@returns(t.enum)
@binds(dll)
def get_error():
    '''
    return error information.
    '''

@accepts(t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_floatv(pname, data):
    pass

@accepts(t.enum, t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_framebuffer_attachment_parameteriv(target, attachment, pname, params):
    pass

@accepts(t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_integerv(pname, data):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_programiv(program, pname, params):
    pass

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_program_info_log(program, bufsize, length, infolog):
    '''
    Returns the information log for a program object.
    
    gl.get_program_info_log returns the information log for the specified
    program object. The information log for a program object is modified when
    the program object is linked or validated. The string that is returned will
    be null terminated.
    
    Args:
        program: the program object whose information log is to be queried.
        bufsize: the size of the character buffer for storing the returned
            information log.
        length: returns the length of the string returned in infolog (excluding
            the null terminator).
        infolog: an array of characters that is used to return the information
            log.
    '''

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_renderbuffer_parameteriv(target, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_shaderiv(shader, pname, params):
    pass

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_shader_info_log(shader, bufsize, length, infolog):
    '''
    Returns the information log for a shader object.
    
    gl.get_shader_info_log returns the information log for the specified shader
    object. The information log for a shader object is modified when the shader
    is compiled. The string that is returned will be null terminated.
    
    Args:
        shader: the shader object whose information log is to be queried.
        bufsize: the size of the character buffer for storing the returned
            information log.
        length: returns the length of the string returned in infolog (excluding
            the null terminator).
        infolog: an array of characters that is used to return the information
            log.
    '''

@accepts(t.enum, t.enum, POINTER(t.int), POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_shader_precision_format(shadertype, precisiontype, range, precision):
    '''
    retrieve the range and precision for numeric formats supported by the shader
compiler.
    
    gl.get_shader_precision_format retrieves the numeric range and precision for
    the implementation's representation of quantities in different numeric
    formats in specified shader type. shaderType specifies the type of shader
    for which the numeric precision and range is to be retrieved and must be one
    of gl.VERTEX_SHADER or gl.FRAGMENT_SHADER. precisionType specifies the
    numeric format to query and must be one of gl.LOW_FLOAT, gl.MEDIUM_FLOAT
    gl.HIGH_FLOAT, gl.LOW_INT, gl.MEDIUM_INT, or gl.HIGH_INT.
    
    Args:
        shadertype: the type of shader whose precision to query.
        precisiontype: the numeric format whose precision and range to query.
        range: the address of array of two integers into which encodings of the
            implementation's numeric range are returned.
        precision: the address of an integer into which the numeric precision of
            the implementation is written.
    '''

@accepts(t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_shader_source(shader, bufsize, length, source):
    '''
    Returns the source code string from a shader object.
    
    gl.get_shader_source returns the concatenation of the source code strings
    from the shader object specified by shader. The source code strings for a
    shader object are the result of a previous call to gl.shader_source. The
    string returned by the function will be null terminated.
    
    Args:
        shader: the shader object to be queried.
        bufsize: the size of the character buffer for storing the returned
            source code string.
        length: returns the length of the string returned in source (excluding
            the null terminator).
        source: an array of characters that is used to return the source code
            string.
    '''

@accepts(t.enum)
@returns(POINTER(t.ubyte))
@binds(dll)
def get_string(name):
    '''
    return a string describing the current GL connection.
    
    gl.get_string returns a pointer to a static string describing some aspect of
    the current GL connection.
    
    Args:
        name: a symbolic constant, one of gl_vendor, gl_renderer, gl_version, or
            gl_shading_language_version.
    '''

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_tex_parameterfv(target, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_tex_parameteriv(target, pname, params):
    pass

@accepts(t.uint, t.int, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_uniformfv(program, location, params):
    pass

@accepts(t.uint, t.int, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_uniformiv(program, location, params):
    pass

@accepts(t.uint, t.char_p)
@returns(t.int)
@binds(dll)
def get_uniform_location(program, name):
    '''
    Returns the location of a uniform variable.
    
    gl.get_uniform_location returns an integer that represents the location of a
    specific uniform variable within a program object. name must be a null
    terminated string that contains no white space. name must be an active
    uniform variable name in program that is not a structure, an array of
    structures, or a subcomponent of a vector or a matrix. This function returns
    -1 if name does not correspond to an active uniform variable in program, if
    name starts with the reserved prefix "gl_", or if name is associated with an
    atomic counter or a named uniform block.
    
    Args:
        program: the program object to be queried.
        name: points to a null terminated string containing the name of the
            uniform variable whose location is to be queried.
    '''

@accepts(t.uint, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def get_vertex_attribfv(index, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_vertex_attribiv(index, pname, params):
    pass

@accepts(t.uint, t.enum, t.void)
@returns(t.void)
@binds(dll)
def get_vertex_attrib_pointerv(index, pname, pointer):
    '''
    return the address of the specified generic vertex attribute pointer.
    
    gl.get_vertex_attrib_pointerv returns pointer information. index is the
    generic vertex attribute to be queried, pname is a symbolic constant
    indicating the pointer to be returned, and params is a pointer to a location
    in which to place the returned data.
    
    Args:
        index: the generic vertex attribute parameter to be returned.
        pname: the symbolic name of the generic vertex attribute parameter to be
            returned.
        pointer: returns the pointer value.
    '''

@accepts(t.enum, t.enum)
@returns(t.void)
@binds(dll)
def hint(target, mode):
    '''
    specify implementation-specific hints.
    
    Args:
        target: a symbolic constant indicating the behavior to be controlled.
        mode: a symbolic constant indicating the desired behavior.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_buffer(buffer):
    '''
    determine if a name corresponds to a buffer object.
    
    gl.is_buffer returns gl.TRUE if buffer is currently the name of a buffer
    object. If buffer is zero, or is a non-zero value that is not currently the
    name of a buffer object, or if an error occurs, gl.is_buffer returns
    gl.FALSE.
    
    Args:
        buffer: a value that may be the name of a buffer object.
    '''

@accepts(t.enum)
@returns(t.boolean)
@binds(dll)
def is_enabled(cap):
    '''
    test whether a capability is enabled.
    
    gl.is_enabled returns gl.TRUE if cap is an enabled capability and returns
    gl.FALSE otherwise. Boolean states that are indexed may be tested with
    gl.is_enabledi. For gl.is_enabledi, index specifies the index of the
    capability to test. index must be between zero and the count of indexed
    capabilities for cap.
    
    Args:
        cap: a symbolic constant indicating a gl capability.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_framebuffer(framebuffer):
    '''
    determine if a name corresponds to a framebuffer object.
    
    gl.is_framebuffer returns gl.TRUE if framebuffer is currently the name of a
    framebuffer object. If framebuffer is zero, or if framebuffer is not the
    name of a framebuffer object, or if an error occurs, gl.is_framebuffer
    returns gl.FALSE. If framebuffer is a name returned by gl.gen_framebuffers,
    by that has not yet been bound through a call to gl.bind_framebuffer, then
    the name is not a framebuffer object and gl.is_framebuffer returns gl.FALSE.
    
    Args:
        framebuffer: a value that may be the name of a framebuffer object.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_program(program):
    '''
    Determines if a name corresponds to a program object.
    
    gl.is_program returns gl.TRUE if program is the name of a program object
    previously created with gl.create_program and not yet deleted with
    gl.delete_program. If program is zero or a non-zero value that is not the
    name of a program object, or if an error occurs, gl.is_program returns
    gl.FALSE.
    
    Args:
        program: a potential program object.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_renderbuffer(renderbuffer):
    '''
    determine if a name corresponds to a renderbuffer object.
    
    gl.is_renderbuffer returns gl.TRUE if renderbuffer is currently the name of
    a renderbuffer object. If renderbuffer is zero, or if renderbuffer is not
    the name of a renderbuffer object, or if an error occurs, gl.is_renderbuffer
    returns gl.FALSE. If renderbuffer is a name returned by
    gl.gen_renderbuffers, by that has not yet been bound through a call to
    gl.bind_renderbuffer or gl.framebuffer_renderbuffer, then the name is not a
    renderbuffer object and gl.is_renderbuffer returns gl.FALSE.
    
    Args:
        renderbuffer: a value that may be the name of a renderbuffer object.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_shader(shader):
    '''
    Determines if a name corresponds to a shader object.
    
    gl.is_shader returns gl.TRUE if shader is the name of a shader object
    previously created with gl.create_shader and not yet deleted with
    gl.delete_shader. If shader is zero or a non-zero value that is not the name
    of a shader object, or if an error occurs, gl.is_shader returns gl.FALSE.
    
    Args:
        shader: a potential shader object.
    '''

@accepts(t.uint)
@returns(t.boolean)
@binds(dll)
def is_texture(texture):
    '''
    determine if a name corresponds to a texture.
    
    gl.is_texture returns gl.TRUE if texture is currently the name of a texture.
    If texture is zero, or is a non-zero value that is not currently the name of
    a texture, or if an error occurs, gl.is_texture returns gl.FALSE.
    
    Args:
        texture: a value that may be the name of a texture.
    '''

@accepts(t.float)
@returns(t.void)
@binds(dll)
def line_width(width):
    '''
    specify the width of rasterized lines.
    
    gl.line_width specifies the rasterized width of both aliased and antialiased
    lines. Using a line width other than 1 has different effects, depending on
    whether line antialiasing is enabled. To enable and disable line
    antialiasing, call gl.enable and gl.disable with argument gl.LINE_SMOOTH.
    Line antialiasing is initially disabled.
    
    Args:
        width: the width of rasterized lines.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def link_program(program):
    '''
    Links a program object.
    
    gl.link_program links the program object specified by program. If any shader
    objects of type gl.VERTEX_SHADER are attached to program, they will be used
    to create an executable that will run on the programmable vertex processor.
    If any shader objects of type gl.GEOMETRY_SHADER are attached to program,
    they will be used to create an executable that will run on the programmable
    geometry processor. If any shader objects of type gl.FRAGMENT_SHADER are
    attached to program, they will be used to create an executable that will run
    on the programmable fragment processor.
    
    Args:
        program: the handle of the program object to be linked.
    '''

@accepts(t.enum, t.int)
@returns(t.void)
@binds(dll)
def pixel_storei(pname, param):
    pass

@accepts(t.float, t.float)
@returns(t.void)
@binds(dll)
def polygon_offset(factor, units):
    '''
    set the scale and units used to calculate depth values.
    
    gl.polygon_offset is useful for rendering hidden-line images, for applying
    decals to surfaces, and for rendering solids with highlighted edges.
    
    Args:
        factor: a scale factor that is used to create a variable depth offset
            for each polygon.
        units: is multiplied by an implementation-specific value to create a
            constant depth offset.
    '''

@accepts(t.int, t.int, t.sizei, t.sizei, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def read_pixels(x, y, width, height, format, type, pixels):
    '''
    read a block of pixels from the frame buffer.
    
    gl.read_pixels and gl.readn_pixels return pixel data from the frame buffer,
    starting with the pixel whose lower left corner is at location , into client
    memory starting at location data. Several parameters control the processing
    of the pixel data before it is placed into client memory. These parameters
    are set with gl.pixel_store. This reference page describes the effects on
    gl.read_pixels and gl.readn_pixels of most, but not all of the parameters
    specified by these three commands.
    
    Args:
        x: the window coordinates of the first pixel that is read from the frame
            buffer.
        y: the window coordinates of the first pixel that is read from the frame
            buffer.
        width: the dimensions of the pixel rectangle.
        height: the dimensions of the pixel rectangle.
        format: the format of the pixel data.
        type: the data type of the pixel data.
        pixels: returns the pixel data.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def release_shader_compiler():
    '''
    release resources consumed by the implementation's shader compiler.
    '''

@accepts(t.enum, t.enum, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def renderbuffer_storage(target, internalformat, width, height):
    '''
    establish data storage, format and dimensions of a renderbuffer object's image.
    
    gl.renderbuffer_storage is equivalent to calling
    gl.renderbuffer_storage_multisample with the samples set to zero, and
    gl.named_renderbuffer_storage is equivalent to calling
    gl.named_renderbuffer_storage_multisample with the samples set to zero.
    
    Args:
        target: a binding target of the allocation for glrenderbufferstorage
            function.
        internalformat: the internal format to use for the renderbuffer object's
            image.
        width: the width of the renderbuffer, in pixels.
        height: the height of the renderbuffer, in pixels.
    '''

@accepts(t.float, t.boolean)
@returns(t.void)
@binds(dll)
def sample_coverage(value, invert):
    '''
    specify multisample coverage parameters.
    
    Args:
        value: a single floating-point sample coverage value.
        invert: a single boolean value representing if the coverage masks should
            be inverted.
    '''

@accepts(t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def scissor(x, y, width, height):
    '''
    define the scissor box.
    
    gl.scissor defines a rectangle, called the scissor box, in window
    coordinates. The first two arguments, x and y, specify the lower left corner
    of the box. width and height specify the width and height of the box.
    
    Args:
        x: the lower left corner of the scissor box.
        y: the lower left corner of the scissor box.
        width: the width and height of the scissor box.
        height: the width and height of the scissor box.
    '''

@accepts(t.sizei, POINTER(t.uint), t.enum, t.void, t.sizei)
@returns(t.void)
@binds(dll)
def shader_binary(count, shaders, binaryformat, binary, length):
    '''
    load pre-compiled shader binaries.
    
    gl.shader_binary loads pre-compiled shader binary code into the count shader
    objects whose handles are given in shaders. binary points to length bytes of
    binary shader code stored in client memory. binaryFormat specifies the
    format of the pre-compiled code.
    
    Args:
        count: the number of shader object handles contained in shaders.
        shaders: the address of an array of shader handles into which to load
            pre-compiled shader binaries.
        binaryformat: the format of the shader binaries contained in binary.
        binary: the address of an array of bytes containing pre-compiled binary
            shader code.
        length: the length of the array whose address is given in binary.
    '''

@accepts(t.uint, t.sizei, POINTER(t.char_p), POINTER(t.int))
@returns(t.void)
@binds(dll)
def shader_source(shader, count, string, length):
    '''
    Replaces the source code in a shader object.
    
    gl.shader_source sets the source code in shader to the source code in the
    array of strings specified by string. Any source code previously stored in
    the shader object is completely replaced. The number of strings in the array
    is specified by count. If length is None, each string is assumed to be null
    terminated.
    
    Args:
        shader: the handle of the shader object whose source code is to be
            replaced.
        count: the number of elements in the string and length arrays.
        string: an array of pointers to strings containing the source code to be
            loaded into the shader.
        length: an array of string lengths.
    '''

@accepts(t.enum, t.int, t.uint)
@returns(t.void)
@binds(dll)
def stencil_func(func, ref, mask):
    '''
    set front and back function and reference value for stencil testing.
    
    Args:
        func: the test function.
        ref: the reference value for the stencil test.
        mask: a mask that is anded with both the reference value and the stored
            stencil value when the test is done.
    '''

@accepts(t.enum, t.enum, t.int, t.uint)
@returns(t.void)
@binds(dll)
def stencil_func_separate(face, func, ref, mask):
    '''
    set front and/or back function and reference value for stencil testing.
    
    Args:
        face: whether front and/or back stencil state is updated.
        func: the test function.
        ref: the reference value for the stencil test.
        mask: a mask that is anded with both the reference value and the stored
            stencil value when the test is done.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def stencil_mask(mask):
    '''
    control the front and back writing of individual bits in the stencil planes.
    
    gl.stencil_mask controls the writing of individual bits in the stencil
    planes. The least significant n bits of mask, where.
    
    Args:
        mask: a bit mask to enable and disable writing of individual bits in the
            stencil planes.
    '''

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def stencil_mask_separate(face, mask):
    '''
    control the front and/or back writing of individual bits in the stencil planes.
    
    gl.stencil_mask_separate controls the writing of individual bits in the
    stencil planes. The least significant n bits of mask, where.
    
    Args:
        face: whether the front and/or back stencil writemask is updated.
        mask: a bit mask to enable and disable writing of individual bits in the
            stencil planes.
    '''

@accepts(t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def stencil_op(fail, zfail, zpass):
    '''
    set front and back stencil test actions.
    
    gl.stencil_op takes three arguments that indicate what happens to the stored
    stencil value while stenciling is enabled. If the stencil test fails, no
    change is made to the pixel's color or depth buffers, and sfail specifies
    what happens to the stencil buffer contents. The following eight actions are
    possible.
    
    Args:
        fail: the action to take when the stencil test fails.
        zfail: the stencil action when the stencil test passes, but the depth
            test fails.
        zpass: the stencil action when both the stencil test and the depth test
            pass, or when the stencil test passes and either there is no depth
            buffer or depth testing is not enabled.
    '''

@accepts(t.enum, t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def stencil_op_separate(face, sfail, dpfail, dppass):
    '''
    set front and/or back stencil test actions.
    
    gl.stencil_op_separate takes three arguments that indicate what happens to
    the stored stencil value while stenciling is enabled. If the stencil test
    fails, no change is made to the pixel's color or depth buffers, and sfail
    specifies what happens to the stencil buffer contents. The following eight
    actions are possible.
    
    Args:
        face: whether front and/or back stencil state is updated.
        sfail: the action to take when the stencil test fails.
        dpfail: the stencil action when the stencil test passes, but the depth
            test fails.
        dppass: the stencil action when both the stencil test and the depth test
            pass, or when the stencil test passes and either there is no depth
            buffer or depth testing is not enabled.
    '''

@accepts(t.enum, t.int, t.int, t.sizei, t.sizei, t.int, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def tex_image2_d(target, level, internalformat, width, height, border, format, type, pixels):
    '''
    specify a two-dimensional texture image.
    
    Args:
        target: the target texture.
        level: the level-of-detail number.
        internalformat: the number of color components in the texture.
        width: the width of the texture image.
        height: the height of the texture image, or the number of layers in a
            texture array, in the case of the gl_texture_1d_array and
            gl_proxy_texture_1d_array targets.
        border: this value must be 0.
        format: the format of the pixel data.
        type: the data type of the pixel data.
        pixels: a pointer to the image data in memory.
    '''

@accepts(t.enum, t.enum, t.float)
@returns(t.void)
@binds(dll)
def tex_parameterf(target, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.float))
@returns(t.void)
@binds(dll)
def tex_parameterfv(target, pname, params):
    pass

@accepts(t.enum, t.enum, t.int)
@returns(t.void)
@binds(dll)
def tex_parameteri(target, pname, param):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_parameteriv(target, pname, params):
    pass

@accepts(t.enum, t.int, t.int, t.int, t.sizei, t.sizei, t.enum, t.enum, t.void)
@returns(t.void)
@binds(dll)
def tex_sub_image2_d(target, level, xoffset, yoffset, width, height, format, type, pixels):
    '''
    specify a two-dimensional texture subimage.
    
    Args:
        target: the target to which the texture is bound for gltexsubimage2d.
        level: the level-of-detail number.
        xoffset: a texel offset in the x direction within the texture array.
        yoffset: a texel offset in the y direction within the texture array.
        width: the width of the texture subimage.
        height: the height of the texture subimage.
        format: the format of the pixel data.
        type: the data type of the pixel data.
        pixels: a pointer to the image data in memory.
    '''

@accepts(t.int, t.float)
@returns(t.void)
@binds(dll)
def uniform1f(location, v0):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform1fv(location, count, value):
    pass

@accepts(t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform1i(location, v0):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform1iv(location, count, value):
    pass

@accepts(t.int, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform2f(location, v0, v1):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform2fv(location, count, value):
    pass

@accepts(t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform2i(location, v0, v1):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform2iv(location, count, value):
    pass

@accepts(t.int, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform3f(location, v0, v1, v2):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform3fv(location, count, value):
    pass

@accepts(t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform3i(location, v0, v1, v2):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform3iv(location, count, value):
    pass

@accepts(t.int, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def uniform4f(location, v0, v1, v2, v3):
    pass

@accepts(t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform4fv(location, count, value):
    pass

@accepts(t.int, t.int, t.int, t.int, t.int)
@returns(t.void)
@binds(dll)
def uniform4i(location, v0, v1, v2, v3):
    pass

@accepts(t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def uniform4iv(location, count, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix2fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix3fv(location, count, transpose, value):
    pass

@accepts(t.int, t.sizei, t.boolean, POINTER(t.float))
@returns(t.void)
@binds(dll)
def uniform_matrix4fv(location, count, transpose, value):
    pass

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def use_program(program):
    '''
    Installs a program object as part of current rendering state.
    
    gl.use_program installs the program object specified by program as part of
    current rendering state. One or more executables are created in a program
    object by successfully attaching shader objects to it with gl.attach_shader,
    successfully compiling the shader objects with gl.compile_shader, and
    successfully linking the program object with gl.link_program.
    
    Args:
        program: the handle of the program object whose executables are to be
            used as part of current rendering state.
    '''

@accepts(t.uint)
@returns(t.void)
@binds(dll)
def validate_program(program):
    '''
    Validates a program object.
    
    gl.validate_program checks to see whether the executables contained in
    program can execute given the current OpenGL state. The information
    generated by the validation process will be stored in program's information
    log. The validation information may consist of an empty string, or it may be
    a string containing information about how the current program object
    interacts with the rest of current OpenGL state. This provides a way for
    OpenGL implementers to convey more information about why the current program
    is inefficient, suboptimal, failing to execute, and so on.
    
    Args:
        program: the handle of the program object to be validated.
    '''

@accepts(t.uint, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib1f(index, x):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib1fv(index, v):
    pass

@accepts(t.uint, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib2f(index, x, y):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib2fv(index, v):
    pass

@accepts(t.uint, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib3f(index, x, y, z):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib3fv(index, v):
    pass

@accepts(t.uint, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def vertex_attrib4f(index, x, y, z, w):
    pass

@accepts(t.uint, POINTER(t.float))
@returns(t.void)
@binds(dll)
def vertex_attrib4fv(index, v):
    pass

@accepts(t.uint, t.int, t.enum, t.boolean, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def vertex_attrib_pointer(index, size, type, normalized, stride, pointer):
    '''
    define an array of generic vertex attribute data.
    
    gl.vertex_attrib_pointer, gl.vertex_attrib_i_pointer and
    gl.vertex_attrib_l_pointer specify the location and data format of the array
    of generic vertex attributes at index index to use when rendering. size
    specifies the number of components per attribute and must be 1, 2, 3, 4, or
    gl.BGRA. type specifies the data type of each component, and stride
    specifies the byte stride from one attribute to the next, allowing vertices
    and attributes to be packed into a single array or stored in separate
    arrays.
    
    Args:
        index: the index of the generic vertex attribute to be modified.
        size: the number of components per generic vertex attribute.
        type: the data type of each component in the array.
        normalized: for glvertexattribpointer, specifies whether fixed-point
            data values should be normalized (gl_true) or converted directly as
            fixed-point values (gl_false) when they are accessed.
        stride: the byte offset between consecutive generic vertex attributes.
        pointer: a offset of the first component of the first generic vertex
            attribute in the array in the data store of the buffer currently
            bound to the gl_array_buffer target.
    '''

@accepts(t.int, t.int, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def viewport(x, y, width, height):
    '''
    set the viewport.
    
    gl.viewport specifies the affine transformation of x and.
    
    Args:
        x: the lower left corner of the viewport rectangle, in pixels.
        y: the lower left corner of the viewport rectangle, in pixels.
        width: the width and height of the viewport.
        height: the width and height of the viewport.
    '''

DEPTH_BUFFER_BIT = 0x00000100
STENCIL_BUFFER_BIT = 0x00000400
COLOR_BUFFER_BIT = 0x00004000
FALSE = 0
TRUE = 1
POINTS = 0x0000
LINES = 0x0001
LINE_LOOP = 0x0002
LINE_STRIP = 0x0003
TRIANGLES = 0x0004
TRIANGLE_STRIP = 0x0005
TRIANGLE_FAN = 0x0006
ZERO = 0
ONE = 1
SRC_COLOR = 0x0300
ONE_MINUS_SRC_COLOR = 0x0301
SRC_ALPHA = 0x0302
ONE_MINUS_SRC_ALPHA = 0x0303
DST_ALPHA = 0x0304
ONE_MINUS_DST_ALPHA = 0x0305
DST_COLOR = 0x0306
ONE_MINUS_DST_COLOR = 0x0307
SRC_ALPHA_SATURATE = 0x0308
FUNC_ADD = 0x8006
BLEND_EQUATION = 0x8009
BLEND_EQUATION_RGB = 0x8009
BLEND_EQUATION_ALPHA = 0x883D
FUNC_SUBTRACT = 0x800A
FUNC_REVERSE_SUBTRACT = 0x800B
BLEND_DST_RGB = 0x80C8
BLEND_SRC_RGB = 0x80C9
BLEND_DST_ALPHA = 0x80CA
BLEND_SRC_ALPHA = 0x80CB
CONSTANT_COLOR = 0x8001
ONE_MINUS_CONSTANT_COLOR = 0x8002
CONSTANT_ALPHA = 0x8003
ONE_MINUS_CONSTANT_ALPHA = 0x8004
BLEND_COLOR = 0x8005
ARRAY_BUFFER = 0x8892
ELEMENT_ARRAY_BUFFER = 0x8893
ARRAY_BUFFER_BINDING = 0x8894
ELEMENT_ARRAY_BUFFER_BINDING = 0x8895
STREAM_DRAW = 0x88E0
STATIC_DRAW = 0x88E4
DYNAMIC_DRAW = 0x88E8
BUFFER_SIZE = 0x8764
BUFFER_USAGE = 0x8765
CURRENT_VERTEX_ATTRIB = 0x8626
FRONT = 0x0404
BACK = 0x0405
FRONT_AND_BACK = 0x0408
TEXTURE_2D = 0x0DE1
CULL_FACE = 0x0B44
BLEND = 0x0BE2
DITHER = 0x0BD0
STENCIL_TEST = 0x0B90
DEPTH_TEST = 0x0B71
SCISSOR_TEST = 0x0C11
POLYGON_OFFSET_FILL = 0x8037
SAMPLE_ALPHA_TO_COVERAGE = 0x809E
SAMPLE_COVERAGE = 0x80A0
NO_ERROR = 0
INVALID_ENUM = 0x0500
INVALID_VALUE = 0x0501
INVALID_OPERATION = 0x0502
OUT_OF_MEMORY = 0x0505
CW = 0x0900
CCW = 0x0901
LINE_WIDTH = 0x0B21
ALIASED_POINT_SIZE_RANGE = 0x846D
ALIASED_LINE_WIDTH_RANGE = 0x846E
CULL_FACE_MODE = 0x0B45
FRONT_FACE = 0x0B46
DEPTH_RANGE = 0x0B70
DEPTH_WRITEMASK = 0x0B72
DEPTH_CLEAR_VALUE = 0x0B73
DEPTH_FUNC = 0x0B74
STENCIL_CLEAR_VALUE = 0x0B91
STENCIL_FUNC = 0x0B92
STENCIL_FAIL = 0x0B94
STENCIL_PASS_DEPTH_FAIL = 0x0B95
STENCIL_PASS_DEPTH_PASS = 0x0B96
STENCIL_REF = 0x0B97
STENCIL_VALUE_MASK = 0x0B93
STENCIL_WRITEMASK = 0x0B98
STENCIL_BACK_FUNC = 0x8800
STENCIL_BACK_FAIL = 0x8801
STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802
STENCIL_BACK_PASS_DEPTH_PASS = 0x8803
STENCIL_BACK_REF = 0x8CA3
STENCIL_BACK_VALUE_MASK = 0x8CA4
STENCIL_BACK_WRITEMASK = 0x8CA5
VIEWPORT = 0x0BA2
SCISSOR_BOX = 0x0C10
COLOR_CLEAR_VALUE = 0x0C22
COLOR_WRITEMASK = 0x0C23
UNPACK_ALIGNMENT = 0x0CF5
PACK_ALIGNMENT = 0x0D05
MAX_TEXTURE_SIZE = 0x0D33
MAX_VIEWPORT_DIMS = 0x0D3A
SUBPIXEL_BITS = 0x0D50
RED_BITS = 0x0D52
GREEN_BITS = 0x0D53
BLUE_BITS = 0x0D54
ALPHA_BITS = 0x0D55
DEPTH_BITS = 0x0D56
STENCIL_BITS = 0x0D57
POLYGON_OFFSET_UNITS = 0x2A00
POLYGON_OFFSET_FACTOR = 0x8038
TEXTURE_BINDING_2D = 0x8069
SAMPLE_BUFFERS = 0x80A8
SAMPLES = 0x80A9
SAMPLE_COVERAGE_VALUE = 0x80AA
SAMPLE_COVERAGE_INVERT = 0x80AB
NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2
COMPRESSED_TEXTURE_FORMATS = 0x86A3
DONT_CARE = 0x1100
FASTEST = 0x1101
NICEST = 0x1102
GENERATE_MIPMAP_HINT = 0x8192
BYTE = 0x1400
UNSIGNED_BYTE = 0x1401
SHORT = 0x1402
UNSIGNED_SHORT = 0x1403
INT = 0x1404
UNSIGNED_INT = 0x1405
FLOAT = 0x1406
FIXED = 0x140C
DEPTH_COMPONENT = 0x1902
ALPHA = 0x1906
RGB = 0x1907
RGBA = 0x1908
LUMINANCE = 0x1909
LUMINANCE_ALPHA = 0x190A
UNSIGNED_SHORT_4_4_4_4 = 0x8033
UNSIGNED_SHORT_5_5_5_1 = 0x8034
UNSIGNED_SHORT_5_6_5 = 0x8363
FRAGMENT_SHADER = 0x8B30
VERTEX_SHADER = 0x8B31
MAX_VERTEX_ATTRIBS = 0x8869
MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB
MAX_VARYING_VECTORS = 0x8DFC
MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D
MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C
MAX_TEXTURE_IMAGE_UNITS = 0x8872
MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD
SHADER_TYPE = 0x8B4F
DELETE_STATUS = 0x8B80
LINK_STATUS = 0x8B82
VALIDATE_STATUS = 0x8B83
ATTACHED_SHADERS = 0x8B85
ACTIVE_UNIFORMS = 0x8B86
ACTIVE_UNIFORM_MAX_LENGTH = 0x8B87
ACTIVE_ATTRIBUTES = 0x8B89
ACTIVE_ATTRIBUTE_MAX_LENGTH = 0x8B8A
SHADING_LANGUAGE_VERSION = 0x8B8C
CURRENT_PROGRAM = 0x8B8D
NEVER = 0x0200
LESS = 0x0201
EQUAL = 0x0202
LEQUAL = 0x0203
GREATER = 0x0204
NOTEQUAL = 0x0205
GEQUAL = 0x0206
ALWAYS = 0x0207
KEEP = 0x1E00
REPLACE = 0x1E01
INCR = 0x1E02
DECR = 0x1E03
INVERT = 0x150A
INCR_WRAP = 0x8507
DECR_WRAP = 0x8508
VENDOR = 0x1F00
RENDERER = 0x1F01
VERSION = 0x1F02
EXTENSIONS = 0x1F03
NEAREST = 0x2600
LINEAR = 0x2601
NEAREST_MIPMAP_NEAREST = 0x2700
LINEAR_MIPMAP_NEAREST = 0x2701
NEAREST_MIPMAP_LINEAR = 0x2702
LINEAR_MIPMAP_LINEAR = 0x2703
TEXTURE_MAG_FILTER = 0x2800
TEXTURE_MIN_FILTER = 0x2801
TEXTURE_WRAP_S = 0x2802
TEXTURE_WRAP_T = 0x2803
TEXTURE = 0x1702
TEXTURE_CUBE_MAP = 0x8513
TEXTURE_BINDING_CUBE_MAP = 0x8514
TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515
TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516
TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517
TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518
TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519
TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A
MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C
TEXTURE0 = 0x84C0
TEXTURE1 = 0x84C1
TEXTURE2 = 0x84C2
TEXTURE3 = 0x84C3
TEXTURE4 = 0x84C4
TEXTURE5 = 0x84C5
TEXTURE6 = 0x84C6
TEXTURE7 = 0x84C7
TEXTURE8 = 0x84C8
TEXTURE9 = 0x84C9
TEXTURE10 = 0x84CA
TEXTURE11 = 0x84CB
TEXTURE12 = 0x84CC
TEXTURE13 = 0x84CD
TEXTURE14 = 0x84CE
TEXTURE15 = 0x84CF
TEXTURE16 = 0x84D0
TEXTURE17 = 0x84D1
TEXTURE18 = 0x84D2
TEXTURE19 = 0x84D3
TEXTURE20 = 0x84D4
TEXTURE21 = 0x84D5
TEXTURE22 = 0x84D6
TEXTURE23 = 0x84D7
TEXTURE24 = 0x84D8
TEXTURE25 = 0x84D9
TEXTURE26 = 0x84DA
TEXTURE27 = 0x84DB
TEXTURE28 = 0x84DC
TEXTURE29 = 0x84DD
TEXTURE30 = 0x84DE
TEXTURE31 = 0x84DF
ACTIVE_TEXTURE = 0x84E0
REPEAT = 0x2901
CLAMP_TO_EDGE = 0x812F
MIRRORED_REPEAT = 0x8370
FLOAT_VEC2 = 0x8B50
FLOAT_VEC3 = 0x8B51
FLOAT_VEC4 = 0x8B52
INT_VEC2 = 0x8B53
INT_VEC3 = 0x8B54
INT_VEC4 = 0x8B55
BOOL = 0x8B56
BOOL_VEC2 = 0x8B57
BOOL_VEC3 = 0x8B58
BOOL_VEC4 = 0x8B59
FLOAT_MAT2 = 0x8B5A
FLOAT_MAT3 = 0x8B5B
FLOAT_MAT4 = 0x8B5C
SAMPLER_2D = 0x8B5E
SAMPLER_CUBE = 0x8B60
VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622
VERTEX_ATTRIB_ARRAY_SIZE = 0x8623
VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624
VERTEX_ATTRIB_ARRAY_TYPE = 0x8625
VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A
VERTEX_ATTRIB_ARRAY_POINTER = 0x8645
VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F
IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A
IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B
COMPILE_STATUS = 0x8B81
INFO_LOG_LENGTH = 0x8B84
SHADER_SOURCE_LENGTH = 0x8B88
SHADER_COMPILER = 0x8DFA
SHADER_BINARY_FORMATS = 0x8DF8
NUM_SHADER_BINARY_FORMATS = 0x8DF9
LOW_FLOAT = 0x8DF0
MEDIUM_FLOAT = 0x8DF1
HIGH_FLOAT = 0x8DF2
LOW_INT = 0x8DF3
MEDIUM_INT = 0x8DF4
HIGH_INT = 0x8DF5
FRAMEBUFFER = 0x8D40
RENDERBUFFER = 0x8D41
RGBA4 = 0x8056
RGB5_A1 = 0x8057
RGB565 = 0x8D62
DEPTH_COMPONENT16 = 0x81A5
STENCIL_INDEX8 = 0x8D48
RENDERBUFFER_WIDTH = 0x8D42
RENDERBUFFER_HEIGHT = 0x8D43
RENDERBUFFER_INTERNAL_FORMAT = 0x8D44
RENDERBUFFER_RED_SIZE = 0x8D50
RENDERBUFFER_GREEN_SIZE = 0x8D51
RENDERBUFFER_BLUE_SIZE = 0x8D52
RENDERBUFFER_ALPHA_SIZE = 0x8D53
RENDERBUFFER_DEPTH_SIZE = 0x8D54
RENDERBUFFER_STENCIL_SIZE = 0x8D55
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0
FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1
FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2
FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3
COLOR_ATTACHMENT0 = 0x8CE0
DEPTH_ATTACHMENT = 0x8D00
STENCIL_ATTACHMENT = 0x8D20
NONE = 0
FRAMEBUFFER_COMPLETE = 0x8CD5
FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6
FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7
FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9
FRAMEBUFFER_UNSUPPORTED = 0x8CDD
FRAMEBUFFER_BINDING = 0x8CA6
RENDERBUFFER_BINDING = 0x8CA7
MAX_RENDERBUFFER_SIZE = 0x84E8
INVALID_FRAMEBUFFER_OPERATION = 0x0506