#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

COPY_READ_BUFFER_BINDING = 0x8F36
COPY_WRITE_BUFFER_BINDING = 0x8F37
TRANSFORM_FEEDBACK_ACTIVE = 0x8E24
TRANSFORM_FEEDBACK_PAUSED = 0x8E23
UNPACK_COMPRESSED_BLOCK_WIDTH = 0x9127
UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128
UNPACK_COMPRESSED_BLOCK_DEPTH = 0x9129
UNPACK_COMPRESSED_BLOCK_SIZE = 0x912A
PACK_COMPRESSED_BLOCK_WIDTH = 0x912B
PACK_COMPRESSED_BLOCK_HEIGHT = 0x912C
PACK_COMPRESSED_BLOCK_DEPTH = 0x912D
PACK_COMPRESSED_BLOCK_SIZE = 0x912E
NUM_SAMPLE_COUNTS = 0x9380
MIN_MAP_BUFFER_ALIGNMENT = 0x90BC
ATOMIC_COUNTER_BUFFER = 0x92C0
ATOMIC_COUNTER_BUFFER_BINDING = 0x92C1
ATOMIC_COUNTER_BUFFER_START = 0x92C2
ATOMIC_COUNTER_BUFFER_SIZE = 0x92C3
ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4
ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5
ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6
ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7
ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8
ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9
ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA
ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB
MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC
MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD
MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE
MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF
MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0
MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1
MAX_VERTEX_ATOMIC_COUNTERS = 0x92D2
MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3
MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4
MAX_GEOMETRY_ATOMIC_COUNTERS = 0x92D5
MAX_FRAGMENT_ATOMIC_COUNTERS = 0x92D6
MAX_COMBINED_ATOMIC_COUNTERS = 0x92D7
MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8
MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC
ACTIVE_ATOMIC_COUNTER_BUFFERS = 0x92D9
UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA
UNSIGNED_INT_ATOMIC_COUNTER = 0x92DB
VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001
ELEMENT_ARRAY_BARRIER_BIT = 0x00000002
UNIFORM_BARRIER_BIT = 0x00000004
TEXTURE_FETCH_BARRIER_BIT = 0x00000008
SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020
COMMAND_BARRIER_BIT = 0x00000040
PIXEL_BUFFER_BARRIER_BIT = 0x00000080
TEXTURE_UPDATE_BARRIER_BIT = 0x00000100
BUFFER_UPDATE_BARRIER_BIT = 0x00000200
FRAMEBUFFER_BARRIER_BIT = 0x00000400
TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800
ATOMIC_COUNTER_BARRIER_BIT = 0x00001000
ALL_BARRIER_BITS = 0xFFFFFFFF
MAX_IMAGE_UNITS = 0x8F38
MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39
IMAGE_BINDING_NAME = 0x8F3A
IMAGE_BINDING_LEVEL = 0x8F3B
IMAGE_BINDING_LAYERED = 0x8F3C
IMAGE_BINDING_LAYER = 0x8F3D
IMAGE_BINDING_ACCESS = 0x8F3E
IMAGE_1D = 0x904C
IMAGE_2D = 0x904D
IMAGE_3D = 0x904E
IMAGE_2D_RECT = 0x904F
IMAGE_CUBE = 0x9050
IMAGE_BUFFER = 0x9051
IMAGE_1D_ARRAY = 0x9052
IMAGE_2D_ARRAY = 0x9053
IMAGE_CUBE_MAP_ARRAY = 0x9054
IMAGE_2D_MULTISAMPLE = 0x9055
IMAGE_2D_MULTISAMPLE_ARRAY = 0x9056
INT_IMAGE_1D = 0x9057
INT_IMAGE_2D = 0x9058
INT_IMAGE_3D = 0x9059
INT_IMAGE_2D_RECT = 0x905A
INT_IMAGE_CUBE = 0x905B
INT_IMAGE_BUFFER = 0x905C
INT_IMAGE_1D_ARRAY = 0x905D
INT_IMAGE_2D_ARRAY = 0x905E
INT_IMAGE_CUBE_MAP_ARRAY = 0x905F
INT_IMAGE_2D_MULTISAMPLE = 0x9060
INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061
UNSIGNED_INT_IMAGE_1D = 0x9062
UNSIGNED_INT_IMAGE_2D = 0x9063
UNSIGNED_INT_IMAGE_3D = 0x9064
UNSIGNED_INT_IMAGE_2D_RECT = 0x9065
UNSIGNED_INT_IMAGE_CUBE = 0x9066
UNSIGNED_INT_IMAGE_BUFFER = 0x9067
UNSIGNED_INT_IMAGE_1D_ARRAY = 0x9068
UNSIGNED_INT_IMAGE_2D_ARRAY = 0x9069
UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A
UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B
UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C
MAX_IMAGE_SAMPLES = 0x906D
IMAGE_BINDING_FORMAT = 0x906E
IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7
IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8
IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9
MAX_VERTEX_IMAGE_UNIFORMS = 0x90CA
MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB
MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC
MAX_GEOMETRY_IMAGE_UNIFORMS = 0x90CD
MAX_FRAGMENT_IMAGE_UNIFORMS = 0x90CE
MAX_COMBINED_IMAGE_UNIFORMS = 0x90CF
COMPRESSED_RGBA_BPTC_UNORM = 0x8E8C
COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 0x8E8D
COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 0x8E8E
COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 0x8E8F
TEXTURE_IMMUTABLE_FORMAT = 0x912F
@accepts(t.enum, t.int, t.sizei, t.sizei, t.uint)
@returns(t.void)
@binds(dll)
def draw_arrays_instanced_base_instance(mode, first, count, instancecount, baseinstance):
    '''
    draw multiple instances of a range of elements with offset applied to instanced
attributes.
    
    gl.draw_arrays_instanced_base_instance behaves identically to gl.draw_arrays
    except that primcount instances of the range of elements are executed and
    the value of the internal counter instanceID advances for each iteration.
    instanceID is an internal 32-bit integer counter that may be read by a
    vertex shader as gl_InstanceID.
    
    Args:
        mode: what kind of primitives to render.
        first: the starting index in the enabled arrays.
        count: the number of indices to be rendered.
        instancecount: the number of instances of the specified range of indices
            to be rendered.
        baseinstance: the base instance for use in fetching instanced vertex
            attributes.
    '''

@accepts(t.enum, t.sizei, t.enum, t.void, t.sizei, t.uint)
@returns(t.void)
@binds(dll)
def draw_elements_instanced_base_instance(mode, count, type, indices, instancecount, baseinstance):
    '''
    draw multiple instances of a set of elements with offset applied to instanced
attributes.
    
    gl.draw_elements_instanced_base_instance behaves identically to
    gl.draw_elements except that primcount instances of the set of elements are
    executed and the value of the internal counter instanceID advances for each
    iteration. instanceID is an internal 32-bit integer counter that may be read
    by a vertex shader as gl_InstanceID.
    
    Args:
        mode: what kind of primitives to render.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        instancecount: the number of instances of the specified range of indices
            to be rendered.
        baseinstance: the base instance for use in fetching instanced vertex
            attributes.
    '''

@accepts(t.enum, t.sizei, t.enum, t.void, t.sizei, t.int, t.uint)
@returns(t.void)
@binds(dll)
def draw_elements_instanced_base_vertex_base_instance(mode, count, type, indices, instancecount, basevertex, baseinstance):
    '''
    render multiple instances of a set of primitives from array data with a per-
element offset.
    
    gl.draw_elements_instanced_base_vertex_base_instance behaves identically to
    gl.draw_elements_instanced except that the ith element transferred by the
    corresponding draw call will be taken from element indices[i] + basevertex
    of each enabled array. If the resulting value is larger than the maximum
    value representable by type, it is as if the calculation were upconverted to
    32-bit unsigned integers. The operation is undefined if the sum would be
    negative. The basevertex has no effect on the shader-visible value of
    gl_VertexID.
    
    Args:
        mode: what kind of primitives to render.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        instancecount: the number of instances of the indexed geometry that
            should be drawn.
        basevertex: a constant that should be added to each element of indices
            when chosing elements from the enabled vertex arrays.
        baseinstance: the base instance for use in fetching instanced vertex
            attributes.
    '''

@accepts(t.enum, t.enum, t.enum, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_internalformativ(target, internalformat, pname, bufsize, params):
    pass

@accepts(t.uint, t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_active_atomic_counter_bufferiv(program, bufferindex, pname, params):
    '''
    retrieve information about the set of active atomic counter buffers for a
program.
    
    gl.get_active_atomic_counter_bufferiv retrieves information about the set of
    active atomic counter buffers for a program object. program is the name of a
    program object for which the command gl.link_program has been issued in the
    past. It is not necessary for program to have been linked successfully. The
    link may have failed because the number of active atomic counters exceeded
    the limits.
    
    Args:
        program: the name of a program object from which to retrieve
            information.
        bufferindex: index of an active atomic counter buffer.
        pname: which parameter of the atomic counter buffer to retrieve.
        params: the address of a variable into which to write the retrieved
            information.
    '''

@accepts(t.uint, t.uint, t.int, t.boolean, t.int, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def bind_image_texture(unit, texture, level, layered, layer, access, format):
    '''
    bind a level of a texture to an image unit.
    
    gl.bind_image_texture binds a single level of a texture to an image unit for
    the purpose of reading and writing it from shaders. unit specifies the zero-
    based index of the image unit to which to bind the texture level. texture
    specifies the name of an existing texture object to bind to the image unit.
    If texture is zero, then any existing binding to the image unit is broken.
    
    Args:
        unit: the index of the image unit to which to bind the texture.
        texture: the name of the texture to bind to the image unit.
        level: the level of the texture that is to be bound.
        layered: whether a layered texture binding is to be established.
        layer: if layered is gl_false, specifies the layer of texture to be
            bound to the image unit.
        access: a token indicating the type of access that will be performed on
            the image.
        format: the format that the elements of the image will be treated as for
            the purposes of formatted stores.
    '''

@accepts(t.bitfield)
@returns(t.void)
@binds(dll)
def memory_barrier(barriers):
    '''
    defines a barrier ordering memory transactions.
    
    gl.memory_barrier defines a barrier ordering the memory transactions issued
    prior to the command relative to those issued after the barrier. For the
    purposes of this ordering, memory transactions performed by shaders are
    considered to be issued by the rendering command that triggered the
    execution of the shader.
    
    Args:
        barriers: the barriers to insert.
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei)
@returns(t.void)
@binds(dll)
def tex_storage1_d(target, levels, internalformat, width):
    '''
    simultaneously specify storage for all levels of a one-dimensional texture.
    
    Args:
        target: the target to which the texture object is bound for
            gltexstorage1d.
        levels: the number of texture levels.
        internalformat: the sized internal format to be used to store texture
            image data.
        width: the width of the texture, in texels.
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def tex_storage2_d(target, levels, internalformat, width, height):
    '''
    simultaneously specify storage for all levels of a two-dimensional or one-
dimensional array texture.
    
    Args:
        target: the target to which the texture object is bound for
            gltexstorage2d.
        levels: the number of texture levels.
        internalformat: the sized internal format to be used to store texture
            image data.
        width: the width of the texture, in texels.
        height: the height of the texture, in texels.
    '''

@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def tex_storage3_d(target, levels, internalformat, width, height, depth):
    '''
    simultaneously specify storage for all levels of a three-dimensional, two-
dimensional array or cube-map array texture.
    
    Args:
        target: the target to which the texture object is bound for
            gltexstorage3d.
        levels: the number of texture levels.
        internalformat: the sized internal format to be used to store texture
            image data.
        width: the width of the texture, in texels.
        height: the height of the texture, in texels.
        depth: the depth of the texture, in texels.
    '''

@accepts(t.enum, t.uint, t.sizei)
@returns(t.void)
@binds(dll)
def draw_transform_feedback_instanced(mode, id, instancecount):
    '''
    render multiple instances of primitives using a count derived from a transform
feedback object.
    
    gl.draw_transform_feedback_instanced draws multiple copies of a range of
    primitives of a type specified by mode using a count retrieved from the
    transform feedback stream specified by stream of the transform feedback
    object specified by id. Calling gl.draw_transform_feedback_instanced is
    equivalent to calling gl.draw_arrays_instanced with mode and primcount as
    specified, first set to zero, and count set to the number of vertices
    captured on vertex stream zero the last time transform feedback was active
    on the transform feedback object named by id.
    
    Args:
        mode: what kind of primitives to render.
        id: the name of a transform feedback object from which to retrieve a
            primitive count.
        instancecount: the number of instances of the geometry to render.
    '''

@accepts(t.enum, t.uint, t.uint, t.sizei)
@returns(t.void)
@binds(dll)
def draw_transform_feedback_stream_instanced(mode, id, stream, instancecount):
    '''
    render multiple instances of primitives using a count derived from a specifed
stream of a transform feedback object.
    
    gl.draw_transform_feedback_stream_instanced draws multiple copies of a range
    of primitives of a type specified by mode using a count retrieved from the
    transform feedback stream specified by stream of the transform feedback
    object specified by id. Calling gl.draw_transform_feedback_stream_instanced
    is equivalent to calling gl.draw_arrays_instanced with mode and primcount as
    specified, first set to zero, and count set to the number of vertices
    captured on vertex stream stream the last time transform feedback was active
    on the transform feedback object named by id.
    
    Args:
        mode: what kind of primitives to render.
        id: the name of a transform feedback object from which to retrieve a
            primitive count.
        stream: the index of the transform feedback stream from which to
            retrieve a primitive count.
        instancecount: the number of instances of the geometry to render.
    '''
