#BEWARE: automatically generated code
#This code was generated by /generate/__main__.py

from opengl.gl.raw.bindings import *

MULTISAMPLE_LINE_WIDTH_RANGE = 0x9381
MULTISAMPLE_LINE_WIDTH_GRANULARITY = 0x9382
@accepts()
@returns(t.void)
@binds(dll)
def blend_barrier():
    pass

MULTIPLY = 0x9294
SCREEN = 0x9295
OVERLAY = 0x9296
DARKEN = 0x9297
LIGHTEN = 0x9298
COLORDODGE = 0x9299
COLORBURN = 0x929A
HARDLIGHT = 0x929B
SOFTLIGHT = 0x929C
DIFFERENCE = 0x929E
EXCLUSION = 0x92A0
HSL_HUE = 0x92AD
HSL_SATURATION = 0x92AE
HSL_COLOR = 0x92AF
HSL_LUMINOSITY = 0x92B0
@accepts(t.uint, t.enum, t.int, t.int, t.int, t.int, t.uint, t.enum, t.int, t.int, t.int, t.int, t.sizei, t.sizei, t.sizei)
@returns(t.void)
@binds(dll)
def copy_image_sub_data(srcname, srctarget, srclevel, srcx, srcy, srcz, dstname, dsttarget, dstlevel, dstx, dsty, dstz, srcwidth, srcheight, srcdepth):
    '''
    perform a raw data copy between two images.
    
    gl.copy_image_sub_data may be used to copy data from one image to another.
    gl.copy_image_sub_data does not perform general-purpose conversions such as
    scaling, resizing, blending, color-space, or format conversions.
    
    Args:
        srcname: the name of a texture or renderbuffer object from which to
            copy.
        srctarget: the target representing the namespace of the source name
            srcname.
        srclevel: the mipmap level to read from the source.
        srcx: the x coordinate of the left edge of the souce region to copy.
        srcy: the y coordinate of the top edge of the souce region to copy.
        srcz: the z coordinate of the near edge of the souce region to copy.
        dstname: the name of a texture or renderbuffer object to which to copy.
        dsttarget: the target representing the namespace of the destination name
            dstname.
        dstx: the x coordinate of the left edge of the destination region.
        dsty: the y coordinate of the top edge of the destination region.
        dstz: the z coordinate of the near edge of the destination region.
        srcwidth: the width of the region to be copied.
        srcheight: the height of the region to be copied.
        srcdepth: the depth of the region to be copied.
    '''

@accepts(t.enum, t.enum, t.enum, t.sizei, POINTER(t.uint), t.boolean)
@returns(t.void)
@binds(dll)
def debug_message_control(source, type, severity, count, ids, enabled):
    '''
    control the reporting of debug messages in a debug context.
    
    gl.debug_message_control controls the reporting of debug messages generated
    by a debug context. The parameters source, type and severity form a filter
    to select messages from the pool of potential messages generated by the GL.
    
    Args:
        source: the source of debug messages to enable or disable.
        type: the type of debug messages to enable or disable.
        severity: the severity of debug messages to enable or disable.
        count: the length of the array ids.
        ids: the address of an array of unsigned integers contianing the ids of
            the messages to enable or disable.
        enabled: a boolean flag determining whether the selected messages should
            be enabled or disabled.
    '''

@accepts(t.enum, t.enum, t.uint, t.enum, t.sizei, t.char_p)
@returns(t.void)
@binds(dll)
def debug_message_insert(source, type, id, severity, length, buf):
    '''
    inject an application-supplied message into the debug message queue.
    
    gl.debug_message_insert inserts a user-supplied message into the debug
    output queue. source specifies the source that will be used to classify the
    message and must be gl.DEBUG_SOURCE_APPLICATION or
    gl.DEBUG_SOURCE_THIRD_PARTY. All other sources are reserved for use by the
    GL implementation. type indicates the type of the message to be inserted and
    may be one of gl.DEBUG_TYPE_ERROR, gl.DEBUG_TYPE_DEPRECATED_BEHAVIOR,
    gl.DEBUG_TYPE_UNDEFINED_BEHAVIOR, gl.DEBUG_TYPE_PORTABILITY,
    gl.DEBUG_TYPE_PERFORMANCE, gl.DEBUG_TYPE_MARKER, gl.DEBUG_TYPE_PUSH_GROUP,
    gl.DEBUG_TYPE_POP_GROUP, or gl.DEBUG_TYPE_OTHER.
    
    Args:
        source: the source of the debug message to insert.
        type: the type of the debug message insert.
        id: the user-supplied identifier of the message to insert.
        severity: the severity of the debug messages to insert.
        length: the length string contained in the character array whose address
            is given by message.
        buf: the address of a character array containing the message to insert.
    '''

@accepts(t.DEBUGPROC, t.void)
@returns(t.void)
@binds(dll)
def debug_message_callback(callback, userparam):
    '''
    specify a callback to receive debugging messages from the GL.
    
    gl.debug_message_callback sets the current debug output callback function to
    the function whose address is given in callback.
    
    Args:
        callback: the address of a callback function that will be called when a
            debug message is generated.
        userparam: a user supplied pointer that will be passed on each
            invocation of callback.
    '''

@accepts(t.uint, t.sizei, POINTER(t.enum), POINTER(t.enum), POINTER(t.uint), POINTER(t.enum), POINTER(t.sizei), t.char_p)
@returns(t.uint)
@binds(dll)
def get_debug_message_log(count, bufsize, sources, types, ids, severities, lengths, messagelog):
    '''
    retrieve messages from the debug message log.
    
    gl.get_debug_message_log retrieves messages from the debug message log. A
    maximum of count messages are retrieved from the log. If sources is not None
    then the source of each message is written into up to count elements of the
    array. If types is not None then the type of each message is written into up
    to count elements of the array.
    
    Args:
        count: the number of debug messages to retrieve from the log.
        bufsize: the size of the buffer whose address is given by messagelog.
        sources: the address of an array of variables to receive the sources of
            the retrieved messages.
        types: the address of an array of variables to receive the types of the
            retrieved messages.
        ids: the address of an array of unsigned integers to receive the ids of
            the retrieved messages.
        severities: the address of an array of variables to receive the
            severites of the retrieved messages.
        lengths: the address of an array of variables to receive the lengths of
            the received messages.
        messagelog: the address of an array of characters that will receive the
            messages.
    '''

@accepts(t.enum, t.uint, t.sizei, t.char_p)
@returns(t.void)
@binds(dll)
def push_debug_group(source, id, length, message):
    '''
    push a named debug group into the command stream.
    
    gl.push_debug_group pushes a debug group described by the string message
    into the command stream. The value of id specifies the ID of messages
    generated. The parameter length contains the number of characters in
    message. If length is negative, it is implied that message contains a null
    terminated string.
    
    Args:
        source: the source of the debug message.
        id: the identifier of the message.
        length: the length of the message to be sent to the debug output stream.
        message: the a string containing the message to be sent to the debug
            output stream.
    '''

@accepts()
@returns(t.void)
@binds(dll)
def pop_debug_group():
    '''
    pop the active debug group.
    '''

@accepts(t.enum, t.uint, t.sizei, t.char_p)
@returns(t.void)
@binds(dll)
def object_label(identifier, name, length, label):
    '''
    label a named object identified within a namespace.
    
    gl.object_label labels the object identified by name within the namespace
    given by identifier. identifier must be one of gl.BUFFER, gl.SHADER,
    gl.PROGRAM, gl.VERTEX_ARRAY, gl.QUERY, gl.PROGRAM_PIPELINE,
    gl.TRANSFORM_FEEDBACK, gl.SAMPLER, gl.TEXTURE, gl.RENDERBUFFER,
    gl.FRAMEBUFFER, to indicate the namespace containing the names of buffers,
    shaders, programs, vertex array objects, query objects, program pipelines,
    transform feedback objects, samplers, textures, renderbuffers and frame
    buffers, respectively.
    
    Args:
        identifier: the namespace from which the name of the object is
            allocated.
        name: the name of the object to label.
        length: the length of the label to be used for the object.
        label: the address of a string containing the label to assign to the
            object.
    '''

@accepts(t.enum, t.uint, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_object_label(identifier, name, bufsize, length, label):
    '''
    retrieve the label of a named object identified within a namespace.
    
    gl.get_object_label retrieves the label of the object identified by name
    within the namespace given by identifier. identifier must be one of
    gl.BUFFER, gl.SHADER, gl.PROGRAM, gl.VERTEX_ARRAY, gl.QUERY,
    gl.PROGRAM_PIPELINE, gl.TRANSFORM_FEEDBACK, gl.SAMPLER, gl.TEXTURE,
    gl.RENDERBUFFER, gl.FRAMEBUFFER, to indicate the namespace containing the
    names of buffers, shaders, programs, vertex array objects, query objects,
    program pipelines, transform feedback objects, samplers, textures,
    renderbuffers and frame buffers, respectively.
    
    Args:
        identifier: the namespace from which the name of the object is
            allocated.
        name: the name of the object whose label to retrieve.
        length: the address of a variable to receive the length of the object
            label.
        label: the address of a string that will receive the object label.
    '''

@accepts(t.void, t.sizei, t.char_p)
@returns(t.void)
@binds(dll)
def object_ptr_label(ptr, length, label):
    '''
    label a a sync object identified by a pointer.
    
    gl.object_ptr_label labels the sync object identified by ptr.
    
    Args:
        ptr: a pointer identifying a sync object.
        length: the length of the label to be used for the object.
        label: the address of a string containing the label to assign to the
            object.
    '''

@accepts(t.void, t.sizei, POINTER(t.sizei), t.char_p)
@returns(t.void)
@binds(dll)
def get_object_ptr_label(ptr, bufsize, length, label):
    '''
    retrieve the label of a sync object identified by a pointer.
    
    gl.get_object_ptr_label retrieves the label of the sync object identified by
    ptr.
    
    Args:
        ptr: the name of the sync object whose label to retrieve.
        length: the address of a variable to receive the length of the object
            label.
        label: the address of a string that will receive the object label.
    '''

@accepts(t.enum, t.void)
@returns(t.void)
@binds(dll)
def get_pointerv(pname, params):
    '''
    return the address of the specified pointer.
    
    gl.get_pointerv returns pointer information. pname indicates the pointer to
    be returned, and params is a pointer to a location in which to place the
    returned data.
    
    Args:
        pname: the pointer to be returned.
        params: returns the pointer value specified by pname.
    '''

DEBUG_OUTPUT_SYNCHRONOUS = 0x8242
DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243
DEBUG_CALLBACK_FUNCTION = 0x8244
DEBUG_CALLBACK_USER_PARAM = 0x8245
DEBUG_SOURCE_API = 0x8246
DEBUG_SOURCE_WINDOW_SYSTEM = 0x8247
DEBUG_SOURCE_SHADER_COMPILER = 0x8248
DEBUG_SOURCE_THIRD_PARTY = 0x8249
DEBUG_SOURCE_APPLICATION = 0x824A
DEBUG_SOURCE_OTHER = 0x824B
DEBUG_TYPE_ERROR = 0x824C
DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D
DEBUG_TYPE_UNDEFINED_BEHAVIOR = 0x824E
DEBUG_TYPE_PORTABILITY = 0x824F
DEBUG_TYPE_PERFORMANCE = 0x8250
DEBUG_TYPE_OTHER = 0x8251
DEBUG_TYPE_MARKER = 0x8268
DEBUG_TYPE_PUSH_GROUP = 0x8269
DEBUG_TYPE_POP_GROUP = 0x826A
DEBUG_SEVERITY_NOTIFICATION = 0x826B
MAX_DEBUG_GROUP_STACK_DEPTH = 0x826C
DEBUG_GROUP_STACK_DEPTH = 0x826D
BUFFER = 0x82E0
SHADER = 0x82E1
PROGRAM = 0x82E2
VERTEX_ARRAY = 0x8074
QUERY = 0x82E3
PROGRAM_PIPELINE = 0x82E4
SAMPLER = 0x82E6
MAX_LABEL_LENGTH = 0x82E8
MAX_DEBUG_MESSAGE_LENGTH = 0x9143
MAX_DEBUG_LOGGED_MESSAGES = 0x9144
DEBUG_LOGGED_MESSAGES = 0x9145
DEBUG_SEVERITY_HIGH = 0x9146
DEBUG_SEVERITY_MEDIUM = 0x9147
DEBUG_SEVERITY_LOW = 0x9148
DEBUG_OUTPUT = 0x92E0
CONTEXT_FLAG_DEBUG_BIT = 0x00000002
STACK_OVERFLOW = 0x0503
STACK_UNDERFLOW = 0x0504
@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def enablei(target, index):
    pass

@accepts(t.enum, t.uint)
@returns(t.void)
@binds(dll)
def disablei(target, index):
    pass

@accepts(t.uint, t.enum)
@returns(t.void)
@binds(dll)
def blend_equationi(buf, mode):
    pass

@accepts(t.uint, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_equation_separatei(buf, modergb, modealpha):
    pass

@accepts(t.uint, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_funci(buf, src, dst):
    pass

@accepts(t.uint, t.enum, t.enum, t.enum, t.enum)
@returns(t.void)
@binds(dll)
def blend_func_separatei(buf, srcrgb, dstrgb, srcalpha, dstalpha):
    pass

@accepts(t.uint, t.boolean, t.boolean, t.boolean, t.boolean)
@returns(t.void)
@binds(dll)
def color_maski(index, r, g, b, a):
    pass

@accepts(t.enum, t.uint)
@returns(t.boolean)
@binds(dll)
def is_enabledi(target, index):
    pass

@accepts(t.enum, t.sizei, t.enum, t.void, t.int)
@returns(t.void)
@binds(dll)
def draw_elements_base_vertex(mode, count, type, indices, basevertex):
    '''
    render primitives from array data with a per-element offset.
    
    gl.draw_elements_base_vertex behaves identically to gl.draw_elements except
    that the ith element transferred by the corresponding draw call will be
    taken from element indices[i] + basevertex of each enabled array. If the
    resulting value is larger than the maximum value representable by type, it
    is as if the calculation were upconverted to 32-bit unsigned integers. The
    operation is undefined if the sum would be negative.
    
    Args:
        mode: what kind of primitives to render.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        basevertex: a constant that should be added to each element of indices
            when chosing elements from the enabled vertex arrays.
    '''

@accepts(t.enum, t.uint, t.uint, t.sizei, t.enum, t.void, t.int)
@returns(t.void)
@binds(dll)
def draw_range_elements_base_vertex(mode, start, end, count, type, indices, basevertex):
    '''
    render primitives from array data with a per-element offset.
    
    gl.draw_range_elements_base_vertex is a restricted form of
    gl.draw_elements_base_vertex. mode, start, end, count and basevertex match
    the corresponding arguments to gl.draw_elements_base_vertex, with the
    additional constraint that all values in the array indices must lie between
    start and end, inclusive, prior to adding basevertex. Index values lying
    outside the range [start, end] are treated in the same way as
    gl.draw_elements_base_vertex. The ith element transferred by the
    corresponding draw call will be taken from element indices[i] + basevertex
    of each enabled array.
    
    Args:
        mode: what kind of primitives to render.
        start: the minimum array index contained in indices.
        end: the maximum array index contained in indices.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        basevertex: a constant that should be added to each element of indices
            when chosing elements from the enabled vertex arrays.
    '''

@accepts(t.enum, t.sizei, t.enum, t.void, t.sizei, t.int)
@returns(t.void)
@binds(dll)
def draw_elements_instanced_base_vertex(mode, count, type, indices, instancecount, basevertex):
    '''
    render multiple instances of a set of primitives from array data with a per-
element offset.
    
    gl.draw_elements_instanced_base_vertex behaves identically to
    gl.draw_elements_instanced except that the ith element transferred by the
    corresponding draw call will be taken from element indices[i] + basevertex
    of each enabled array. If the resulting value is larger than the maximum
    value representable by type, it is as if the calculation were upconverted to
    32-bit unsigned integers. The operation is undefined if the sum would be
    negative.
    
    Args:
        mode: what kind of primitives to render.
        count: the number of elements to be rendered.
        type: the type of the values in indices.
        indices: a pointer to the location where the indices are stored.
        instancecount: the number of instances of the indexed geometry that
            should be drawn.
        basevertex: a constant that should be added to each element of indices
            when chosing elements from the enabled vertex arrays.
    '''

@accepts(t.enum, t.enum, t.uint, t.int)
@returns(t.void)
@binds(dll)
def framebuffer_texture(target, attachment, texture, level):
    '''
    attach a level of a texture object as a logical buffer of a framebuffer object.
    
    Args:
        target: the target to which the framebuffer is bound for all commands
            except glnamedframebuffertexture.
        attachment: the attachment point of the framebuffer.
        texture: the name of an existing texture object to attach.
        level: the mipmap level of the texture object to attach.
    '''

GEOMETRY_SHADER = 0x8DD9
GEOMETRY_SHADER_BIT = 0x00000004
GEOMETRY_VERTICES_OUT = 0x8916
GEOMETRY_INPUT_TYPE = 0x8917
GEOMETRY_OUTPUT_TYPE = 0x8918
GEOMETRY_SHADER_INVOCATIONS = 0x887F
LAYER_PROVOKING_VERTEX = 0x825E
LINES_ADJACENCY = 0x000A
LINE_STRIP_ADJACENCY = 0x000B
TRIANGLES_ADJACENCY = 0x000C
TRIANGLE_STRIP_ADJACENCY = 0x000D
MAX_GEOMETRY_UNIFORM_COMPONENTS = 0x8DDF
MAX_GEOMETRY_UNIFORM_BLOCKS = 0x8A2C
MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32
MAX_GEOMETRY_INPUT_COMPONENTS = 0x9123
MAX_GEOMETRY_OUTPUT_COMPONENTS = 0x9124
MAX_GEOMETRY_OUTPUT_VERTICES = 0x8DE0
MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS = 0x8DE1
MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A
MAX_GEOMETRY_TEXTURE_IMAGE_UNITS = 0x8C29
MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF
MAX_GEOMETRY_ATOMIC_COUNTERS = 0x92D5
MAX_GEOMETRY_IMAGE_UNIFORMS = 0x90CD
MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7
FIRST_VERTEX_CONVENTION = 0x8E4D
LAST_VERTEX_CONVENTION = 0x8E4E
UNDEFINED_VERTEX = 0x8260
PRIMITIVES_GENERATED = 0x8C87
FRAMEBUFFER_DEFAULT_LAYERS = 0x9312
MAX_FRAMEBUFFER_LAYERS = 0x9317
FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS = 0x8DA8
FRAMEBUFFER_ATTACHMENT_LAYERED = 0x8DA7
REFERENCED_BY_GEOMETRY_SHADER = 0x9309
@accepts(t.float, t.float, t.float, t.float, t.float, t.float, t.float, t.float)
@returns(t.void)
@binds(dll)
def primitive_bounding_box(minx, miny, minz, minw, maxx, maxy, maxz, maxw):
    pass

PRIMITIVE_BOUNDING_BOX = 0x92BE
@accepts()
@returns(t.enum)
@binds(dll)
def get_graphics_reset_status():
    '''
    check if the rendering context has not been lost due to software or hardware
issues.
    '''

@accepts(t.int, t.int, t.sizei, t.sizei, t.enum, t.enum, t.sizei, t.void)
@returns(t.void)
@binds(dll)
def readn_pixels(x, y, width, height, format, type, bufsize, data):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.float))
@returns(t.void)
@binds(dll)
def getn_uniformfv(program, location, bufsize, params):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.int))
@returns(t.void)
@binds(dll)
def getn_uniformiv(program, location, bufsize, params):
    pass

@accepts(t.uint, t.int, t.sizei, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def getn_uniformuiv(program, location, bufsize, params):
    pass

NO_ERROR = 0
CONTEXT_FLAG_ROBUST_ACCESS_BIT = 0x00000004
CONTEXT_FLAGS = 0x821E
LOSE_CONTEXT_ON_RESET = 0x8252
GUILTY_CONTEXT_RESET = 0x8253
INNOCENT_CONTEXT_RESET = 0x8254
UNKNOWN_CONTEXT_RESET = 0x8255
RESET_NOTIFICATION_STRATEGY = 0x8256
NO_RESET_NOTIFICATION = 0x8261
CONTEXT_LOST = 0x0507
@accepts(t.float)
@returns(t.void)
@binds(dll)
def min_sample_shading(value):
    '''
    specifies minimum rate at which sample shaing takes place.
    
    gl.min_sample_shading specifies the rate at which samples are shaded within
    a covered pixel. Sample-rate shading is enabled by calling gl.enable with
    the parameter gl.SAMPLE_SHADING. If gl.MULTISAMPLE or gl.SAMPLE_SHADING is
    disabled, sample shading has no effect. Otherwise, an implementation must
    provide at least as many unique color values for each covered fragment as
    specified by value times samples where samples is the value of gl.SAMPLES
    for the current framebuffer.
    
    Args:
        value: the rate at which samples are shaded within each covered pixel.
    '''

SAMPLE_SHADING = 0x8C36
MIN_SAMPLE_SHADING_VALUE = 0x8C37
MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B
MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C
FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D
@accepts(t.enum, t.int)
@returns(t.void)
@binds(dll)
def patch_parameteri(pname, value):
    pass

PATCHES = 0x000E
PATCH_VERTICES = 0x8E72
TESS_CONTROL_OUTPUT_VERTICES = 0x8E75
TESS_GEN_MODE = 0x8E76
TESS_GEN_SPACING = 0x8E77
TESS_GEN_VERTEX_ORDER = 0x8E78
TESS_GEN_POINT_MODE = 0x8E79
TRIANGLES = 0x0004
ISOLINES = 0x8E7A
QUADS = 0x0007
EQUAL = 0x0202
FRACTIONAL_ODD = 0x8E7B
FRACTIONAL_EVEN = 0x8E7C
CCW = 0x0901
CW = 0x0900
MAX_PATCH_VERTICES = 0x8E7D
MAX_TESS_GEN_LEVEL = 0x8E7E
MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F
MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80
MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81
MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82
MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83
MAX_TESS_PATCH_COMPONENTS = 0x8E84
MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85
MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86
MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89
MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A
MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C
MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D
MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E
MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F
MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD
MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE
MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3
MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4
MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB
MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC
MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8
MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9
PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = 0x8221
IS_PER_PATCH = 0x92E7
REFERENCED_BY_TESS_CONTROL_SHADER = 0x9307
REFERENCED_BY_TESS_EVALUATION_SHADER = 0x9308
TESS_CONTROL_SHADER = 0x8E88
TESS_EVALUATION_SHADER = 0x8E87
TESS_CONTROL_SHADER_BIT = 0x00000008
TESS_EVALUATION_SHADER_BIT = 0x00000010
@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def tex_parameter_iiv(target, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def tex_parameter_iuiv(target, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_tex_parameter_iiv(target, pname, params):
    pass

@accepts(t.enum, t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_tex_parameter_iuiv(target, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def sampler_parameter_iiv(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def sampler_parameter_iuiv(sampler, pname, param):
    pass

@accepts(t.uint, t.enum, POINTER(t.int))
@returns(t.void)
@binds(dll)
def get_sampler_parameter_iiv(sampler, pname, params):
    pass

@accepts(t.uint, t.enum, POINTER(t.uint))
@returns(t.void)
@binds(dll)
def get_sampler_parameter_iuiv(sampler, pname, params):
    pass

TEXTURE_BORDER_COLOR = 0x1004
CLAMP_TO_BORDER = 0x812D
@accepts(t.enum, t.enum, t.uint)
@returns(t.void)
@binds(dll)
def tex_buffer(target, internalformat, buffer):
    '''
    attach a buffer object's data store to a buffer texture object.
    
    gl.tex_buffer and gl.texture_buffer attaches the data store of a specified
    buffer object to a specified texture object, and specify the storage format
    for the texture image found found in the buffer object. The texture object
    must be a buffer texture.
    
    Args:
        target: the target to which the texture is bound for gltexbuffer.
        internalformat: the internal format of the data in the store belonging
            to buffer.
        buffer: the name of the buffer object whose storage to attach to the
            active buffer texture.
    '''

@accepts(t.enum, t.enum, t.uint, t.intptr, t.sizeiptr)
@returns(t.void)
@binds(dll)
def tex_buffer_range(target, internalformat, buffer, offset, size):
    '''
    attach a range of a buffer object's data store to a buffer texture object.
    
    gl.tex_buffer_range and gl.texture_buffer_range attach a range of the data
    store of a specified buffer object to a specified texture object, and
    specify the storage format for the texture image found found in the buffer
    object. The texture object must be a buffer texture.
    
    Args:
        target: the target to which the texture object is bound for
            gltexbufferrange.
        internalformat: the internal format of the data in the store belonging
            to buffer.
        buffer: the name of the buffer object whose storage to attach to the
            active buffer texture.
        offset: the offset of the start of the range of the buffer's data store
            to attach.
        size: the size of the range of the buffer's data store to attach.
    '''

TEXTURE_BUFFER = 0x8C2A
TEXTURE_BUFFER_BINDING = 0x8C2A
MAX_TEXTURE_BUFFER_SIZE = 0x8C2B
TEXTURE_BINDING_BUFFER = 0x8C2C
TEXTURE_BUFFER_DATA_STORE_BINDING = 0x8C2D
TEXTURE_BUFFER_OFFSET_ALIGNMENT = 0x919F
SAMPLER_BUFFER = 0x8DC2
INT_SAMPLER_BUFFER = 0x8DD0
UNSIGNED_INT_SAMPLER_BUFFER = 0x8DD8
IMAGE_BUFFER = 0x9051
INT_IMAGE_BUFFER = 0x905C
UNSIGNED_INT_IMAGE_BUFFER = 0x9067
TEXTURE_BUFFER_OFFSET = 0x919D
TEXTURE_BUFFER_SIZE = 0x919E
COMPRESSED_RGBA_ASTC_4x4 = 0x93B0
COMPRESSED_RGBA_ASTC_5x4 = 0x93B1
COMPRESSED_RGBA_ASTC_5x5 = 0x93B2
COMPRESSED_RGBA_ASTC_6x5 = 0x93B3
COMPRESSED_RGBA_ASTC_6x6 = 0x93B4
COMPRESSED_RGBA_ASTC_8x5 = 0x93B5
COMPRESSED_RGBA_ASTC_8x6 = 0x93B6
COMPRESSED_RGBA_ASTC_8x8 = 0x93B7
COMPRESSED_RGBA_ASTC_10x5 = 0x93B8
COMPRESSED_RGBA_ASTC_10x6 = 0x93B9
COMPRESSED_RGBA_ASTC_10x8 = 0x93BA
COMPRESSED_RGBA_ASTC_10x10 = 0x93BB
COMPRESSED_RGBA_ASTC_12x10 = 0x93BC
COMPRESSED_RGBA_ASTC_12x12 = 0x93BD
COMPRESSED_SRGB8_ALPHA8_ASTC_4x4 = 0x93D0
COMPRESSED_SRGB8_ALPHA8_ASTC_5x4 = 0x93D1
COMPRESSED_SRGB8_ALPHA8_ASTC_5x5 = 0x93D2
COMPRESSED_SRGB8_ALPHA8_ASTC_6x5 = 0x93D3
COMPRESSED_SRGB8_ALPHA8_ASTC_6x6 = 0x93D4
COMPRESSED_SRGB8_ALPHA8_ASTC_8x5 = 0x93D5
COMPRESSED_SRGB8_ALPHA8_ASTC_8x6 = 0x93D6
COMPRESSED_SRGB8_ALPHA8_ASTC_8x8 = 0x93D7
COMPRESSED_SRGB8_ALPHA8_ASTC_10x5 = 0x93D8
COMPRESSED_SRGB8_ALPHA8_ASTC_10x6 = 0x93D9
COMPRESSED_SRGB8_ALPHA8_ASTC_10x8 = 0x93DA
COMPRESSED_SRGB8_ALPHA8_ASTC_10x10 = 0x93DB
COMPRESSED_SRGB8_ALPHA8_ASTC_12x10 = 0x93DC
COMPRESSED_SRGB8_ALPHA8_ASTC_12x12 = 0x93DD
TEXTURE_CUBE_MAP_ARRAY = 0x9009
TEXTURE_BINDING_CUBE_MAP_ARRAY = 0x900A
SAMPLER_CUBE_MAP_ARRAY = 0x900C
SAMPLER_CUBE_MAP_ARRAY_SHADOW = 0x900D
INT_SAMPLER_CUBE_MAP_ARRAY = 0x900E
UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY = 0x900F
IMAGE_CUBE_MAP_ARRAY = 0x9054
INT_IMAGE_CUBE_MAP_ARRAY = 0x905F
UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A
STENCIL_INDEX = 0x1901
STENCIL_INDEX8 = 0x8D48
@accepts(t.enum, t.sizei, t.enum, t.sizei, t.sizei, t.sizei, t.boolean)
@returns(t.void)
@binds(dll)
def tex_storage3_d_multisample(target, samples, internalformat, width, height, depth, fixedsamplelocations):
    '''
    specify storage for a two-dimensional multisample array texture.
    
    Args:
        target: the target to which the texture object is bound for
            gltexstorage3dmultisample.
        samples: the number of samples in the texture.
        internalformat: the sized internal format to be used to store texture
            image data.
        width: the width of the texture, in texels.
        height: the height of the texture, in texels.
        depth: the depth of the texture, in layers.
        fixedsamplelocations: whether the image will use identical sample
            locations and the same number of samples for all texels in the
            image, and the sample locations will not depend on the internal
            format or size of the image.
    '''

TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9102
TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105
SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910B
INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C
UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D